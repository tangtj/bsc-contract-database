{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\u0027t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\u0027t, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"},"IFactory.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IFactory {\n    function isPair(address pair) external view returns (bool);\n\n    function getInitializable()\n        external\n        view\n        returns (\n            address,\n            address,\n            bool\n        );\n\n    function pairCodeHash() external pure returns (bytes32);\n\n    function getPair(\n        address tokenA,\n        address token,\n        bool stable\n    ) external view returns (address);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external returns (address pair);\n}\n"},"IPair.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IPair {\n    // Structure to capture time period obervations every 30 minutes, used for local oracles\n    struct Observation {\n        uint256 timestamp;\n        uint256 reserve0Cumulative;\n        uint256 reserve1Cumulative;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        );\n\n    function getAmountOut(uint256, address) external view returns (uint256);\n\n    function claimFees() external returns (uint256, uint256);\n\n    function tokens() external returns (address, address);\n\n    function token0() external returns (address);\n\n    function token1() external returns (address);\n}\n"},"IWETH.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IWETH {\n    function name() external view returns (string memory);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function symbol() external view returns (string memory);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function deposit() external payable;\n\n    function allowance(address, address) external view returns (uint256);\n}\n"},"Math.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nlibrary Math {\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e= b ? a : b;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    function positiveInt128(int128 value) internal pure returns (int128) {\n        return value \u003c 0 ? int128(0) : value;\n    }\n\n    function closeTo(\n        uint256 a,\n        uint256 b,\n        uint256 target\n    ) internal pure returns (bool) {\n        if (a \u003e b) {\n            if (a - b \u003c= target) {\n                return true;\n            }\n        } else {\n            if (b - a \u003c= target) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y \u003e 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x \u003c z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.13;\n\nimport \"./IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"},"USDFIRouter.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./Math.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./IERC20.sol\";\nimport \"./IWETH.sol\";\nimport \"./IPair.sol\";\nimport \"./IFactory.sol\";\n\ncontract USDFIRouterV2 {\n    using SafeERC20 for IERC20;\n\n    struct Route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    address public immutable factory;\n    IWETH public immutable weth;\n    uint256 internal constant MINIMUM_LIQUIDITY = 10**3;\n    bytes32 immutable pairCodeHash;\n\n    modifier ensure(uint256 deadline) {\n        require(deadline \u003e= block.timestamp, \"DystRouter: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _weth) {\n        factory = _factory;\n        pairCodeHash = IFactory(_factory).pairCodeHash();\n        weth = IWETH(_weth);\n    }\n\n    receive() external payable {\n        // only accept ETH via fallback from the WETH contract\n        require(msg.sender == address(weth), \"DystRouter: NOT_WETH\");\n    }\n\n    function sortTokens(address tokenA, address tokenB)\n        external\n        pure\n        returns (address token0, address token1)\n    {\n        return _sortTokens(tokenA, tokenB);\n    }\n\n    function _sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"DystRouter: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA \u003c tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"DystRouter: ZERO_ADDRESS\");\n    }\n\n    function pairFor(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (address pair) {\n        return _pairFor(tokenA, tokenB, stable);\n    }\n\n    /// @dev Calculates the CREATE2 address for a pair without making any external calls.\n    function _pairFor(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) internal view returns (address pair) {\n        (address token0, address token1) = _sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1, stable)),\n                            pairCodeHash // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function quoteLiquidity(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB) {\n        return _quoteLiquidity(amountA, reserveA, reserveB);\n    }\n\n    /// @dev Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset.\n    function _quoteLiquidity(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA \u003e 0, \"DystRouter: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA \u003e 0 \u0026\u0026 reserveB \u003e 0,\n            \"DystRouter: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    function getReserves(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (uint256 reserveA, uint256 reserveB) {\n        return _getReserves(tokenA, tokenB, stable);\n    }\n\n    /// @dev Fetches and sorts the reserves for a pair.\n    function _getReserves(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = _sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IPair(\n            _pairFor(tokenA, tokenB, stable)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    /// @dev Performs chained getAmountOut calculations on any number of pairs.\n    function getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut\n    ) external view returns (uint256 amount, bool stable) {\n        address pair = _pairFor(tokenIn, tokenOut, true);\n        uint256 amountStable;\n        uint256 amountVolatile;\n        if (IFactory(factory).isPair(pair)) {\n            amountStable = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        pair = _pairFor(tokenIn, tokenOut, false);\n        if (IFactory(factory).isPair(pair)) {\n            amountVolatile = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        return\n            amountStable \u003e amountVolatile\n                ? (amountStable, true)\n                : (amountVolatile, false);\n    }\n\n    function getExactAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    ) external view returns (uint256) {\n        address pair = _pairFor(tokenIn, tokenOut, stable);\n        if (IFactory(factory).isPair(pair)) {\n            return IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        return 0;\n    }\n\n    /// @dev Performs chained getAmountOut calculations on any number of pairs.\n    function getAmountsOut(uint256 amountIn, Route[] memory routes)\n        external\n        view\n        returns (uint256[] memory amounts)\n    {\n        return _getAmountsOut(amountIn, routes);\n    }\n\n    function _getAmountsOut(uint256 amountIn, Route[] memory routes)\n        internal\n        view\n        returns (uint256[] memory amounts)\n    {\n        require(routes.length \u003e= 1, \"DystRouter: INVALID_PATH\");\n        amounts = new uint256[](routes.length + 1);\n        amounts[0] = amountIn;\n        for (uint256 i = 0; i \u003c routes.length; i++) {\n            address pair = _pairFor(\n                routes[i].from,\n                routes[i].to,\n                routes[i].stable\n            );\n            if (IFactory(factory).isPair(pair)) {\n                amounts[i + 1] = IPair(pair).getAmountOut(\n                    amounts[i],\n                    routes[i].from\n                );\n            }\n        }\n    }\n\n    function isPair(address pair) external view returns (bool) {\n        return IFactory(factory).isPair(pair);\n    }\n\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    )\n        external\n        view\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        // create the pair if it doesn\u0027t exist yet\n        address _pair = IFactory(factory).getPair(tokenA, tokenB, stable);\n        (uint256 reserveA, uint256 reserveB) = (0, 0);\n        uint256 _totalSupply = 0;\n        if (_pair != address(0)) {\n            _totalSupply = IERC20(_pair).totalSupply();\n            (reserveA, reserveB) = _getReserves(tokenA, tokenB, stable);\n        }\n        if (reserveA == 0 \u0026\u0026 reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\n        } else {\n            uint256 amountBOptimal = _quoteLiquidity(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal \u003c= amountBDesired) {\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n                liquidity = Math.min(\n                    (amountA * _totalSupply) / reserveA,\n                    (amountB * _totalSupply) / reserveB\n                );\n            } else {\n                uint256 amountAOptimal = _quoteLiquidity(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n                liquidity = Math.min(\n                    (amountA * _totalSupply) / reserveA,\n                    (amountB * _totalSupply) / reserveB\n                );\n            }\n        }\n    }\n\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 liquidity\n    ) external view returns (uint256 amountA, uint256 amountB) {\n        // create the pair if it doesn\u0027t exist yet\n        address _pair = IFactory(factory).getPair(tokenA, tokenB, stable);\n\n        if (_pair == address(0)) {\n            return (0, 0);\n        }\n\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\n            tokenA,\n            tokenB,\n            stable\n        );\n        uint256 _totalSupply = IERC20(_pair).totalSupply();\n        // using balances ensures pro-rata distribution\n        amountA = (liquidity * reserveA) / _totalSupply;\n        // using balances ensures pro-rata distribution\n        amountB = (liquidity * reserveB) / _totalSupply;\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        require(amountADesired \u003e= amountAMin, \"DystRouter: DESIRED_A_AMOUNT\");\n        require(amountBDesired \u003e= amountBMin, \"DystRouter: DESIRED_B_AMOUNT\");\n        // create the pair if it doesn\u0027t exist yet\n        address _pair = IFactory(factory).getPair(tokenA, tokenB, stable);\n        if (_pair == address(0)) {\n            _pair = IFactory(factory).createPair(tokenA, tokenB, stable);\n        }\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\n            tokenA,\n            tokenB,\n            stable\n        );\n        if (reserveA == 0 \u0026\u0026 reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = _quoteLiquidity(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal \u003c= amountBDesired) {\n                require(\n                    amountBOptimal \u003e= amountBMin,\n                    \"DystRouter: INSUFFICIENT_B_AMOUNT\"\n                );\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = _quoteLiquidity(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal \u003c= amountADesired);\n                require(\n                    amountAOptimal \u003e= amountAMin,\n                    \"DystRouter: INSUFFICIENT_A_AMOUNT\"\n                );\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        (amountA, amountB) = _addLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            amountADesired,\n            amountBDesired,\n            amountAMin,\n            amountBMin\n        );\n        address pair = _pairFor(tokenA, tokenB, stable);\n        SafeERC20.safeTransferFrom(IERC20(tokenA), msg.sender, pair, amountA);\n        SafeERC20.safeTransferFrom(IERC20(tokenB), msg.sender, pair, amountB);\n        liquidity = IPair(pair).mint(to);\n    }\n\n    function addLiquidityETH(\n        address token,\n        bool stable,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        ensure(deadline)\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            address(weth),\n            stable,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = _pairFor(token, address(weth), stable);\n        IERC20(token).safeTransferFrom(msg.sender, pair, amountToken);\n        weth.deposit{value: amountETH}();\n        assert(weth.transfer(pair, amountETH));\n        liquidity = IPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value \u003e amountETH)\n            _safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB) {\n        return\n            _removeLiquidity(\n                tokenA,\n                tokenB,\n                stable,\n                liquidity,\n                amountAMin,\n                amountBMin,\n                to,\n                deadline\n            );\n    }\n\n    function _removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) internal ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        address pair = _pairFor(tokenA, tokenB, stable);\n        IERC20(pair).safeTransferFrom(msg.sender, pair, liquidity);\n        // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = IPair(pair).burn(to);\n        (address token0, ) = _sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n        require(amountA \u003e= amountAMin, \"DystRouter: INSUFFICIENT_A_AMOUNT\");\n        require(amountB \u003e= amountBMin, \"DystRouter: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidityETH(\n        address token,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH) {\n        return\n            _removeLiquidityETH(\n                token,\n                stable,\n                liquidity,\n                amountTokenMin,\n                amountETHMin,\n                to,\n                deadline\n            );\n    }\n\n    function _removeLiquidityETH(\n        address token,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        internal\n        ensure(deadline)\n        returns (uint256 amountToken, uint256 amountETH)\n    {\n        (amountToken, amountETH) = _removeLiquidity(\n            token,\n            address(weth),\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        IERC20(token).safeTransfer(to, amountToken);\n        weth.withdraw(amountETH);\n        _safeTransferETH(to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB) {\n        address pair = _pairFor(tokenA, tokenB, stable);\n        {\n            uint256 value = approveMax ? type(uint256).max : liquidity;\n            IPair(pair).permit(\n                msg.sender,\n                address(this),\n                value,\n                deadline,\n                v,\n                r,\n                s\n            );\n        }\n\n        (amountA, amountB) = _removeLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            liquidity,\n            amountAMin,\n            amountBMin,\n            to,\n            deadline\n        );\n    }\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH) {\n        address pair = _pairFor(token, address(weth), stable);\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = _removeLiquidityETH(\n            token,\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            to,\n            deadline\n        );\n    }\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountFTMMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountFTM) {\n        return\n            _removeLiquidityETHSupportingFeeOnTransferTokens(\n                token,\n                stable,\n                liquidity,\n                amountTokenMin,\n                amountFTMMin,\n                to,\n                deadline\n            );\n    }\n\n    function _removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountFTMMin,\n        address to,\n        uint256 deadline\n    )\n        internal\n        ensure(deadline)\n        returns (uint256 amountToken, uint256 amountFTM)\n    {\n        (amountToken, amountFTM) = _removeLiquidity(\n            token,\n            address(weth),\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountFTMMin,\n            address(this),\n            deadline\n        );\n        IERC20(token).safeTransfer(to, IERC20(token).balanceOf(address(this)));\n        weth.withdraw(amountFTM);\n        _safeTransferETH(to, amountFTM);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountFTMMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountFTM) {\n        address pair = _pairFor(token, address(weth), stable);\n        uint256 value = approveMax ? type(uint256).max : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (\n            amountToken,\n            amountFTM\n        ) = _removeLiquidityETHSupportingFeeOnTransferTokens(\n            token,\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountFTMMin,\n            to,\n            deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        uint256[] memory amounts,\n        Route[] memory routes,\n        address _to\n    ) internal virtual {\n        for (uint256 i = 0; i \u003c routes.length; i++) {\n            (address token0, ) = _sortTokens(routes[i].from, routes[i].to);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = routes[i].from == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n            address to = i \u003c routes.length - 1\n                ? _pairFor(\n                    routes[i + 1].from,\n                    routes[i + 1].to,\n                    routes[i + 1].stable\n                )\n                : _to;\n            IPair(_pairFor(routes[i].from, routes[i].to, routes[i].stable))\n                .swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function _swapSupportingFeeOnTransferTokens(\n        Route[] memory routes,\n        address _to\n    ) internal virtual {\n        for (uint256 i; i \u003c routes.length; i++) {\n            (address input, address output) = (routes[i].from, routes[i].to);\n            (address token0, ) = _sortTokens(input, output);\n            IPair pair = IPair(\n                _pairFor(routes[i].from, routes[i].to, routes[i].stable)\n            );\n            uint256 amountInput;\n            uint256 amountOutput;\n            {\n                // scope to avoid stack too deep errors\n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n                uint256 reserveInput = input == token0 ? reserve0 : reserve1;\n                amountInput =\n                    IERC20(input).balanceOf(address(pair)) -\n                    reserveInput;\n                //(amountOutput,) = getAmountOut(amountInput, input, output, stable);\n                amountOutput = pair.getAmountOut(amountInput, input);\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOutput)\n                : (amountOutput, uint256(0));\n            address to = i \u003c routes.length - 1\n                ? _pairFor(\n                    routes[i + 1].from,\n                    routes[i + 1].to,\n                    routes[i + 1].stable\n                )\n                : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function swapExactTokensForTokensSimple(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address tokenFrom,\n        address tokenTo,\n        bool stable,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        Route[] memory routes = new Route[](1);\n        routes[0].from = tokenFrom;\n        routes[0].to = tokenTo;\n        routes[0].stable = stable;\n        amounts = _getAmountsOut(amountIn, routes);\n        require(\n            amounts[amounts.length - 1] \u003e= amountOutMin,\n            \"DystRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = _getAmountsOut(amountIn, routes);\n        require(\n            amounts[amounts.length - 1] \u003e= amountOutMin,\n            \"DystRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external payable ensure(deadline) returns (uint256[] memory amounts) {\n        require(routes[0].from == address(weth), \"DystRouter: INVALID_PATH\");\n        amounts = _getAmountsOut(msg.value, routes);\n        require(\n            amounts[amounts.length - 1] \u003e= amountOutMin,\n            \"DystRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        weth.deposit{value: amounts[0]}();\n        assert(\n            weth.transfer(\n                _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n                amounts[0]\n            )\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        require(\n            routes[routes.length - 1].to == address(weth),\n            \"DystRouter: INVALID_PATH\"\n        );\n        amounts = _getAmountsOut(amountIn, routes);\n        require(\n            amounts[amounts.length - 1] \u003e= amountOutMin,\n            \"DystRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, address(this));\n        weth.withdraw(amounts[amounts.length - 1]);\n        _safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) {\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amountIn\n        );\n        uint256 balanceBefore = IERC20(routes[routes.length - 1].to).balanceOf(\n            to\n        );\n        _swapSupportingFeeOnTransferTokens(routes, to);\n        require(\n            IERC20(routes[routes.length - 1].to).balanceOf(to) -\n                balanceBefore \u003e=\n                amountOutMin,\n            \"DystRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external payable ensure(deadline) {\n        require(routes[0].from == address(weth), \"DystRouter: INVALID_PATH\");\n        uint256 amountIn = msg.value;\n        weth.deposit{value: amountIn}();\n        assert(\n            weth.transfer(\n                _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n                amountIn\n            )\n        );\n        uint256 balanceBefore = IERC20(routes[routes.length - 1].to).balanceOf(\n            to\n        );\n        _swapSupportingFeeOnTransferTokens(routes, to);\n        require(\n            IERC20(routes[routes.length - 1].to).balanceOf(to) -\n                balanceBefore \u003e=\n                amountOutMin,\n            \"DystRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) {\n        require(\n            routes[routes.length - 1].to == address(weth),\n            \"DystRouter: INVALID_PATH\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(routes, address(this));\n        uint256 amountOut = IERC20(address(weth)).balanceOf(address(this));\n        require(\n            amountOut \u003e= amountOutMin,\n            \"DystRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        weth.withdraw(amountOut);\n        _safeTransferETH(to, amountOut);\n    }\n\n    function UNSAFE_swapExactTokensForTokens(\n        uint256[] memory amounts,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory) {\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, to);\n        return amounts;\n    }\n\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"DystRouter: ETH_TRANSFER_FAILED\");\n    }\n}\n"}}