{"FeeDistribute.sol":{"content":"// SPDX-License-Identifier: GPLv3\r\n\r\n/**\r\n  888888b.                           .d8888b.           888 d8b 888          .d8888b.                                  \r\n  888  \"88b                         d88P  Y88b          888 Y8P 888         d88P  Y88b                                 \r\n  888  .88P                         Y88b.               888     888         888    888                                 \r\n  8888888K.  .d8888b   .d8888b       \"Y888b.   88888b.  888 888 888888      888         8888b.  88888b.d88b.   .d88b.  \r\n  888  \"Y88b 88K      d88P\"             \"Y88b. 888 \"88b 888 888 888         888  88888     \"88b 888 \"888 \"88b d8P  Y8b \r\n  888    888 \"Y8888b. 888                 \"888 888  888 888 888 888         888    888 .d888888 888  888  888 88888888 \r\n  888   d88P      X88 Y88b.         Y88b  d88P 888 d88P 888 888 Y88b.       Y88b  d88P 888  888 888  888  888 Y8b.     \r\n  8888888P\"   88888P\u0027  \"Y8888P       \"Y8888P\"  88888P\"  888 888  \"Y888       \"Y8888P88 \"Y888888 888  888  888  \"Y8888  \r\n                                               888                                                                     \r\n                                               888                                                                     \r\n                                               888              \r\n**/\r\n\r\npragma solidity ^0.8.18;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract FeeDistribute {\r\n    using SafeMath for uint256; \r\n    IERC20 public usdt;\r\n    uint256 public baseDividend = 700;\r\n    address[4] public feeReceivers;\r\n    uint256[4] public feeRates = [300, 195, 105, 100];\r\n    constructor(address _usdtAddr, address[4] memory _feeReceivers) {\r\n        usdt = IERC20(_usdtAddr);\r\n        feeReceivers = _feeReceivers;\r\n    }\r\n\r\n    function distribute() public {\r\n        uint256 balNow = usdt.balanceOf(address(this));\r\n        if(balNow \u003e 0){\r\n            for(uint256 i = 0; i \u003c feeReceivers.length; i++){\r\n                uint256 fee = balNow.mul(feeRates[i]).div(baseDividend);\r\n                usdt.transfer(feeReceivers[i], fee);\r\n            }\r\n        }\r\n    }\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary SafeMath {\n\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"}}