
// File: @chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
  function decimals() external view returns (uint8);

  function description() external view returns (string memory);

  function version() external view returns (uint256);

  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}


// File: @openzeppelin/contracts/access/AccessControl.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)

pragma solidity ^0.8.0;

import "./IAccessControl.sol";
import "../utils/Context.sol";
import "../utils/Strings.sol";
import "../utils/introspection/ERC165.sol";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context, IAccessControl, ERC165 {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with a standardized message including the required role.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     *
     * _Available since v4.1._
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role);
        _;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {
        return _roles[role].members[account];
    }

    /**
     * @dev Revert with a standard message if `_msgSender()` is missing `role`.
     * Overriding this function changes the behavior of the {onlyRole} modifier.
     *
     * Format of the revert message is described in {_checkRole}.
     *
     * _Available since v4.6._
     */
    function _checkRole(bytes32 role) internal view virtual {
        _checkRole(role, _msgSender());
    }

    /**
     * @dev Revert with a standard message if `account` is missing `role`.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     */
    function _checkRole(bytes32 role, address account) internal view virtual {
        if (!hasRole(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        "AccessControl: account ",
                        Strings.toHexString(account),
                        " is missing role ",
                        Strings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleGranted} event.
     */
    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleRevoked} event.
     */
    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been revoked `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     *
     * May emit a {RoleRevoked} event.
     */
    function renounceRole(bytes32 role, address account) public virtual override {
        require(account == _msgSender(), "AccessControl: can only renounce roles for self");

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * May emit a {RoleGranted} event.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     *
     * NOTE: This function is deprecated in favor of {_grantRole}.
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleGranted} event.
     */
    function _grantRole(bytes32 role, address account) internal virtual {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleRevoked} event.
     */
    function _revokeRole(bytes32 role, address account) internal virtual {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}


// File: @openzeppelin/contracts/access/AccessControlEnumerable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)

pragma solidity ^0.8.0;

import "./IAccessControlEnumerable.sol";
import "./AccessControl.sol";
import "../utils/structs/EnumerableSet.sol";

/**
 * @dev Extension of {AccessControl} that allows enumerating the members of each role.
 */
abstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {
    using EnumerableSet for EnumerableSet.AddressSet;

    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {
        return _roleMembers[role].at(index);
    }

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {
        return _roleMembers[role].length();
    }

    /**
     * @dev Overload {_grantRole} to track enumerable memberships
     */
    function _grantRole(bytes32 role, address account) internal virtual override {
        super._grantRole(role, account);
        _roleMembers[role].add(account);
    }

    /**
     * @dev Overload {_revokeRole} to track enumerable memberships
     */
    function _revokeRole(bytes32 role, address account) internal virtual override {
        super._revokeRole(role, account);
        _roleMembers[role].remove(account);
    }
}


// File: @openzeppelin/contracts/access/IAccessControl.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)

pragma solidity ^0.8.0;

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;
}


// File: @openzeppelin/contracts/access/IAccessControlEnumerable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)

pragma solidity ^0.8.0;

import "./IAccessControl.sol";

/**
 * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.
 */
interface IAccessControlEnumerable is IAccessControl {
    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index) external view returns (address);

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
}


// File: @openzeppelin/contracts/access/Ownable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File: @openzeppelin/contracts/proxy/Clones.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)

pragma solidity ^0.8.0;

/**
 * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for
 * deploying minimal proxy contracts, also known as "clones".
 *
 * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies
 * > a minimal bytecode implementation that delegates all calls to a known, fixed address.
 *
 * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`
 * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the
 * deterministic method.
 *
 * _Available since v3.4._
 */
library Clones {
    /**
     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.
     *
     * This function uses the create opcode, which should never revert.
     */
    function clone(address implementation) internal returns (address instance) {
        /// @solidity memory-safe-assembly
        assembly {
            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
            // of the `implementation` address with the bytecode before the address.
            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
            instance := create(0, 0x09, 0x37)
        }
        require(instance != address(0), "ERC1167: create failed");
    }

    /**
     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.
     *
     * This function uses the create2 opcode and a `salt` to deterministically deploy
     * the clone. Using the same `implementation` and `salt` multiple time will revert, since
     * the clones cannot be deployed twice at the same address.
     */
    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {
        /// @solidity memory-safe-assembly
        assembly {
            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
            // of the `implementation` address with the bytecode before the address.
            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
            instance := create2(0, 0x09, 0x37, salt)
        }
        require(instance != address(0), "ERC1167: create2 failed");
    }

    /**
     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
     */
    function predictDeterministicAddress(
        address implementation,
        bytes32 salt,
        address deployer
    ) internal pure returns (address predicted) {
        /// @solidity memory-safe-assembly
        assembly {
            let ptr := mload(0x40)
            mstore(add(ptr, 0x38), deployer)
            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
            mstore(add(ptr, 0x14), implementation)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
            mstore(add(ptr, 0x58), salt)
            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
            predicted := keccak256(add(ptr, 0x43), 0x55)
        }
    }

    /**
     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
     */
    function predictDeterministicAddress(address implementation, bytes32 salt)
        internal
        view
        returns (address predicted)
    {
        return predictDeterministicAddress(implementation, salt, address(this));
    }
}


// File: @openzeppelin/contracts/proxy/utils/Initializable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)

pragma solidity ^0.8.2;

import "../../utils/Address.sol";

/**
 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
 * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
 *
 * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
 * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
 * case an upgrade adds a module that needs to be initialized.
 *
 * For example:
 *
 * [.hljs-theme-light.nopadding]
 * ```
 * contract MyToken is ERC20Upgradeable {
 *     function initialize() initializer public {
 *         __ERC20_init("MyToken", "MTK");
 *     }
 * }
 * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
 *     function initializeV2() reinitializer(2) public {
 *         __ERC20Permit_init("MyToken");
 *     }
 * }
 * ```
 *
 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
 * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
 *
 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
 *
 * [CAUTION]
 * ====
 * Avoid leaving a contract uninitialized.
 *
 * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
 * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
 * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
 *
 * [.hljs-theme-light.nopadding]
 * ```
 * /// @custom:oz-upgrades-unsafe-allow constructor
 * constructor() {
 *     _disableInitializers();
 * }
 * ```
 * ====
 */
abstract contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     * @custom:oz-retyped-from bool
     */
    uint8 private _initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private _initializing;

    /**
     * @dev Triggered when the contract has been initialized or reinitialized.
     */
    event Initialized(uint8 version);

    /**
     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
     * `onlyInitializing` functions can be used to initialize parent contracts.
     *
     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a
     * constructor.
     *
     * Emits an {Initialized} event.
     */
    modifier initializer() {
        bool isTopLevelCall = !_initializing;
        require(
            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),
            "Initializable: contract is already initialized"
        );
        _initialized = 1;
        if (isTopLevelCall) {
            _initializing = true;
        }
        _;
        if (isTopLevelCall) {
            _initializing = false;
            emit Initialized(1);
        }
    }

    /**
     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
     * used to initialize parent contracts.
     *
     * A reinitializer may be used after the original initialization step. This is essential to configure modules that
     * are added through upgrades and that require initialization.
     *
     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
     * cannot be nested. If one is invoked in the context of another, execution will revert.
     *
     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
     * a contract, executing them in the right order is up to the developer or operator.
     *
     * WARNING: setting the version to 255 will prevent any future reinitialization.
     *
     * Emits an {Initialized} event.
     */
    modifier reinitializer(uint8 version) {
        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");
        _initialized = version;
        _initializing = true;
        _;
        _initializing = false;
        emit Initialized(version);
    }

    /**
     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
     * {initializer} and {reinitializer} modifiers, directly or indirectly.
     */
    modifier onlyInitializing() {
        require(_initializing, "Initializable: contract is not initializing");
        _;
    }

    /**
     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
     * through proxies.
     *
     * Emits an {Initialized} event the first time it is successfully executed.
     */
    function _disableInitializers() internal virtual {
        require(!_initializing, "Initializable: contract is initializing");
        if (_initialized < type(uint8).max) {
            _initialized = type(uint8).max;
            emit Initialized(type(uint8).max);
        }
    }

    /**
     * @dev Internal function that returns the initialized version. Returns `_initialized`
     */
    function _getInitializedVersion() internal view returns (uint8) {
        return _initialized;
    }

    /**
     * @dev Internal function that returns the initialized version. Returns `_initializing`
     */
    function _isInitializing() internal view returns (bool) {
        return _initializing;
    }
}


// File: @openzeppelin/contracts/security/Pausable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable is Context {
    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address account);

    bool private _paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    constructor() {
        _paused = false;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        _requireNotPaused();
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        _requirePaused();
        _;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view virtual returns (bool) {
        return _paused;
    }

    /**
     * @dev Throws if the contract is paused.
     */
    function _requireNotPaused() internal view virtual {
        require(!paused(), "Pausable: paused");
    }

    /**
     * @dev Throws if the contract is not paused.
     */
    function _requirePaused() internal view virtual {
        require(paused(), "Pausable: not paused");
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}


// File: @openzeppelin/contracts/security/ReentrancyGuard.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be _NOT_ENTERED
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}


// File: @openzeppelin/contracts/token/ERC20/ERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)

pragma solidity ^0.8.0;

import "./IERC20.sol";
import "./extensions/IERC20Metadata.sol";
import "../../utils/Context.sol";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
     * `transferFrom`. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum `uint256`.
     *
     * Requirements:
     *
     * - `from` and `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     * - the caller must have allowance for ``from``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `from` to `to`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     */
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[from] = fromBalance - amount;
            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
            // decrementing then incrementing.
            _balances[to] += amount;
        }

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        unchecked {
            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
            _balances[account] += amount;
        }
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
            // Overflow not possible: amount <= accountBalance <= totalSupply.
            _totalSupply -= amount;
        }

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
     *
     * Does not update the allowance amount in case of infinite allowance.
     * Revert if not enough allowance is available.
     *
     * Might emit an {Approval} event.
     */
    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}


// File: @openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: @openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)

pragma solidity ^0.8.0;

import "../ERC20.sol";
import "../../../utils/Context.sol";

/**
 * @dev Extension of {ERC20} that allows token holders to destroy both their own
 * tokens and those that they have an allowance for, in a way that can be
 * recognized off-chain (via event analysis).
 */
abstract contract ERC20Burnable is Context, ERC20 {
    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public virtual {
        _burn(_msgSender(), amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, deducting from the caller's
     * allowance.
     *
     * See {ERC20-_burn} and {ERC20-allowance}.
     *
     * Requirements:
     *
     * - the caller must have allowance for ``accounts``'s tokens of at least
     * `amount`.
     */
    function burnFrom(address account, uint256 amount) public virtual {
        _spendAllowance(account, _msgSender(), amount);
        _burn(account, amount);
    }
}


// File: @openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)

pragma solidity ^0.8.0;

import "../ERC20.sol";
import "../../../security/Pausable.sol";

/**
 * @dev ERC20 token with pausable token transfers, minting and burning.
 *
 * Useful for scenarios such as preventing trades until the end of an evaluation
 * period, or having an emergency switch for freezing all token transfers in the
 * event of a large bug.
 */
abstract contract ERC20Pausable is ERC20, Pausable {
    /**
     * @dev See {ERC20-_beforeTokenTransfer}.
     *
     * Requirements:
     *
     * - the contract must not be paused.
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        require(!paused(), "ERC20Pausable: token transfer while paused");
    }
}


// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}


// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../extensions/draft-IERC20Permit.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}


// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)

pragma solidity ^0.8.0;

import "../IERC721.sol";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Enumerable is IERC721 {
    /**
     * @dev Returns the total amount of tokens stored by the contract.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);

    /**
     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
     * Use along with {totalSupply} to enumerate all tokens.
     */
    function tokenByIndex(uint256 index) external view returns (uint256);
}


// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC721.sol";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Metadata is IERC721 {
    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}


// File: @openzeppelin/contracts/token/ERC721/IERC721.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)

pragma solidity ^0.8.0;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
     * understand this adds an external call which potentially creates a reentrancy vulnerability.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}


// File: @openzeppelin/contracts/utils/Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: @openzeppelin/contracts/utils/introspection/ERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.0;

import "./IERC165.sol";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}


// File: @openzeppelin/contracts/utils/introspection/IERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}


// File: @openzeppelin/contracts/utils/math/Math.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)

pragma solidity ^0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    enum Rounding {
        Down, // Toward negative infinity
        Up, // Toward infinity
        Zero // Toward zero
    }

    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds up instead
     * of rounding down.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a == 0 ? 0 : (a - 1) / b + 1;
    }

    /**
     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
     * with further edits by Uniswap Labs also under MIT license.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2^256 + prod0.
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(x, y, not(0))
                prod0 := mul(x, y)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division.
            if (prod1 == 0) {
                return prod0 / denominator;
            }

            // Make sure the result is less than 2^256. Also prevents denominator == 0.
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0].
            uint256 remainder;
            assembly {
                // Compute remainder using mulmod.
                remainder := mulmod(x, y, denominator)

                // Subtract 256 bit number from 512 bit number.
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
            // See https://cs.stackexchange.com/q/138556/92363.

            // Does not overflow because the denominator cannot be zero at this stage in the function.
            uint256 twos = denominator & (~denominator + 1);
            assembly {
                // Divide denominator by twos.
                denominator := div(denominator, twos)

                // Divide [prod1 prod0] by twos.
                prod0 := div(prod0, twos)

                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
                twos := add(div(sub(0, twos), twos), 1)
            }

            // Shift in bits from prod1 into prod0.
            prod0 |= prod1 * twos;

            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
            // four bits. That is, denominator * inv = 1 mod 2^4.
            uint256 inverse = (3 * denominator) ^ 2;

            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
            // in modular arithmetic, doubling the correct bits in each step.
            inverse *= 2 - denominator * inverse; // inverse mod 2^8
            inverse *= 2 - denominator * inverse; // inverse mod 2^16
            inverse *= 2 - denominator * inverse; // inverse mod 2^32
            inverse *= 2 - denominator * inverse; // inverse mod 2^64
            inverse *= 2 - denominator * inverse; // inverse mod 2^128
            inverse *= 2 - denominator * inverse; // inverse mod 2^256

            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inverse;
            return result;
        }
    }

    /**
     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator,
        Rounding rounding
    ) internal pure returns (uint256) {
        uint256 result = mulDiv(x, y, denominator);
        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
            result += 1;
        }
        return result;
    }

    /**
     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
     *
     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
     */
    function sqrt(uint256 a) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
        //
        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
        //
        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
        //
        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
        uint256 result = 1 << (log2(a) >> 1);

        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
        // into the expected uint128 result.
        unchecked {
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            return min(result, a / result);
        }
    }

    /**
     * @notice Calculates sqrt(a), following the selected rounding direction.
     */
    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = sqrt(a);
            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 2, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 128;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 64;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 32;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 16;
            }
            if (value >> 8 > 0) {
                value >>= 8;
                result += 8;
            }
            if (value >> 4 > 0) {
                value >>= 4;
                result += 4;
            }
            if (value >> 2 > 0) {
                value >>= 2;
                result += 2;
            }
            if (value >> 1 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log2(value);
            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 10, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >= 10**64) {
                value /= 10**64;
                result += 64;
            }
            if (value >= 10**32) {
                value /= 10**32;
                result += 32;
            }
            if (value >= 10**16) {
                value /= 10**16;
                result += 16;
            }
            if (value >= 10**8) {
                value /= 10**8;
                result += 8;
            }
            if (value >= 10**4) {
                value /= 10**4;
                result += 4;
            }
            if (value >= 10**2) {
                value /= 10**2;
                result += 2;
            }
            if (value >= 10**1) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log10(value);
            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 256, rounded down, of a positive value.
     * Returns 0 if given 0.
     *
     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
     */
    function log256(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 16;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 8;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 4;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 2;
            }
            if (value >> 8 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log256(value);
            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
        }
    }
}


// File: @openzeppelin/contracts/utils/Strings.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)

pragma solidity ^0.8.0;

import "./math/Math.sol";

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _SYMBOLS = "0123456789abcdef";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        unchecked {
            uint256 length = Math.log10(value) + 1;
            string memory buffer = new string(length);
            uint256 ptr;
            /// @solidity memory-safe-assembly
            assembly {
                ptr := add(buffer, add(32, length))
            }
            while (true) {
                ptr--;
                /// @solidity memory-safe-assembly
                assembly {
                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
                }
                value /= 10;
                if (value == 0) break;
            }
            return buffer;
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        unchecked {
            return toHexString(value, Math.log256(value) + 1);
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }
}


// File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)
// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.

pragma solidity ^0.8.0;

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
 * and `uint256` (`UintSet`) are supported.
 *
 * [WARNING]
 * ====
 * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure
 * unusable.
 * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.
 *
 * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an
 * array of EnumerableSet.
 * ====
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;
        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping(bytes32 => uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) {
            // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            if (lastIndex != toDeleteIndex) {
                bytes32 lastValue = set._values[lastIndex];

                // Move the last value to the index where the value to delete is
                set._values[toDeleteIndex] = lastValue;
                // Update the index for the moved value
                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex
            }

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        return set._values[index];
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function _values(Set storage set) private view returns (bytes32[] memory) {
        return set._values;
    }

    // Bytes32Set

    struct Bytes32Set {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _add(set._inner, value);
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _remove(set._inner, value);
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
        return _contains(set._inner, value);
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(Bytes32Set storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
        return _at(set._inner, index);
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
        bytes32[] memory store = _values(set._inner);
        bytes32[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint160(uint256(_at(set._inner, index))));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(AddressSet storage set) internal view returns (address[] memory) {
        bytes32[] memory store = _values(set._inner);
        address[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }

    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(UintSet storage set) internal view returns (uint256[] memory) {
        bytes32[] memory store = _values(set._inner);
        uint256[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }
}


// File: @uniswap/lib/contracts/libraries/TransferHelper.sol
// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.6.0;

// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false
library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeApprove: approve failed'
        );
    }

    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeTransfer: transfer failed'
        );
    }

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::transferFrom: transferFrom failed'
        );
    }

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');
    }
}


// File: hardhat/console.sol
// SPDX-License-Identifier: MIT
pragma solidity >= 0.4.22 <0.9.0;

library console {
	address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);

	function _sendLogPayload(bytes memory payload) private view {
		uint256 payloadLength = payload.length;
		address consoleAddress = CONSOLE_ADDRESS;
		assembly {
			let payloadStart := add(payload, 32)
			let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
		}
	}

	function log() internal view {
		_sendLogPayload(abi.encodeWithSignature("log()"));
	}

	function logInt(int256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
	}

	function logUint(uint256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
	}

	function logString(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function logBool(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function logAddress(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function logBytes(bytes memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
	}

	function logBytes1(bytes1 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
	}

	function logBytes2(bytes2 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
	}

	function logBytes3(bytes3 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
	}

	function logBytes4(bytes4 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
	}

	function logBytes5(bytes5 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
	}

	function logBytes6(bytes6 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
	}

	function logBytes7(bytes7 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
	}

	function logBytes8(bytes8 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
	}

	function logBytes9(bytes9 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
	}

	function logBytes10(bytes10 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
	}

	function logBytes11(bytes11 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
	}

	function logBytes12(bytes12 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
	}

	function logBytes13(bytes13 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
	}

	function logBytes14(bytes14 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
	}

	function logBytes15(bytes15 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
	}

	function logBytes16(bytes16 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
	}

	function logBytes17(bytes17 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
	}

	function logBytes18(bytes18 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
	}

	function logBytes19(bytes19 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
	}

	function logBytes20(bytes20 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
	}

	function logBytes21(bytes21 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
	}

	function logBytes22(bytes22 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
	}

	function logBytes23(bytes23 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
	}

	function logBytes24(bytes24 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
	}

	function logBytes25(bytes25 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
	}

	function logBytes26(bytes26 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
	}

	function logBytes27(bytes27 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
	}

	function logBytes28(bytes28 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
	}

	function logBytes29(bytes29 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
	}

	function logBytes30(bytes30 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
	}

	function logBytes31(bytes31 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
	}

	function logBytes32(bytes32 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
	}

	function log(uint256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
	}

	function log(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function log(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function log(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function log(uint256 p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
	}

	function log(uint256 p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
	}

	function log(uint256 p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
	}

	function log(uint256 p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
	}

	function log(string memory p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
	}

	function log(string memory p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
	}

	function log(string memory p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
	}

	function log(string memory p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
	}

	function log(bool p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
	}

	function log(bool p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
	}

	function log(bool p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
	}

	function log(bool p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
	}

	function log(address p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
	}

	function log(address p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
	}

	function log(address p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
	}

	function log(address p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
	}

	function log(uint256 p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
	}

	function log(string memory p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
	}

	function log(string memory p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
	}

	function log(string memory p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
	}

	function log(string memory p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
	}

	function log(bool p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
	}

	function log(bool p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
	}

	function log(bool p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
	}

	function log(bool p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
	}

	function log(bool p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
	}

	function log(bool p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
	}

	function log(bool p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
	}

	function log(bool p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
	}

	function log(address p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
	}

	function log(address p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
	}

	function log(address p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
	}

	function log(address p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
	}

	function log(address p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
	}

	function log(address p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
	}

	function log(address p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
	}

	function log(address p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
	}

	function log(address p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
	}

	function log(address p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
	}

	function log(address p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
	}

	function log(address p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
	}

}


// File: src/AMPER/AMPEREstimatorV1.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import {IRDNRegistry} from "../RDN/interfaces/IRDNRegistry.sol";
import {IAMPERProject} from "./interfaces/IAMPERProject.sol";
import {IAMPEREstimator} from "./interfaces/IAMPEREstimator.sol";

contract AMPEREstimatorV1 is IAMPEREstimator, AccessControlEnumerable {

    IRDNRegistry public immutable registry;
    IAMPERProject public immutable amper;
    uint public startPrice;
    uint public priceMoveStep;
    uint public priceMoveThreshold;

    uint[2][10] public promoBonusConfig = [
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0]
    ];
    bool public promoBonusActive = false;

    uint public onceBonusBase;
    mapping(uint => uint) public onceBonusValues;
    uint[] public onceBonusTakers;

    bytes32 public constant CONFIG_ROLE = keccak256("CONFIG_ROLE");

    constructor (
        address _registry, 
        address _amper, 
        address _admin, 
        uint _startPrice,
        uint _priceMoveStep,
        uint _priceMoveThreshld,
        uint _onceBonusBase) 
    {
        registry = IRDNRegistry(_registry);
        amper = IAMPERProject(_amper);

        startPrice = _startPrice;
        priceMoveStep = _priceMoveStep;
        priceMoveThreshold = _priceMoveThreshld;

        onceBonusBase = _onceBonusBase;

        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(CONFIG_ROLE, _admin);
    }

    function estimateAmountOut(uint _userId, uint _amountIn) public view returns(uint, uint) {
        uint _startPrice = startPrice;
        uint _step = priceMoveStep;
        uint _threshold = priceMoveThreshold;
        uint _distributed = amper.distributed();
        uint remained = _amountIn;
        uint amountOut = 0;
        while (remained > 0) {
            uint currentStage = _distributed / _threshold;
            uint currentPrice = _startPrice + currentStage * _step;
            uint currentPriceAmount = _threshold - _distributed % _threshold;
            uint currentPriceCost = (currentPrice * currentPriceAmount) / (10**18);
            uint spent = (currentPriceCost <= remained) ? currentPriceCost : remained;
            uint bought = (currentPriceCost <= remained) ? currentPriceAmount: ((remained * 10**18)/ currentPrice);
            remained -= spent;
            amountOut += bought;
            _distributed += bought;
        }
        uint bonus = estimatePromoBonus(amountOut) + estimateOnceBonus(_userId, amountOut);
        return (amountOut, bonus);
    }

    function giveOnceBonus(uint _userId, uint _amountOut) public returns(uint) {
        require(msg.sender == address(amper), "Access denied");
        uint bonus = estimateOnceBonus(_userId, _amountOut);
        if (bonus > 0) {
            onceBonusTakers.push(_userId);
            onceBonusValues[_userId] = bonus;
        }
        return bonus;
    }

    function estimateOnceBonus(uint _userId, uint _amountOut) public view returns(uint) {
        uint bonus;
        if (onceBonusValues[_userId] > 0) return 0;
        bonus = (_amountOut * onceBonusBase * registry.getTariff(_userId)) / 10**4;
        return bonus;
    }

    function estimatePromoBonus(uint _amountOut) public view returns(uint) {
        if (promoBonusActive == false) return 0;
        uint bonus;
        uint[2][10] memory _promoBonusConfig = promoBonusConfig;
        for (uint i=0; i < _promoBonusConfig.length; i++) {
            if (_amountOut >= _promoBonusConfig[i][0]) {
                bonus = _promoBonusConfig[i][1];
            }
        }
        return (bonus * _amountOut)/10**4;
    }

    // admin functions

    function configPromoBonus(uint[2][10] memory _promoBonusConfig) public onlyRole(CONFIG_ROLE) {
        promoBonusConfig = _promoBonusConfig;
    }

    function configDistribution(
        uint _startPrice,
        uint _priceMoveStep,
        uint _priceMoveThreshold,
        uint _onceBonusBase,
        bool _promoBonusActive)
        public onlyRole(CONFIG_ROLE) 
    {
        startPrice = _startPrice;
        priceMoveStep = _priceMoveStep;
        priceMoveThreshold = _priceMoveThreshold;
        onceBonusBase = _onceBonusBase;
        promoBonusActive = _promoBonusActive;
    }

}

// File: src/AMPER/AMPERProject.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {WithdrawAnyERC20Token} from "../Utils/WithdrawAnyERC20Token.sol";
import {IRDNRegistry} from "../RDN/interfaces/IRDNRegistry.sol";
import {IRDNDistributor} from "../RDN/interfaces/IRDNDistributor.sol";
import {IAMPEREstimator} from "./interfaces/IAMPEREstimator.sol";
import {IAMPERStaking} from "./interfaces/IAMPERStaking.sol";



contract AMPERProject is AccessControlEnumerable, WithdrawAnyERC20Token {

    IRDNRegistry public immutable registry;
    IAMPEREstimator public estimator;
    IAMPERStaking public staking;
    IERC20 public token;
    uint public distributed;
    uint public distributionLimit;
    uint public reward;

    event Turnover(
        uint indexed userId,
        address indexed token,
        uint turnoverAmount,
        uint normalizedTurnover
    );

    event Participation(
        uint indexed userId,
        address indexed tokensIn,
        uint amountIn,
        uint amountOutTotal,
        uint bonus
    );

    bytes32 public constant CONFIG_ROLE = keccak256("CONFIG_ROLE");

    constructor (address _registry, address _admin) WithdrawAnyERC20Token(_admin, false) {
        registry = IRDNRegistry(_registry);

        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(CONFIG_ROLE, _admin);
        
    }

    function estimateAmountOut(uint _userId, uint _amountIn) public view returns(uint, uint) {
        return _estimateAmountOut(_userId, _amountIn);
    }

    function _estimateAmountOut(uint _userId, uint _amountIn) private view returns(uint, uint) {
        require(registry.isRegistered(_userId), "Not registered in RDN");
        (uint amountOut, uint bonus) = estimator.estimateAmountOut(_userId, _amountIn);
        require(amountOut <= (distributionLimit - distributed), "Distribution Limit");
        return (amountOut, bonus);
    }

    function participate(uint _amountIn, uint _amountOutMin) public {
        uint userId = registry.getUserIdByAddress(msg.sender);
        require(userId > 0, "Not registered in RDN");
        
        (uint amountOut, uint bonus) = estimator.estimateAmountOut(userId, _amountIn);
        uint onceBonus = estimator.estimateOnceBonus(userId, _amountIn);
        uint amountOutTotal = amountOut + bonus;
        require(amountOutTotal <= (distributionLimit - distributed), "Distribution limit overflow");
        require(amountOutTotal >= _amountOutMin, "amountOut lt amountOutMin");

        token.transferFrom(msg.sender, address(this), _amountIn);
        uint toReward = (_amountIn * reward) / 10**4;
        if (toReward > 0) {
            IRDNDistributor distributor = IRDNDistributor(registry.getDistributor(address(token)));
            token.approve(address(distributor), toReward);
            distributor.distribute(msg.sender, toReward);
        }

        if (onceBonus > 0) {
            estimator.giveOnceBonus(userId, amountOut);
        }

        distributed += amountOutTotal;

        staking.deposit(userId, amountOutTotal, 0);

        emit Turnover(userId, address(token), _amountIn, _amountIn / 10);
        emit Participation(userId, address(token), _amountIn, amountOutTotal, bonus);
        
    }

    function config(address _staking, address _estimator, uint _distributionLimit, address _token, uint _reward) public onlyRole(CONFIG_ROLE) {
        estimator = IAMPEREstimator(_estimator);
        staking = IAMPERStaking(_staking);
        distributionLimit = _distributionLimit;
        token = IERC20(_token);
        reward = _reward;
    }

    function setDistributed(uint _distributed) public onlyRole(CONFIG_ROLE) {
        distributed = _distributed;
    }

    
}

// File: src/AMPER/AMPERStaking.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {WithdrawAnyERC20Token} from "../Utils/WithdrawAnyERC20Token.sol";
import {IRDNRegistry} from "../RDN/interfaces/IRDNRegistry.sol";


contract AMPERStaking is AccessControlEnumerable, WithdrawAnyERC20Token {
    
    IRDNRegistry public immutable registry;
    IERC20 public token;
    bool public withdrawalEnabled;

    struct Deposit {
        uint created;
        uint amount;
    }

    struct Member {
        uint stakedTotalAmount;
        uint outOfStakingAmount;
        Deposit[] deposits;
    }

    mapping (uint => Member) public members;
    uint[] public membersArr;

    struct Config {
        uint created;
        uint[2][10] rules;
    }
    Config[] public configs;

    bytes32 public constant CONFIG_ROLE = keccak256("CONFIG_ROLE");
    bytes32 public constant DEPOSIT_ROLE = keccak256("DEPOSIT_ROLE");


    constructor (address _registry, address _admin) WithdrawAnyERC20Token(_admin, false) {
        registry = IRDNRegistry(_registry);

        uint[2][10] memory _rules = [
            [uint(0), uint(0)],
            [uint(0), uint(0)],
            [uint(0), uint(0)],
            [uint(2200 ether), uint(12 ether / 100)],
            [uint(3500 ether), uint(15 ether / 100)],
            [uint(5000 ether), uint(18 ether / 100)],
            [uint(7500 ether), uint(22 ether / 100)],
            [uint(11000 ether), uint(25 ether / 100)],
            [uint(16000 ether), uint(30 ether / 100)],
            [uint(25000 ether), uint(45 ether / 100)]
        ];
        Config memory _config = Config(block.timestamp, _rules);
        configs.push(_config);


        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(CONFIG_ROLE, _admin);
        _setupRole(DEPOSIT_ROLE, _admin);
    }

    function deposit(uint _userId, uint _amount, uint _outOfStakingAmount) public onlyRole(DEPOSIT_ROLE) {
        require(registry.isValidUser(_userId), "Not registered in RDN");
        require(_amount > 0, "Nothing to deposit");
        Deposit memory _deposit = Deposit(block.timestamp, _amount);
        if (members[_userId].stakedTotalAmount == 0 && members[_userId].outOfStakingAmount == 0) {
            membersArr.push(_userId);
        }
        members[_userId].stakedTotalAmount += _amount;
        members[_userId].deposits.push(_deposit);
        members[_userId].outOfStakingAmount += _outOfStakingAmount;
    }

    function income(uint _userId) public view returns(uint) {
        uint _configsCount = configs.length;
        uint _staked;
        uint _nextBreak;
        uint _income;
        uint _lastIncome;
        Member memory _member = members[_userId];
        Config memory _conf = configs[0];

        for (uint i; i < _configsCount; i++) {
            _conf = configs[i];
            if (i == (_configsCount - 1)) {
                _nextBreak = block.timestamp;
            } else {
                _nextBreak = configs[i+1].created;
            }
            if (i > 0) {
                _income += ((_conf.created - _lastIncome) * _staked * _rule(configs[i-1], _staked)) / (365 days * 10**18);
            }
            _lastIncome = _conf.created;
            for (uint j; j < _member.deposits.length; j++) {
                if ((_member.deposits[j].created > _conf.created) && (_member.deposits[j].created <= _nextBreak)) {
                    _income += ((_member.deposits[j].created - _lastIncome) * _staked * _rule(_conf, _staked)) / (365 days * 10**18);
                    _staked += _member.deposits[j].amount;
                    _lastIncome = _member.deposits[j].created;
                }
            }
        }
        _income += ((block.timestamp - _lastIncome) * _staked * _rule(_conf, _staked)) / (365 days * 10**18);
        return _income;
    }

    function rule(uint _amount) public view returns(uint) {
        return _rule(configs[configs.length - 1], _amount);
    }

    function _rule(Config memory _conf, uint _amount) pure private returns (uint) {
        uint _val;
        for (uint i; i < _conf.rules.length; i++) {
            if (_amount >= _conf.rules[i][0]) {
                _val = _conf.rules[i][1];
            } else {
                break;
            }
        }
        return _val;
    }

    function balanceSummary(uint _userId) public view returns(uint, uint, uint) {
        uint _staked = members[_userId].stakedTotalAmount;
        uint _outStaking = members[_userId].outOfStakingAmount;
        uint _income = income(_userId);
        return (_staked, _outStaking, _income);
    }

    function staked(uint _userId) public view returns(uint) {
        return members[_userId].stakedTotalAmount;
    }

    function outStaking(uint _userId) public view returns(uint) {
        return members[_userId].outOfStakingAmount;
    }

    function configRules(uint[2][10] memory _rules) public {
        Config memory _conf = Config(block.timestamp, _rules);
        configs.push(_conf);
    }

    function configStaking(address _token, bool _withdrawalEnabled) public onlyRole(CONFIG_ROLE) {
        token = IERC20(_token);
        withdrawalEnabled = _withdrawalEnabled;
    }

    function getAllMembers() public view returns(uint[] memory) {
        return membersArr;
    }
}

// File: src/AMPER/interfaces/IAMPEREstimator.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

interface IAMPEREstimator {
    
    function estimateAmountOut(uint _userId, uint _amountIn) external view returns(uint, uint);

    function estimateOnceBonus(uint _userId, uint _amountIn) external view returns(uint);

    function giveOnceBonus(uint _userId, uint _amountOut) external returns(uint);

}

// File: src/AMPER/interfaces/IAMPERProject.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

interface IAMPERProject {
    
    function distributed() external view returns(uint);
    
    function estimateAmountOut(uint _userId, uint _amountIn) external view returns(uint, uint);
    
    function estimateAmountIn(uint _userId, uint _amountOut) external view returns(uint, uint);

}

// File: src/AMPER/interfaces/IAMPERStaking.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

interface IAMPERStaking {
    
    function deposit(uint _userId, uint _amount, uint _outOfStakingAmount) external;
    
    function income(uint _userId) external view returns(uint);

}

// File: src/DeFi/Refs/DFH/LPTokensManager/dex/IPair.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IPair is IERC20 {
  function token0() external view returns (address);

  function token1() external view returns (address);
}

// File: src/DeFi/Refs/DFH/LPTokensManager/dex/IRouter.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

interface IRouter {
  function swapExactTokensForTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapExactTokensForTokensSupportingFeeOnTransferTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external;

  function addLiquidity(
    address tokenA,
    address tokenB,
    uint256 amountADesired,
    uint256 amountBDesired,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  )
    external
    returns (
      uint256 amountA,
      uint256 amountB,
      uint256 liquidity
    );

  function removeLiquidity(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountA, uint256 amountB);

  function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);
}

// File: src/DeFi/Refs/DFH/LPTokensManager/IWrap.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IWrap is IERC20 {
  event Deposit(address indexed dst, uint256 wad);
  event Withdrawal(address indexed src, uint256 wad);

  function deposit() external payable;

  function withdraw(uint256 wad) external;
}

// File: src/DeFi/Refs/DFH/LPTokensManager/LPTokensManager.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "./Storage.sol";
import "./dex/IPair.sol";
import "./dex/IRouter.sol";
import "./IWrap.sol";

contract LPTokensManager is Ownable {
  using SafeERC20 for IERC20;

  /// @notice Storage contract
  Storage public info;

  struct Swap {
    address[] path;
    uint256 outMin;
  }

  event StorageChanged(address indexed info);

  constructor(address _info) {
    require(_info != address(0), "LPTokensManager::constructor: invalid storage contract address");
    info = Storage(_info);
  }

  receive() external payable {}

  fallback() external payable {}

  /**
   * @notice Change storage contract address.
   * @param _info New storage contract address.
   */
  function changeStorage(address _info) external onlyOwner {
    require(_info != address(0), "LPTokensManager::changeStorage: invalid storage contract address");
    info = Storage(_info);
    emit StorageChanged(_info);
  }

  function _swap(
    address router,
    uint256 amount,
    uint256 outMin,
    address[] memory path,
    uint256 deadline
  ) internal {
    if (path[0] == path[path.length - 1]) return;

    IRouter(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(
      amount,
      outMin,
      path,
      address(this),
      deadline
    );
  }

  /**
   * @return Current call commission.
   */
  function fee() public view returns (uint256) {
    uint256 feeUSD = info.getUint(keccak256("DFH:Fee:Automate:LPTokensManager"));
    if (feeUSD == 0) return 0;

    (, int256 answer, , , ) = AggregatorV3Interface(info.getAddress(keccak256("DFH:Fee:PriceFeed"))).latestRoundData();
    require(answer > 0, "LPTokensManager::fee: invalid price feed response");

    return (feeUSD * 1e18) / uint256(answer);
  }

  function _payCommission() internal {
    uint256 payFee = fee();
    if (payFee == 0) return;
    require(msg.value >= payFee, "LPTokensManager::_payCommission: insufficient funds to pay commission");
    address treasury = info.getAddress(keccak256("DFH:Contract:Treasury"));
    require(treasury != address(0), "LPTokensManager::_payCommission: invalid treasury contract address");

    // solhint-disable-next-line avoid-low-level-calls
    (bool sentTreasury, ) = payable(treasury).call{value: payFee}("");
    require(sentTreasury, "LPTokensManager::_payCommission: transfer fee to the treasury failed");
    if (msg.value > payFee) {
      // solhint-disable-next-line avoid-low-level-calls
      (bool sentRemained, ) = payable(msg.sender).call{value: msg.value - payFee}("");
      require(sentRemained, "LPTokensManager::_payCommission: transfer of remained tokens to the sender failed");
    }
  }

  function _returnRemainder(address[3] memory tokens) internal {
    for (uint256 i = 0; i < tokens.length; i++) {
      if (tokens[i] == address(0)) continue;
      uint256 tokenBalance = IERC20(tokens[i]).balanceOf(address(this));
      if (tokenBalance > 0) {
        IERC20(tokens[i]).safeTransfer(msg.sender, tokenBalance);
      }
    }
  }

  function _approve(
    IERC20 token,
    address spender,
    uint256 amount
  ) internal {
    if (token.allowance(address(this), spender) != 0) {
      token.safeApprove(spender, 0);
    }
    token.safeApprove(spender, amount);
  }

  function _buyLiquidity(
    uint256 amount,
    address router,
    Swap memory swap0,
    Swap memory swap1,
    IPair to,
    uint256 deadline
  ) internal returns (address token0, address token1) {
    require(
      info.getBool(keccak256(abi.encodePacked("DFH:Contract:LPTokensManager:allowedRouter:", router))),
      "LPTokensManager::_buyLiquidity: invalid router address"
    );
    require(swap0.path[0] == swap1.path[0], "LPTokensManager::_buyLiqudity: start token not equals");

    // Get tokens in
    token0 = to.token0();
    require(swap0.path[swap0.path.length - 1] == token0, "LPTokensManager::_buyLiqudity: invalid token0");
    token1 = to.token1();
    require(swap1.path[swap1.path.length - 1] == token1, "LPTokensManager::_buyLiqudity: invalid token1");

    // Swap tokens
    _approve(IERC20(swap0.path[0]), router, amount);
    uint256 amount0In = amount / 2;
    _swap(router, amount0In, swap0.outMin, swap0.path, deadline);
    uint256 amount1In = amount - amount0In;
    _swap(router, amount1In, swap1.outMin, swap1.path, deadline);

    // Add liquidity
    amount0In = IERC20(token0).balanceOf(address(this));
    amount1In = IERC20(token1).balanceOf(address(this));
    _approve(IERC20(token0), router, amount0In);
    _approve(IERC20(token1), router, amount1In);
    IRouter(router).addLiquidity(token0, token1, amount0In, amount1In, 0, 0, msg.sender, deadline);
  }

  function buyLiquidity(
    uint256 amount,
    address router,
    Swap memory swap0,
    Swap memory swap1,
    IPair to,
    uint256 deadline
  ) public payable {
    _payCommission();
    IERC20(swap0.path[0]).safeTransferFrom(msg.sender, address(this), amount);
    (address token0, address token1) = _buyLiquidity(amount, router, swap0, swap1, to, deadline);
    _returnRemainder([token0, token1, swap0.path[0]]);
  }

  function buyLiquidityETH(
    address router,
    Swap memory swap0,
    Swap memory swap1,
    IPair to,
    uint256 deadline
  ) external payable {
    uint256 amountIn = msg.value;

    uint256 payFee = fee();
    if (payFee > 0) {
      amountIn -= payFee;
      address treasury = info.getAddress(keccak256("DFH:Contract:Treasury"));
      require(treasury != address(0), "LPTokensManager::buyLiquidityETH: invalid treasury contract address");
      // solhint-disable-next-line avoid-low-level-calls
      (bool sentTreasury, ) = payable(treasury).call{value: payFee}("");
      require(sentTreasury, "LPTokensManager::buyLiquidityETH: transfer fee to the treasury failed");
    }

    IWrap wrapper = IWrap(info.getAddress(keccak256("NativeWrapper:Contract")));
    wrapper.deposit{value: amountIn}();

    (address token0, address token1) = _buyLiquidity(amountIn, router, swap0, swap1, to, deadline);
    _returnRemainder([token0, token1, swap0.path[0]]);
  }

  function _sellLiquidity(
    uint256 amount,
    address router,
    Swap memory swap0,
    Swap memory swap1,
    IPair from,
    uint256 deadline
  ) internal returns (address token0, address token1) {
    require(
      info.getBool(keccak256(abi.encodePacked("DFH:Contract:LPTokensManager:allowedRouter:", router))),
      "LPTokensManager::sellLiquidity: invalid router address"
    );
    require(
      swap0.path[swap0.path.length - 1] == swap1.path[swap1.path.length - 1],
      "LPTokensManager::sellLiqudity: end token not equals"
    );

    // Get tokens in
    token0 = from.token0();
    require(swap0.path[0] == token0, "LPTokensManager::sellLiqudity: invalid token0");
    token1 = from.token1();
    require(swap1.path[0] == token1, "LPTokensManager::sellLiqudity: invalid token1");

    // Remove liquidity
    _approve(IERC20(from), router, amount);
    IRouter(router).removeLiquidity(token0, token1, amount, 0, 0, address(this), deadline);

    // Swap tokens
    uint256 amount0In = IERC20(token0).balanceOf(address(this));
    _approve(IERC20(token0), router, amount0In);
    _swap(router, amount0In, swap0.outMin, swap0.path, deadline);
    uint256 amount1In = IERC20(token1).balanceOf(address(this));
    _approve(IERC20(token1), router, amount1In);
    _swap(router, amount1In, swap1.outMin, swap1.path, deadline);
  }

  function sellLiquidity(
    uint256 amount,
    address router,
    Swap memory swap0,
    Swap memory swap1,
    IPair from,
    uint256 deadline
  ) external payable {
    _payCommission();
    IERC20(from).safeTransferFrom(msg.sender, address(this), amount);
    (address token0, address token1) = _sellLiquidity(amount, router, swap0, swap1, from, deadline);
    _returnRemainder([token0, token1, swap0.path[swap0.path.length - 1]]);
  }

  function sellLiquidityETH(
    uint256 amount,
    address router,
    Swap memory swap0,
    Swap memory swap1,
    IPair from,
    uint256 deadline
  ) external payable {
    _payCommission();
    IERC20(from).safeTransferFrom(msg.sender, address(this), amount);
    (address token0, address token1) = _sellLiquidity(amount, router, swap0, swap1, from, deadline);

    IWrap wrapper = IWrap(info.getAddress(keccak256("NativeWrapper:Contract")));
    wrapper.withdraw(wrapper.balanceOf(address(this)));

    // solhint-disable-next-line avoid-low-level-calls
    (bool sentRecipient, ) = payable(msg.sender).call{value: address(this).balance}("");
    require(sentRecipient, "LPTokensManager::sellLiquidityETH: transfer ETH to recipeint failed");
    _returnRemainder([token0, token1, swap0.path[swap0.path.length - 1]]);
  }
}

// File: src/DeFi/Refs/DFH/LPTokensManager/Storage.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/access/Ownable.sol";

contract Storage is Ownable {
  /// @dev Bytes storage.
  mapping(bytes32 => bytes) private _bytes;

  /// @dev Bool storage.
  mapping(bytes32 => bool) private _bool;

  /// @dev Uint storage.
  mapping(bytes32 => uint256) private _uint;

  /// @dev Int storage.
  mapping(bytes32 => int256) private _int;

  /// @dev Address storage.
  mapping(bytes32 => address) private _address;

  /// @dev String storage.
  mapping(bytes32 => string) private _string;

  event Updated(bytes32 indexed key);

  /**
   * @param key The key for the record
   */
  function getBytes(bytes32 key) external view returns (bytes memory) {
    return _bytes[key];
  }

  /**
   * @param key The key for the record
   */
  function getBool(bytes32 key) external view returns (bool) {
    return _bool[key];
  }

  /**
   * @param key The key for the record
   */
  function getUint(bytes32 key) external view returns (uint256) {
    return _uint[key];
  }

  /**
   * @param key The key for the record
   */
  function getInt(bytes32 key) external view returns (int256) {
    return _int[key];
  }

  /**
   * @param key The key for the record
   */
  function getAddress(bytes32 key) external view returns (address) {
    return _address[key];
  }

  /**
   * @param key The key for the record
   */
  function getString(bytes32 key) external view returns (string memory) {
    return _string[key];
  }

  /**
   * @param key The key for the record
   * @param value The value to set.
   */
  function setBytes(bytes32 key, bytes calldata value) external onlyOwner {
    _bytes[key] = value;
    emit Updated(key);
  }

  /**
   * @param key The key for the record
   * @param value The value to set.
   */
  function setBool(bytes32 key, bool value) external onlyOwner {
    _bool[key] = value;
    emit Updated(key);
  }

  /**
   * @param key The key for the record
   * @param value The value to set.
   */
  function setUint(bytes32 key, uint256 value) external onlyOwner {
    _uint[key] = value;
    emit Updated(key);
  }

  /**
   * @param key The key for the record
   * @param value The value to set.
   */
  function setInt(bytes32 key, int256 value) external onlyOwner {
    _int[key] = value;
    emit Updated(key);
  }

  /**
   * @param key The key for the record
   * @param value The value to set.
   */
  function setAddress(bytes32 key, address value) external onlyOwner {
    _address[key] = value;
    emit Updated(key);
  }

  /**
   * @param key The key for the record
   * @param value The value to set.
   */
  function setString(bytes32 key, string calldata value) external onlyOwner {
    _string[key] = value;
    emit Updated(key);
  }

  /**
   * @param key The key for the record
   */
  function deleteBytes(bytes32 key) external onlyOwner {
    delete _bytes[key];
    emit Updated(key);
  }

  /**
   * @param key The key for the record
   */
  function deleteBool(bytes32 key) external onlyOwner {
    delete _bool[key];
    emit Updated(key);
  }

  /**
   * @param key The key for the record
   */
  function deleteUint(bytes32 key) external onlyOwner {
    delete _uint[key];
    emit Updated(key);
  }

  /**
   * @param key The key for the record
   */
  function deleteInt(bytes32 key) external onlyOwner {
    delete _int[key];
    emit Updated(key);
  }

  /**
   * @param key The key for the record
   */
  function deleteAddress(bytes32 key) external onlyOwner {
    delete _address[key];
    emit Updated(key);
  }

  /**
   * @param key The key for the record
   */
  function deleteString(bytes32 key) external onlyOwner {
    delete _string[key];
    emit Updated(key);
  }
}

// File: src/DeFi/Refs/DFH/Restake/IMasterChef2.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

interface IMasterChef2 {
  struct UserInfo {
    uint256 amount;
    uint256 rewardDebt;
    uint256 boostMultiplier;
  }

  struct PoolInfo {
    uint256 accCakePerShare;
    uint256 lastRewardBlock;
    uint256 allocPoint;
    uint256 totalBoostedShare;
    bool isRegular;
  }

  function totalRegularAllocPoint() external view returns (uint256);

  function totalSpecialAllocPoint() external view returns (uint256);

  function cakePerBlock(bool _isRegular) external view returns (uint256 amount);

  // solhint-disable-next-line func-name-mixedcase
  function CAKE() external view returns (address);

  function poolLength() external view returns (uint256);

  function poolInfo(uint256 pool) external view returns (PoolInfo memory);

  function lpToken(uint256 pool) external view returns (address);

  function userInfo(uint256 pool, address user) external view returns (UserInfo memory);

  function pendingCake(uint256 pool, address user) external view returns (uint256);

  function deposit(uint256 pool, uint256 amount) external;

  function withdraw(uint256 pool, uint256 amount) external;

  function emergencyWithdraw(uint256 pool) external;
}

// File: src/DeFi/Refs/DFH/Restake/MasterChef2LpRestake.automate.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./utils/DFH/Automate.sol";
import "./utils/DFH/IStorage.sol";
import "./utils/Uniswap/IUniswapV2Router02.sol";
import "./utils/Uniswap/IUniswapV2Pair.sol";
import "./utils/Uniswap/SafeUniswapV2Router.sol";
import "./utils/Uniswap/StopLoss.sol";
import "./IMasterChef2.sol";

/**
 * @notice Use with LP token only.
 */
contract MasterChef2LpRestake is Automate {
  using SafeERC20 for IERC20;
  using SafeUniswapV2Router for IUniswapV2Router02;
  using StopLoss for StopLoss.Order;

  struct Swap {
    address[] path;
    uint256 outMin;
  }

  address public liquidityRouter;

  IMasterChef2 public staking;

  uint256 public pool;

  uint16 public slippage;

  uint16 public deadline;

  IERC20 public stakingToken;

  IERC20 public rewardToken;

  StopLoss.Order public stopLoss;

  // solhint-disable-next-line no-empty-blocks
  constructor(address _info) Automate(_info) {}

  function init(
    address _staking,
    address _liquidityRouter,
    uint256 _pool,
    uint16 _slippage,
    uint16 _deadline
  ) external initializer {
    require(
      !_initialized || address(staking) == _staking,
      "MasterChef2LpRestake::init: reinitialize staking address forbidden"
    );
    staking = IMasterChef2(_staking);
    require(
      !_initialized || liquidityRouter == _liquidityRouter,
      "MasterChef2LpRestake::init: reinitialize liquidity router address forbidden"
    );
    liquidityRouter = _liquidityRouter;
    require(!_initialized || pool == _pool, "MasterChef2LpRestake::init: reinitialize pool index forbidden");
    pool = _pool;
    slippage = _slippage;
    deadline = _deadline;

    if (!_initialized) {
      address lpToken = staking.lpToken(pool);
      stakingToken = IERC20(lpToken);
      rewardToken = IERC20(staking.CAKE());
    }
  }

  function deposit(uint256 amount) external onlyOwner {
    IERC20 _stakingToken = stakingToken; // gas optimisation
    _stakingToken.safeTransferFrom(msg.sender, address(this), amount);
    _stakingToken.safeApprove(address(staking), amount);
    staking.deposit(pool, amount);
  }

  function refund() external onlyOwner {
    IMasterChef2 _staking = staking; // gas optimisation
    address __owner = owner(); // gas optimisation
    IMasterChef2.UserInfo memory userInfo = _staking.userInfo(pool, address(this));
    _staking.withdraw(pool, userInfo.amount);
    stakingToken.safeTransfer(__owner, stakingToken.balanceOf(address(this)));
    rewardToken.safeTransfer(__owner, rewardToken.balanceOf(address(this)));
  }

  function emergencyWithdraw() external onlyOwner {
    address __owner = owner(); // gas optimisation
    staking.emergencyWithdraw(pool);
    stakingToken.safeTransfer(__owner, stakingToken.balanceOf(address(this)));
    rewardToken.safeTransfer(__owner, rewardToken.balanceOf(address(this)));
  }

  function run(
    uint256 gasFee,
    uint256 _deadline,
    Swap memory swap0,
    Swap memory swap1
  ) external bill(gasFee, "PancakeSwapMasterChef2LpRestake") {
    IMasterChef2 _staking = staking; // gas optimization
    IUniswapV2Router02 _liquidityRouter = IUniswapV2Router02(liquidityRouter);
    require(_staking.pendingCake(pool, address(this)) > 0, "MasterChef2LpRestake::run: no earned");

    _staking.deposit(pool, 0); // get all reward
    uint256 rewardAmount = rewardToken.balanceOf(address(this));
    rewardToken.safeApprove(address(_liquidityRouter), rewardAmount);
    _liquidityRouter.safeSwapExactTokensForTokens(rewardAmount / 2, swap0.outMin, swap0.path, address(this), _deadline);
    _liquidityRouter.safeSwapExactTokensForTokens(
      rewardAmount - rewardAmount / 2,
      swap1.outMin,
      swap1.path,
      address(this),
      _deadline
    );

    IUniswapV2Pair _stakingToken = IUniswapV2Pair(address(stakingToken));
    _liquidityRouter.addAllLiquidity(_stakingToken.token0(), _stakingToken.token1(), address(this), _deadline);
    uint256 stakingAmount = _stakingToken.balanceOf(address(this));
    stakingToken.safeApprove(address(_staking), stakingAmount);
    _staking.deposit(pool, stakingAmount);
  }

  function setStopLoss(
    address[] calldata path,
    uint256 amountOut,
    uint256 amountOutMin
  ) external onlyOwner {
    stopLoss = StopLoss.Order(path, amountOut, amountOutMin);
  }

  function runStopLoss(uint256 gasFee, uint256 _deadline) external bill(gasFee, "PancakeSwapMasterChef2LpStopLoss") {
    staking.withdraw(pool, staking.userInfo(pool, address(this)).amount);
    (address token0, address token1, , ) = IUniswapV2Router02(liquidityRouter).removeAllLiquidity(
      address(stakingToken),
      address(this),
      _deadline
    );
    address[] memory inTokens = new address[](2);
    inTokens[0] = token0;
    inTokens[1] = token1;

    stopLoss.run(liquidityRouter, inTokens, _deadline);
    address __owner = owner();
    IERC20 exitToken = IERC20(stopLoss.path[stopLoss.path.length - 1]);
    exitToken.safeTransfer(__owner, exitToken.balanceOf(address(this)));
    if (rewardToken != exitToken) {
      rewardToken.safeTransfer(__owner, rewardToken.balanceOf(address(this)));
    }
  }
}

// File: src/DeFi/Refs/DFH/Restake/utils/DFH/Automate.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./proxy/ERC1167.sol";
import "./IStorage.sol";
import "./IBalance.sol";

// solhint-disable avoid-tx-origin
abstract contract Automate {
  using ERC1167 for address;

  /// @notice Storage contract address.
  address internal _info;

  /// @notice Contract owner.
  address internal _owner;

  /// @notice Is contract paused.
  bool internal _paused;

  /// @notice Protocol fee in USD (-1 if value in global storage).
  int256 internal _protocolFee;

  /// @notice Is contract already initialized.
  bool internal _initialized;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  event ProtocolFeeChanged(int256 protocolFee);

  constructor(address __info) {
    _info = __info;
    _owner = tx.origin;
    _protocolFee = -1;
  }

  /**
   * @notice Returns address of Storage contract.
   */
  function info() public view returns (address) {
    address impl = address(this).implementation();
    if (impl == address(this)) return _info;

    return Automate(impl).info();
  }

  /// @dev Modifier to protect an initializer function from being invoked twice.
  modifier initializer() {
    if (_owner == address(0)) {
      _owner = tx.origin;
      _protocolFee = -1;
    } else {
      require(_owner == msg.sender, "Automate: caller is not the owner");
    }
    _;
    _initialized = true;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(_owner == msg.sender, "Automate: caller is not the owner");
    _;
  }

  /**
   * @notice Returns the address of the current owner.
   */
  function owner() public view returns (address) {
    return _owner;
  }

  /**
   * @dev Transfers ownership of the contract to a new account (`newOwner`).
   * Can only be called by the current owner.
   */
  function transferOwnership(address newOwner) external onlyOwner {
    require(address(this).implementation() == address(this), "Automate: change the owner failed");

    address oldOwner = _owner;
    _owner = newOwner;
    emit OwnershipTransferred(oldOwner, newOwner);
  }

  /**
   * @dev Throws if called by any account other than the pauser.
   */
  modifier onlyPauser() {
    if (address(this).implementation() == address(this)) {
      address pauser = IStorage(info()).getAddress(keccak256("DFH:Pauser"));
      require(msg.sender == _owner || msg.sender == pauser, "Automate: caller is not the pauser");
    } else {
      require(msg.sender == _owner, "Automate: caller is not the pauser");
    }
    _;
  }

  /**
   * @notice Returns true if the contract is paused, and false otherwise.
   */
  function paused() public view returns (bool) {
    address impl = address(this).implementation();
    if (impl == address(this)) return _paused;

    return _paused || Automate(impl).paused();
  }

  /**
   * @dev Throws if contract unpaused.
   */
  modifier whenPaused() {
    require(paused(), "Automate: not paused");
    _;
  }

  /**
   * @dev Throws if contract paused.
   */
  modifier whenNotPaused() {
    require(!paused(), "Automate: paused");
    _;
  }

  /**
   * @notice Pause contract.
   */
  function pause() external onlyPauser whenNotPaused {
    _paused = true;
  }

  /**
   * @notice Unpause contract.
   */
  function unpause() external onlyPauser whenPaused {
    _paused = false;
  }

  /**
   * @return Current protocol fee.
   */
  function protocolFee() public view returns (uint256) {
    address impl = address(this).implementation();
    if (impl != address(this) && _protocolFee < 0) {
      return Automate(impl).protocolFee();
    }

    IStorage __info = IStorage(info());
    uint256 feeOnUSD = _protocolFee < 0 ? __info.getUint(keccak256("DFH:Fee:Automate")) : uint256(_protocolFee);
    if (feeOnUSD == 0) return 0;

    (, int256 price, , , ) = AggregatorV3Interface(__info.getAddress(keccak256("DFH:Fee:PriceFeed"))).latestRoundData();
    require(price > 0, "Automate: invalid price");

    return (feeOnUSD * 1e18) / uint256(price);
  }

  /**
   * @notice Change protocol fee.
   * @param __protocolFee New protocol fee.
   */
  function changeProtocolFee(int256 __protocolFee) external {
    address impl = address(this).implementation();
    require(
      (impl == address(this) ? _owner : Automate(impl).owner()) == msg.sender,
      "Automate::changeProtocolFee: caller is not the protocol owner"
    );

    _protocolFee = __protocolFee;
    emit ProtocolFeeChanged(__protocolFee);
  }

  /**
   * @dev Claim fees from owner.
   * @param gasFee Claim gas fee.
   * @param operation Claim description.
   */
  function _bill(uint256 gasFee, string memory operation) internal whenNotPaused returns (uint256) {
    address account = owner(); // gas optimisation
    if (tx.origin == account) return 0; // free if called by the owner

    IStorage __info = IStorage(info());

    address balance = __info.getAddress(keccak256("DFH:Contract:Balance"));
    require(balance != address(0), "Automate::_bill: balance contract not found");

    return IBalance(balance).claim(account, gasFee, protocolFee(), operation);
  }

  /**
   * @dev Claim fees from owner.
   * @param gasFee Claim gas fee.
   * @param operation Claim description.
   */
  modifier bill(uint256 gasFee, string memory operation) {
    _bill(gasFee, operation);
    _;
  }

  /**
   * @notice Transfer ERC20 token to recipient.
   * @param token The address of the token to be transferred.
   * @param recipient Token recipient address.
   * @param amount Transferred amount of tokens.
   */
  function transfer(
    address token,
    address recipient,
    uint256 amount
  ) external onlyOwner {
    IERC20(token).transfer(recipient, amount);
  }
}

// File: src/DeFi/Refs/DFH/Restake/utils/DFH/IBalance.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

interface IBalance {
  function claim(
    address account,
    uint256 gasFee,
    uint256 protocolFee,
    string memory description
  ) external returns (uint256);
}

// File: src/DeFi/Refs/DFH/Restake/utils/DFH/IStorage.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

interface IStorage {
  function getBytes(bytes32 key) external view returns (bytes memory);

  function getBool(bytes32 key) external view returns (bool);

  function getUint(bytes32 key) external view returns (uint256);

  function getInt(bytes32 key) external view returns (int256);

  function getAddress(bytes32 key) external view returns (address);

  function getString(bytes32 key) external view returns (string memory);
}

// File: src/DeFi/Refs/DFH/Restake/utils/DFH/proxy/ERC1167.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

// solhint-disable no-inline-assembly
library ERC1167 {
  bytes public constant CLONE =
    hex"363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3";

  /**
   * @notice Make new proxy contract.
   * @param impl Address prototype contract.
   * @return proxy Address new proxy contract.
   */
  function clone(address impl) external returns (address proxy) {
    assembly {
      let ptr := mload(0x40)
      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
      mstore(add(ptr, 0x14), shl(0x60, impl))
      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
      proxy := create(0, ptr, 0x37)
    }
    require(proxy != address(0), "ERC1167: create failed");
  }

  /**
   * @notice Returns address of prototype contract for proxy.
   * @param proxy Address proxy contract.
   * @return impl Address prototype contract (current contract address if not proxy).
   */
  function implementation(address proxy) external view returns (address impl) {
    uint256 size;
    assembly {
      size := extcodesize(proxy)
    }

    impl = proxy;
    if (size <= 45 && size >= 41) {
      bool matches = true;
      uint256 i;

      bytes memory code;
      assembly {
        code := mload(0x40)
        mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
        mstore(code, size)
        extcodecopy(proxy, add(code, 0x20), 0, size)
      }
      for (i = 0; matches && i < 9; i++) {
        matches = code[i] == CLONE[i];
      }
      for (i = 0; matches && i < 15; i++) {
        if (i == 4) {
          matches = code[code.length - i - 1] == bytes1(uint8(CLONE[45 - i - 1]) - uint8(45 - size));
        } else {
          matches = code[code.length - i - 1] == CLONE[45 - i - 1];
        }
      }
      if (code[9] != bytes1(0x73 - uint8(45 - size))) {
        matches = false;
      }
      uint256 forwardedToBuffer;
      if (matches) {
        assembly {
          forwardedToBuffer := mload(add(code, 30))
        }
        forwardedToBuffer &= (0x1 << (20 * 8)) - 1;
        impl = address(uint160(forwardedToBuffer >> ((45 - size) * 8)));
      }
    }
  }
}

// File: src/DeFi/Refs/DFH/Restake/utils/ERC20Tools.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

library ERC20Tools {
  function safeApprove(
    IERC20 token,
    address spender,
    uint256 value
  ) internal {
    uint256 allowance = token.allowance(address(this), spender);
    if (allowance != 0 && allowance < value) {
      token.approve(spender, 0);
    }
    if (allowance != value) {
      token.approve(spender, value);
    }
  }

  function safeApproveAll(IERC20 token, address spender) internal {
    safeApprove(token, spender, 2**256 - 1);
  }
}

// File: src/DeFi/Refs/DFH/Restake/utils/Uniswap/IUniswapV2Pair.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// solhint-disable func-name-mixedcase
interface IUniswapV2Pair is IERC20 {
  function nonces(address owner) external view returns (uint256);

  function MINIMUM_LIQUIDITY() external pure returns (uint256);

  function token0() external view returns (address);

  function token1() external view returns (address);

  function getReserves()
    external
    view
    returns (
      uint112 reserve0,
      uint112 reserve1,
      uint32 blockTimestampLast
    );

  function price0CumulativeLast() external view returns (uint256);

  function price1CumulativeLast() external view returns (uint256);

  function kLast() external view returns (uint256);

  function mint(address to) external returns (uint256 liquidity);

  function burn(address to) external returns (uint256 amount0, uint256 amount1);

  function swap(
    uint256 amount0Out,
    uint256 amount1Out,
    address to,
    bytes calldata data
  ) external;
}

// File: src/DeFi/Refs/DFH/Restake/utils/Uniswap/IUniswapV2Router02.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

// solhint-disable func-name-mixedcase
interface IUniswapV2Router02 {
  function factory() external view returns (address);

  function WETH() external view returns (address);

  function addLiquidity(
    address tokenA,
    address tokenB,
    uint256 amountADesired,
    uint256 amountBDesired,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  )
    external
    returns (
      uint256 amountA,
      uint256 amountB,
      uint256 liquidity
    );

  function addLiquidityETH(
    address token,
    uint256 amountTokenDesired,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  )
    external
    payable
    returns (
      uint256 amountToken,
      uint256 amountETH,
      uint256 liquidity
    );

  function removeLiquidity(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountA, uint256 amountB);

  function removeLiquidityETH(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountToken, uint256 amountETH);

  function removeLiquidityWithPermit(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountA, uint256 amountB);

  function removeLiquidityETHWithPermit(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountToken, uint256 amountETH);

  function swapExactTokensForTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapTokensForExactTokens(
    uint256 amountOut,
    uint256 amountInMax,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapExactETHForTokens(
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable returns (uint256[] memory amounts);

  function swapTokensForExactETH(
    uint256 amountOut,
    uint256 amountInMax,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapExactTokensForETH(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapETHForExactTokens(
    uint256 amountOut,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable returns (uint256[] memory amounts);

  function quote(
    uint256 amountA,
    uint256 reserveA,
    uint256 reserveB
  ) external pure returns (uint256 amountB);

  function getAmountOut(
    uint256 amountIn,
    uint256 reserveIn,
    uint256 reserveOut
  ) external pure returns (uint256 amountOut);

  function getAmountIn(
    uint256 amountOut,
    uint256 reserveIn,
    uint256 reserveOut
  ) external pure returns (uint256 amountIn);

  function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);

  function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);

  function removeLiquidityETHSupportingFeeOnTransferTokens(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountETH);

  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountETH);

  function swapExactTokensForTokensSupportingFeeOnTransferTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external;

  function swapExactETHForTokensSupportingFeeOnTransferTokens(
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable;

  function swapExactTokensForETHSupportingFeeOnTransferTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external;
}

// File: src/DeFi/Refs/DFH/Restake/utils/Uniswap/SafeUniswapV2Router.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./IUniswapV2Router02.sol";
import "./IUniswapV2Pair.sol";

library SafeUniswapV2Router {
  using SafeERC20 for IERC20;

  function safeSwapExactTokensForTokens(
    IUniswapV2Router02 router,
    uint256 amountIn,
    uint256 amountOutMin,
    address[] memory path,
    address to,
    uint256 deadline
  ) internal returns (uint256[] memory amounts) {
    if (path[0] != path[path.length - 1])
      amounts = router.swapExactTokensForTokens(amountIn, amountOutMin, path, to, deadline);
  }

  function addAllLiquidity(
    IUniswapV2Router02 router,
    address tokenA,
    address tokenB,
    address to,
    uint256 deadline
  )
    internal
    returns (
      uint256,
      uint256,
      uint256
    )
  {
    uint256 amountA = IERC20(tokenA).balanceOf(address(this));
    if (IERC20(tokenA).allowance(address(this), address(router)) > 0) {
      IERC20(tokenA).safeApprove(address(router), 0);
    }
    IERC20(tokenA).safeApprove(address(router), amountA);

    uint256 amountB = IERC20(tokenB).balanceOf(address(this));
    if (IERC20(tokenB).allowance(address(this), address(router)) > 0) {
      IERC20(tokenB).safeApprove(address(router), 0);
    }
    IERC20(tokenB).safeApprove(address(router), amountB);

    return router.addLiquidity(tokenA, tokenB, amountA, amountB, 0, 0, to, deadline);
  }

  function removeAllLiquidity(
    IUniswapV2Router02 router,
    address pair,
    address to,
    uint256 deadline
  )
    internal
    returns (
      address tokenA,
      address tokenB,
      uint256 amountA,
      uint256 amountB
    )
  {
    tokenA = IUniswapV2Pair(pair).token0();
    tokenB = IUniswapV2Pair(pair).token1();

    uint256 balance = IERC20(pair).balanceOf(address(this));
    if (IERC20(pair).allowance(address(this), address(router)) > 0) {
      IERC20(pair).safeApprove(address(router), 0);
    }
    IERC20(pair).safeApprove(address(router), balance);

    (amountA, amountB) = router.removeLiquidity(tokenA, tokenB, balance, 0, 0, to, deadline);
  }
}

// File: src/DeFi/Refs/DFH/Restake/utils/Uniswap/StopLoss.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./SafeUniswapV2Router.sol";
import "./IUniswapV2Router02.sol";

library StopLoss {
  using SafeERC20 for IERC20;
  using SafeUniswapV2Router for IUniswapV2Router02;

  struct Order {
    address[] path;
    uint256 amountOut;
    uint256 amountOutMin;
  }

  event StopLossOrderCompleted(uint256 amountOut);

  function run(
    Order storage order,
    address liquidityRouter,
    address[] memory inTokens,
    uint256 _deadline
  ) internal {
    require(order.path.length > 1 && order.amountOut > 0, "StopLoss::run: stop loss disabled");
    require(inTokens.length <= 256, "StopLoss::run: too many in tokens");
    for (uint8 i = 0; i < inTokens.length; i++) {
      address token = inTokens[i];
      if (token == order.path[0]) continue;
      uint256 balance = IERC20(token).balanceOf(address(this));
      if (balance == 0) continue;
      address[] memory path = new address[](2);
      path[0] = token;
      path[1] = order.path[0];
      IERC20(token).safeApprove(liquidityRouter, balance);
      IUniswapV2Router02(liquidityRouter).safeSwapExactTokensForTokens(balance, 0, path, address(this), _deadline);
    }

    address baseToken = order.path[0];
    uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));
    uint256 amountOut;
    if (baseToken != order.path[order.path.length - 1]) {
      require(baseBalance > 0, "StopLoss::run: insufficient balance of base token");
      IERC20(baseToken).safeApprove(liquidityRouter, baseBalance);
      uint256[] memory amountsOut = IUniswapV2Router02(liquidityRouter).safeSwapExactTokensForTokens(
        baseBalance,
        order.amountOutMin,
        order.path,
        address(this),
        _deadline
      );
      amountOut = amountsOut[amountsOut.length - 1];
      require(amountOut <= order.amountOut, "StopLoss::run: invalid output amount");
    } else {
      amountOut = baseBalance;
      require(amountOut <= order.amountOut, "StopLoss::run: invalid output amount");
    }
    emit StopLossOrderCompleted(amountOut);
  }
}

// File: src/DeFi/Spot/AdapterMasterChefV3.sol
//// SPDX-License-Identifier: Unlicense
//pragma solidity ^0.8.10;
//
//import "@openzeppelin/contracts/access/Ownable.sol";
//import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
//import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
//import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
//import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
//
//interface INonfungiblePositionManagerStruct {
//    struct IncreaseLiquidityParams {
//        uint256 tokenId;
//        uint256 amount0Desired;
//        uint256 amount1Desired;
//        uint256 amount0Min;
//        uint256 amount1Min;
//        uint256 deadline;
//    }
//
//    struct DecreaseLiquidityParams {
//        uint256 tokenId;
//        uint128 liquidity;
//        uint256 amount0Min;
//        uint256 amount1Min;
//        uint256 deadline;
//    }
//
//    struct CollectParams {
//        uint256 tokenId;
//        address recipient;
//        uint128 amount0Max;
//        uint128 amount1Max;
//    }
//}
//
//
//
///// @title Creates and initializes V3 Pools
///// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that
///// require the pool to exist.
//interface IPoolInitializer {
//    /// @notice Creates a new pool if it does not exist, then initializes if not initialized
//    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool
//    /// @param token0 The contract address of token0 of the pool
//    /// @param token1 The contract address of token1 of the pool
//    /// @param fee The fee amount of the v3 pool for the specified token pair
//    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value
//    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary
//    function createAndInitializePoolIfNecessary(
//        address token0,
//        address token1,
//        uint24 fee,
//        uint160 sqrtPriceX96
//    ) external payable returns (address pool);
//}
//
//
//
///// @title Periphery Payments
///// @notice Functions to ease deposits and withdrawals of ETH
//interface IPeripheryPayments {
//    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.
//    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.
//    /// @param amountMinimum The minimum amount of WETH9 to unwrap
//    /// @param recipient The address receiving ETH
//    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;
//
//    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`
//    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps
//    /// that use ether for the input amount. And in PancakeSwap Router, this would be called
//    /// at the very end of swap
//    function refundETH() external payable;
//
//    /// @notice Transfers the full amount of a token held by this contract to recipient
//    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users
//    /// @param token The contract address of the token which will be transferred to `recipient`
//    /// @param amountMinimum The minimum amount of token required for a transfer
//    /// @param recipient The destination address of the token
//    function sweepToken(
//        address token,
//        uint256 amountMinimum,
//        address recipient
//    ) external payable;
//}
//
//
///// @title Immutable state
///// @notice Functions that return immutable state of the router
//interface IPeripheryImmutableState {
//    /// @return Returns the address of the PancakeSwap V3 deployer
//    function deployer() external view returns (address);
//
//    /// @return Returns the address of the PancakeSwap V3 factory
//    function factory() external view returns (address);
//
//    /// @return Returns the address of WETH9
//    function WETH9() external view returns (address);
//}
//
//
///**
// * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
// * @dev See https://eips.ethereum.org/EIPS/eip-721
// */
//interface IERC721Metadata is IERC721 {
//
//    /**
//     * @dev Returns the token collection name.
//     */
//    function name() external view returns (string memory);
//
//    /**
//     * @dev Returns the token collection symbol.
//     */
//    function symbol() external view returns (string memory);
//
//    /**
//     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
//     */
//    function tokenURI(uint256 tokenId) external view returns (string memory);
//}
//
//
///// @title ERC721 with permit
///// @notice Extension to ERC721 that includes a permit function for signature based approvals
//interface IERC721Permit is IERC721 {
//    /// @notice The permit typehash used in the permit signature
//    /// @return The typehash for the permit
//    function PERMIT_TYPEHASH() external pure returns (bytes32);
//
//    /// @notice The domain separator used in the permit signature
//    /// @return The domain seperator used in encoding of permit signature
//    function DOMAIN_SEPARATOR() external view returns (bytes32);
//
//    /// @notice Approve of a specific token ID for spending by spender via signature
//    /// @param spender The account that is being approved
//    /// @param tokenId The ID of the token that is being approved for spending
//    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work
//    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
//    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
//    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
//    function permit(
//        address spender,
//        uint256 tokenId,
//        uint256 deadline,
//        uint8 v,
//        bytes32 r,
//        bytes32 s
//    ) external payable;
//}
//
//
//

///// @title Pool state that can change
///// @notice These methods compose the pool's state, and can change with any frequency including multiple times
///// per transaction
//interface IPancakeV3PoolState {
//    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
//    /// when accessed externally.
//    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
//    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
//    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
//    /// boundary.
//    /// observationIndex The index of the last oracle observation that was written,
//    /// observationCardinality The current maximum number of observations stored in the pool,
//    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
//    /// feeProtocol The protocol fee for both tokens of the pool.
//    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
//    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
//    /// unlocked Whether the pool is currently locked to reentrancy
//    function slot0()
//        external
//        view
//        returns (
//            uint160 sqrtPriceX96,
//            int24 tick,
//            uint16 observationIndex,
//            uint16 observationCardinality,
//            uint16 observationCardinalityNext,
//            uint32 feeProtocol,
//            bool unlocked
//        );
//
//    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
//    /// @dev This value can overflow the uint256
//    function feeGrowthGlobal0X128() external view returns (uint256);
//
//    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
//    /// @dev This value can overflow the uint256
//    function feeGrowthGlobal1X128() external view returns (uint256);
//
//    /// @notice The amounts of token0 and token1 that are owed to the protocol
//    /// @dev Protocol fees will never exceed uint128 max in either token
//    function protocolFees() external view returns (uint128 token0, uint128 token1);
//
//    /// @notice The currently in range liquidity available to the pool
//    /// @dev This value has no relationship to the total liquidity across all ticks
//    function liquidity() external view returns (uint128);
//
//    /// @notice Look up information about a specific tick in the pool
//    /// @param tick The tick to look up
//    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
//    /// tick upper,
//    /// liquidityNet how much liquidity changes when the pool price crosses the tick,
//    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
//    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
//    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
//    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
//    /// secondsOutside the seconds spent on the other side of the tick from the current tick,
//    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
//    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
//    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
//    /// a specific position.
//    function ticks(int24 tick)
//        external
//        view
//        returns (
//            uint128 liquidityGross,
//            int128 liquidityNet,
//            uint256 feeGrowthOutside0X128,
//            uint256 feeGrowthOutside1X128,
//            int56 tickCumulativeOutside,
//            uint160 secondsPerLiquidityOutsideX128,
//            uint32 secondsOutside,
//            bool initialized
//        );
//
//    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
//    function tickBitmap(int16 wordPosition) external view returns (uint256);
//
//    /// @notice Returns the information about a position by the position's key
//    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
//    /// @return _liquidity The amount of liquidity in the position,
//    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
//    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
//    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
//    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
//    function positions(bytes32 key)
//        external
//        view
//        returns (
//            uint128 _liquidity,
//            uint256 feeGrowthInside0LastX128,
//            uint256 feeGrowthInside1LastX128,
//            uint128 tokensOwed0,
//            uint128 tokensOwed1
//        );
//
//    /// @notice Returns data about a specific observation index
//    /// @param index The element of the observations array to fetch
//    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
//    /// ago, rather than at a specific index in the array.
//    /// @return blockTimestamp The timestamp of the observation,
//    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
//    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
//    /// Returns initialized whether the observation has been initialized and the values are safe to use
//    function observations(uint256 index)
//        external
//        view
//        returns (
//            uint32 blockTimestamp,
//            int56 tickCumulative,
//            uint160 secondsPerLiquidityCumulativeX128,
//            bool initialized
//        );
//}
//
//
//interface IPancakeV3Pool is IPancakeV3PoolState {
//    function factory() external view returns (address);
//
//    function token0() external view returns (address);
//
//    function token1() external view returns (address);
//
//    function fee() external view returns (uint24);
//
//    function lmPool() external view returns (address);
//}
//
//
//interface ILMPool {
//    function updatePosition(int24 tickLower, int24 tickUpper, int128 liquidityDelta) external;
//
//    function getRewardGrowthInside(
//        int24 tickLower,
//        int24 tickUpper
//    ) external view returns (uint256 rewardGrowthInsideX128);
//
//    function accumulateReward(uint32 currTimestamp) external;
//}
//
//interface ILMPoolDeployer {
//    function deploy(IPancakeV3Pool pool) external returns (ILMPool lmPool);
//}
//
//
//interface IFarmBooster {
//    function getUserMultiplier(uint256 _tokenId) external view returns (uint256);
//
//    function whiteList(uint256 _pid) external view returns (bool);
//
//    function updatePositionBoostMultiplier(uint256 _tokenId) external returns (uint256 _multiplier);
//
//    function removeBoostMultiplier(address _user, uint256 _tokenId, uint256 _pid) external;
//}
//
//
//contract AdapterMasterChefV3 is Ownable {
//    IMasterChefV3 public masterchef = IMasterChefV3(0x556B9306565093C855AEA9AE92A594704c2Cd59e);
//    INonfungiblePositionManager public positionManager = INonfungiblePositionManager(0x46A15B0b27311cedF172AB29E4f4766fbE7F4364);
//
//    // add liquidity https://bscscan.com/tx/0x5a185387202ed0febb91eaa8731e6f552181910915cbf70cfc6a32c10dae5071
//    function addLiquidty(
//        address token0,
//        address token1,
//        uint24 fee,
//        int24 tickLower,
//        int24 tickUpper,
//        uint256 amount0Desired,
//        uint256 amount1Desired,
//        uint256 amount0Min,
//        uint256 amount1Min,
//        address recipient,
//        uint256 deadline
//    ) external onlyOwner {
//        INonfungiblePositionManager.MintParams memory _mintParams = INonfungiblePositionManager.MintParams({
//            token0: token0,
//            token1: token1,
//            fee: fee,
//            tickLower: tickLower,
//            tickUpper: tickUpper,
//            amount0Desired: amount0Desired,
//            amount1Desired: amount1Desired,
//            amount0Min: amount0Min,
//            amount1Min: amount1Min,
//            recipient: recipient,
//            deadline: deadline
//        });
//        IERC20(token0).approve(address(positionManager), amount0Desired);
//        IERC20(token1).approve(address(positionManager), amount1Desired);
//        IERC20(token0).transferFrom(msg.sender, address(this), amount0Desired);
//        IERC20(token1).transferFrom(msg.sender, address(this), amount1Desired);
//        positionManager.mint(_mintParams);
//        uint256 rest0 = IERC20(token0).balanceOf(address(this));
//        uint256 rest1 = IERC20(token1).balanceOf(address(this));
//        if (rest0 > 0) {
//            IERC20(token0).transfer(msg.sender, rest0);
//        }
//        if (rest1 > 0) {
//            IERC20(token1).transfer(msg.sender, rest1);
//        }
//    }
//
//    // deposit
//    function deposit(
//        uint256 _tokenId
//    ) external onlyOwner {
//        positionManager.safeTransferFrom(address(this), address(masterchef), _tokenId);
//    }
//
//    // harvest
//    function harvest(
//        uint256 _tokenId
//    ) external onlyOwner {
//        masterchef.harvest(_tokenId, msg.sender);
//    }
//
//    // withdraw
//    function withdraw(
//        uint256 _tokenId
//    ) external onlyOwner {
//        masterchef.withdraw(_tokenId, msg.sender);
//    }
//
//    // todo remove in production
//    function doAnything(address _contract, bytes memory _data) external onlyOwner {
//        (bool success, ) = _contract.call(_data);
//        require(success, "doAnything: failed");
//    }
//
//    // todo remove in production
//    function doAnythingWithStorage(address _contract, bytes memory _data) external onlyOwner {
//        (bool success, ) = _contract.delegatecall(_data);
//        require(success, "doAnythingWithStorage: failed");
//    }
//
//    // todo remove in production
//    function recoverERC20(address _token, uint256 _amount) external onlyOwner {
//        IERC20(_token).transfer(msg.sender, _amount);
//    }
//
//    // todo remove in production
//    function recoverNative(uint256 _amount) external onlyOwner {
//        payable(msg.sender).transfer(_amount);
//    }
//
//    // todo remove in production
//    function recoverERC721(address nft, uint256 tokenId) external onlyOwner {
//        IERC721(nft).transferFrom(address(this), msg.sender, tokenId);
//    }
//}


// File: src/DeFi/Spot/ERC20Spot.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../../RDN/RDNOwnable.sol";


contract ERC20Spot is IERC20, RDNOwnable {

    mapping(uint => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    uint private _totalSupply;
    string private _name;
    string private _symbol;

    function initERC20Spot(address _registry, uint _ownerId) internal {
        _symbol = 'SPOT0';
        _name = "SPOTv0 Share Token";

        initRDNOwnable(_registry, _ownerId);

    }


    function balanceOf(address _account) public view returns (uint) {
        uint userId = IRDNRegistry(registry).getUserIdByAddress(_account);
        return _balances[userId];
    }

    function allowance(address owner, address spender) public view returns (uint) {
        return _allowances[owner][spender];
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return 18;
    }

    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }

    function transfer(address to, uint amount) external returns (bool) {
        return false;
    }

    function approve(address spender, uint amount) external returns (bool) {
        return false;
    }

    function transferFrom(
        address from,
        address to,
        uint amount
    ) external returns (bool) {
        return false;
    }

    function _mint(uint userId, uint amount) internal {
        address account = IRDNRegistry(registry).getUserAddress(userId);
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply += amount;
        unchecked {
            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
            _balances[userId] += amount;
        }
        emit Transfer(address(0), account, amount);
    }

    function _burn(uint userId, uint amount) internal {
        address account = IRDNRegistry(registry).getUserAddress(userId);
        require(account != address(0), "ERC20: burn from zero address");

        uint accountBalance = _balances[userId];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[userId] = accountBalance - amount;
            // Overflow not possible: amount <= accountBalance <= totalSupply.
            _totalSupply -= amount;
        }

        emit Transfer(account, address(0), amount);
    }
}

// File: src/DeFi/Spot/IMasterChef2.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

interface IMasterChef2 {
  struct UserInfo {
    uint256 amount;
    uint256 rewardDebt;
    uint256 boostMultiplier;
  }

  struct PoolInfo {
    uint256 accCakePerShare;
    uint256 lastRewardBlock;
    uint256 allocPoint;
    uint256 totalBoostedShare;
    bool isRegular;
  }

  function totalRegularAllocPoint() external view returns (uint256);

  function totalSpecialAllocPoint() external view returns (uint256);

  function cakePerBlock(bool _isRegular) external view returns (uint256 amount);

  // solhint-disable-next-line func-name-mixedcase
  function CAKE() external view returns (address);

  function poolLength() external view returns (uint256);

  function poolInfo(uint256 pool) external view returns (PoolInfo memory);

  function lpToken(uint256 pool) external view returns (address);

  function userInfo(uint256 pool, address user) external view returns (UserInfo memory);

  function pendingCake(uint256 pool, address user) external view returns (uint256);

  function deposit(uint256 pool, uint256 amount) external;

  function withdraw(uint256 pool, uint256 amount) external;

  function emergencyWithdraw(uint256 pool) external;
}

// File: src/DeFi/Spot/ISpotFactoryV0.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "./ISpotV0.sol";

interface ISpotFactoryV0 {

    function create(uint poolIndex) external returns(address);

    function getAllUserSpots(uint ownerId) external view returns(address[] memory);

    function createAndDeposit(
        uint poolIndex, 
        uint amount, 
        ISpotV0.Swap memory swap0, 
        ISpotV0.Swap memory swap1,
        ISpotV0.Swap memory swapReward0,
        ISpotV0.Swap memory swapReward1,
        uint deadline
    ) external returns(address);

}

// File: src/DeFi/Spot/ISpotFactoryV1.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "./ISpotV1.sol";

interface ISpotFactoryV1 {

    function create(uint poolIndex) external returns(address);

    function getAllUserSpots(uint ownerId) external view returns(address[] memory);

    function createAndDeposit(
        uint poolIndex, 
        uint amount, 
        ISpotV1.Swap memory swap0, 
        ISpotV1.Swap memory swap1,
        ISpotV1.Swap memory swapReward0,
        ISpotV1.Swap memory swapReward1,
        uint deadline
    ) external payable returns(address);

}

// File: src/DeFi/Spot/ISpotV0.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

interface ISpotV0 {

    struct Swap {
        address[] path;
        uint outMin;
    }
    
    function init(
        address _pool,
        address _router,
        address _stakingToken,
        address _rewardToken,
        uint _poolIndex,
        uint _ownerId,
        address _registry,
        address factory
    ) external;

    function deposit(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) external;

    function withdraw(
        uint amountToBurn,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) external;

    function restake(
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) external;
    
}

// File: src/DeFi/Spot/ISpotV1.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

interface ISpotV1 {

    struct Swap {
        address[] path;
        uint outMin;
    }

    struct Log {
        uint timestamp;
        uint blocknumber;
        uint8 operationType; // 0 - deposit, 1 - withdrawal, 2 - restake
        address token; // deposit or withdrawal token
        uint tokenAmount;
        uint lpAmount; // amount of LP deposited or withdrawn
        uint lpToken0Amount;
        uint lpToken1Amount;
    }
    
    function init(
        address _wrapper,
        address _pool,
        address _router,
        address _stakingToken,
        address _rewardToken,
        uint _poolIndex,
        uint _ownerId,
        address _registry,
        address factory
    ) external;

    function deposit(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) external payable;

    function withdraw(
        uint amountToBurn,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) external;

    function restake(
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) external;

}

// File: src/DeFi/Spot/ISpotV2.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

interface ISpotV2 {

    struct Swap {
        address[] path;
        uint outMin;
    }

    struct Log {
        uint timestamp;
        uint blocknumber;
        uint8 operationType; // 0 - deposit, 1 - withdrawal, 2 - restake
        address token; // deposit or withdrawal token
        uint tokenAmount;
        uint lpAmount; // amount of LP deposited or withdrawn
        uint lpToken0Amount;
        uint lpToken1Amount;
    }
    
    function init(
        address _wrapper,
        address _pool,
        address _router,
        address _stakingToken,
        address _rewardToken,
        uint _poolIndex,
        uint _ownerId,
        address _registry,
        address factory
    ) external;

    function deposit(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) external payable;

    function withdraw(
        uint amountToBurn,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) external;

    function restake(
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) external;

}

// File: src/DeFi/Spot/IUniswapV2Pair.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// solhint-disable func-name-mixedcase
interface IUniswapV2Pair is IERC20 {
  function nonces(address owner) external view returns (uint256);

  function MINIMUM_LIQUIDITY() external pure returns (uint256);

  function token0() external view returns (address);

  function token1() external view returns (address);

  function getReserves()
    external
    view
    returns (
      uint112 reserve0,
      uint112 reserve1,
      uint32 blockTimestampLast
    );

  function price0CumulativeLast() external view returns (uint256);

  function price1CumulativeLast() external view returns (uint256);

  function kLast() external view returns (uint256);

  function mint(address to) external returns (uint256 liquidity);

  function burn(address to) external returns (uint256 amount0, uint256 amount1);

  function swap(
    uint256 amount0Out,
    uint256 amount1Out,
    address to,
    bytes calldata data
  ) external;
}

// File: src/DeFi/Spot/IUniswapV2Router.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.6;

interface IUniswapV2Router {
  function factory() external view returns (address);

  function WETH() external view returns (address);

  function addLiquidity(
    address tokenA,
    address tokenB,
    uint256 amountADesired,
    uint256 amountBDesired,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  )
    external
    returns (
      uint256 amountA,
      uint256 amountB,
      uint256 liquidity
    );

  function addLiquidityETH(
    address token,
    uint256 amountTokenDesired,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  )
    external
    payable
    returns (
      uint256 amountToken,
      uint256 amountETH,
      uint256 liquidity
    );

  function removeLiquidity(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountA, uint256 amountB);

  function removeLiquidityETH(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountToken, uint256 amountETH);

  function removeLiquidityWithPermit(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountA, uint256 amountB);

  function removeLiquidityETHWithPermit(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountToken, uint256 amountETH);

  function swapExactTokensForTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapTokensForExactTokens(
    uint256 amountOut,
    uint256 amountInMax,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapExactETHForTokens(
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable returns (uint256[] memory amounts);

  function swapTokensForExactETH(
    uint256 amountOut,
    uint256 amountInMax,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapExactTokensForETH(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapETHForExactTokens(
    uint256 amountOut,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable returns (uint256[] memory amounts);

  function quote(
    uint256 amountA,
    uint256 reserveA,
    uint256 reserveB
  ) external pure returns (uint256 amountB);

  function getAmountOut(
    uint256 amountIn,
    uint256 reserveIn,
    uint256 reserveOut
  ) external pure returns (uint256 amountOut);

  function getAmountIn(
    uint256 amountOut,
    uint256 reserveIn,
    uint256 reserveOut
  ) external pure returns (uint256 amountIn);

  function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);

  function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);

  function removeLiquidityETHSupportingFeeOnTransferTokens(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountETH);

  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountETH);

  function swapExactTokensForTokensSupportingFeeOnTransferTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external;

  function swapExactETHForTokensSupportingFeeOnTransferTokens(
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable;

  function swapExactTokensForETHSupportingFeeOnTransferTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external;
}

// File: src/DeFi/Spot/IWrap.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IWrap is IERC20 {
  event Deposit(address indexed dst, uint256 wad);
  event Withdrawal(address indexed src, uint256 wad);

  function deposit() external payable;

  function withdraw(uint256 wad) external;
}

// File: src/DeFi/Spot/SafeUniswapV2Router.sol
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./IUniswapV2Router.sol";
import "./IUniswapV2Pair.sol";

library SafeUniswapV2Router {
  using SafeERC20 for IERC20;

  function safeSwapExactTokensForTokens(
    IUniswapV2Router router,
    uint256 amountIn,
    uint256 amountOutMin,
    address[] memory path,
    address to,
    uint256 deadline
  ) internal returns (uint256[] memory amounts) {
    if (path[0] != path[path.length - 1])
      amounts = router.swapExactTokensForTokens(amountIn, amountOutMin, path, to, deadline);
  }

  function addAllLiquidity(
    IUniswapV2Router router,
    address tokenA,
    address tokenB,
    address to,
    uint256 deadline
  )
    internal
    returns (
      uint256,
      uint256,
      uint256
    )
  {
    uint256 amountA = IERC20(tokenA).balanceOf(address(this));
    if (IERC20(tokenA).allowance(address(this), address(router)) > 0) {
      IERC20(tokenA).safeApprove(address(router), 0);
    }
    IERC20(tokenA).safeApprove(address(router), amountA);

    uint256 amountB = IERC20(tokenB).balanceOf(address(this));
    if (IERC20(tokenB).allowance(address(this), address(router)) > 0) {
      IERC20(tokenB).safeApprove(address(router), 0);
    }
    IERC20(tokenB).safeApprove(address(router), amountB);

    return router.addLiquidity(tokenA, tokenB, amountA, amountB, 0, 0, to, deadline);
  }

  function removeAllLiquidity(
    IUniswapV2Router router,
    address pair,
    address to,
    uint256 deadline
  )
    internal
    returns (
      address tokenA,
      address tokenB,
      uint256 amountA,
      uint256 amountB
    )
  {
    tokenA = IUniswapV2Pair(pair).token0();
    tokenB = IUniswapV2Pair(pair).token1();

    uint256 balance = IERC20(pair).balanceOf(address(this));
    if (IERC20(pair).allowance(address(this), address(router)) > 0) {
      IERC20(pair).safeApprove(address(router), 0);
    }
    IERC20(pair).safeApprove(address(router), balance);

    (amountA, amountB) = router.removeLiquidity(tokenA, tokenB, balance, 0, 0, to, deadline);
  }
}

// File: src/DeFi/Spot/SpotFactoryV0.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/proxy/Clones.sol";
import {IRDNRegistry} from "../../RDN/interfaces/IRDNRegistry.sol";
import "./IMasterChef2.sol";
import "./ISpotV0.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract SpotFactoryV0 {
    
    // todo
    // ownerid shoud be active / RDNConnected
    // onlyRDN

    event SpotCreated(address indexed spotAddress, uint indexed ownerId, uint indexed poolIndex);

    using SafeERC20 for IERC20;

    address public immutable implementation;
    address public immutable registry;
    address public immutable pool;
    address public immutable router;
    address public immutable rewardToken;

    mapping(uint => mapping(uint => address)) public spots;

    constructor(address _implementation, address _registry, address _pool, address _router, address _rewardToken) {
        implementation = _implementation;
        registry = _registry;
        pool = _pool;
        router = _router;
        rewardToken = _rewardToken;
    }

    function create(uint poolIndex) public returns(address) {
        uint ownerId = IRDNRegistry(registry).getUserIdByAddress(msg.sender);
        require(ownerId > 0, "not registered in RDN");
        address spot = _create(ownerId, poolIndex);
        return spot;
    }

    function createAndDeposit(
        uint poolIndex,
        uint amount, 
        ISpotV0.Swap memory swap0, 
        ISpotV0.Swap memory swap1,
        ISpotV0.Swap memory swapReward0,
        ISpotV0.Swap memory swapReward1,
        uint deadline
    ) public returns(address) {
        uint ownerId = IRDNRegistry(registry).getUserIdByAddress(msg.sender);
        require(ownerId > 0, "not registered in RDN");
        address spot = _create(ownerId, poolIndex);
        IERC20(swap0.path[0]).safeTransferFrom(msg.sender, address(this), amount);
        IERC20(swap0.path[0]).approve(spot, amount);
        ISpotV0(spot).deposit(amount, swap0, swap1, swapReward0, swapReward1, deadline);
        return spot;
    }

    function _create(uint ownerId, uint poolIndex) internal returns(address) {
        require(spots[ownerId][poolIndex] == address(0), "spot already created");

        address stakingToken = IMasterChef2(pool).lpToken(poolIndex);
        require(stakingToken != address(0), "wrong pool index");

        address spot = Clones.clone(implementation);

        ISpotV0(spot).init(pool, router, stakingToken, rewardToken, poolIndex, ownerId, registry, address(this));

        // pools[ownerId].push(poolIndex);
        spots[ownerId][poolIndex] = spot;
        
        emit SpotCreated(spot, ownerId, poolIndex);
        
        return spot;
    }

    function getAllUserSpots(uint ownerId) public view returns(address[] memory) {
        uint poolsCount = IMasterChef2(pool).poolLength();
        address[] memory spotsArray = new address[](poolsCount);
        for (uint i=0; i < poolsCount; i++) {
            spotsArray[i] = spots[ownerId][i];
        }
        return spotsArray;
    }

    function getSpotAddress(uint ownerId, uint poolIndex) public view returns(address) {
        return spots[ownerId][poolIndex];
    }

}

// File: src/DeFi/Spot/SpotFactoryV1.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/proxy/Clones.sol";
import {IRDNRegistry} from "../../RDN/interfaces/IRDNRegistry.sol";
import "./IMasterChef2.sol";
import "./ISpotV1.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

contract SpotFactoryV1 is AccessControlEnumerable{
    
     bytes32 public constant UPDATEIMPLEMENTATION_ROLE = keccak256("UPDATEIMPLEMENTATION_ROLE");

    event SpotCreated(address indexed spotAddress, uint indexed ownerId, uint indexed poolIndex);

    using SafeERC20 for IERC20;

    address public implementation;
    address public immutable registry;
    address public immutable pool;
    address public immutable router;
    address public immutable rewardToken;
    address public immutable wrapper;

    mapping(uint => mapping(uint => address)) public spots;

    constructor(address _implementation, address _registry, address _pool, address _router, address _rewardToken, address _wrapper, address _admin) {
        implementation = _implementation;
        registry = _registry;
        pool = _pool;
        router = _router;
        rewardToken = _rewardToken;
        wrapper = _wrapper;
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(UPDATEIMPLEMENTATION_ROLE, _admin);
    }

    function create(uint poolIndex) public returns(address) {
        uint ownerId = IRDNRegistry(registry).getUserIdByAddress(msg.sender);
        require(IRDNRegistry(registry).isActive(ownerId), "not active RDN");
        address spot = _create(ownerId, poolIndex);
        return spot;
    }

    function createAndDeposit(
        uint poolIndex,
        uint amount, 
        ISpotV1.Swap memory swap0, 
        ISpotV1.Swap memory swap1,
        ISpotV1.Swap memory swapReward0,
        ISpotV1.Swap memory swapReward1,
        uint deadline
    ) public payable returns(address) {
        uint ownerId = IRDNRegistry(registry).getUserIdByAddress(msg.sender);
        require(IRDNRegistry(registry).isActive(ownerId), "not active RDN");
        address spot = _create(ownerId, poolIndex);
        if (msg.value > 0) {
            ISpotV1(spot).deposit{value: msg.value}(amount, swap0, swap1, swapReward0, swapReward1, deadline);
        } else {
            IERC20(swap0.path[0]).safeTransferFrom(msg.sender, address(this), amount);
            amount = IERC20(swap0.path[0]).balanceOf(address(this));
            IERC20(swap0.path[0]).approve(spot, amount);
            ISpotV1(spot).deposit(amount, swap0, swap1, swapReward0, swapReward1, deadline);
        }
        return spot;
    }

    function updateImplementation(address _implementation) public onlyRole(UPDATEIMPLEMENTATION_ROLE) {
        implementation = _implementation;
    }

    function _create(uint ownerId, uint poolIndex) internal returns(address) {
        require(spots[ownerId][poolIndex] == address(0), "spot already created");

        address stakingToken = IMasterChef2(pool).lpToken(poolIndex);
        require(stakingToken != address(0), "wrong pool index");

        address spot = Clones.clone(implementation);

        ISpotV1(spot).init(wrapper, pool, router, stakingToken, rewardToken, poolIndex, ownerId, registry, address(this));

        // pools[ownerId].push(poolIndex);
        spots[ownerId][poolIndex] = spot;
        
        emit SpotCreated(spot, ownerId, poolIndex);
        
        return spot;
    }

    function getAllUserSpots(uint ownerId) public view returns(address[] memory) {
        uint poolsCount = IMasterChef2(pool).poolLength();
        address[] memory spotsArray = new address[](poolsCount);
        for (uint i=0; i < poolsCount; i++) {
            spotsArray[i] = spots[ownerId][i];
        }
        return spotsArray;
    }

    function getSpotAddress(uint ownerId, uint poolIndex) public view returns(address) {
        return spots[ownerId][poolIndex];
    }

}

// File: src/DeFi/Spot/SpotFactoryV2.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/proxy/Clones.sol";
import {IRDNRegistry} from "../../RDN/interfaces/IRDNRegistry.sol";
import "./IMasterChef2.sol";
import "./ISpotV2.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

contract SpotFactoryV2 is AccessControlEnumerable{
    
     bytes32 public constant UPDATEIMPLEMENTATION_ROLE = keccak256("UPDATEIMPLEMENTATION_ROLE");

    event SpotCreated(address indexed spotAddress, uint indexed ownerId, uint indexed poolIndex);

    using SafeERC20 for IERC20;

    address public implementation;
    address public immutable registry;
    address public immutable pool;
    address public immutable router;
    address public immutable rewardToken;
    address public immutable wrapper;

    mapping(uint => mapping(uint => address)) public spots;

    constructor(address _implementation, address _registry, address _pool, address _router, address _rewardToken, address _wrapper, address _admin) {
        implementation = _implementation;
        registry = _registry;
        pool = _pool;
        router = _router;
        rewardToken = _rewardToken;
        wrapper = _wrapper;
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(UPDATEIMPLEMENTATION_ROLE, _admin);
    }

    function create(uint poolIndex) public returns(address) {
        uint ownerId = IRDNRegistry(registry).getUserIdByAddress(msg.sender);
        require(IRDNRegistry(registry).isActive(ownerId), "not active RDN");
        address spot = _create(ownerId, poolIndex);
        return spot;
    }

    function createAndDeposit(
        uint poolIndex,
        uint amount, 
        ISpotV2.Swap memory swap0, 
        ISpotV2.Swap memory swap1,
        ISpotV2.Swap memory swapReward0,
        ISpotV2.Swap memory swapReward1,
        uint deadline
    ) public payable returns(address) {
        uint ownerId = IRDNRegistry(registry).getUserIdByAddress(msg.sender);
        require(IRDNRegistry(registry).isActive(ownerId), "not active RDN");
        address spot = _create(ownerId, poolIndex);
        if (msg.value > 0) {
            ISpotV2(spot).deposit{value: msg.value}(amount, swap0, swap1, swapReward0, swapReward1, deadline);
        } else {
            IERC20(swap0.path[0]).safeTransferFrom(msg.sender, address(this), amount);
            amount = IERC20(swap0.path[0]).balanceOf(address(this));
            IERC20(swap0.path[0]).approve(spot, amount);
            ISpotV2(spot).deposit(amount, swap0, swap1, swapReward0, swapReward1, deadline);
        }
        return spot;
    }

    function updateImplementation(address _implementation) public onlyRole(UPDATEIMPLEMENTATION_ROLE) {
        implementation = _implementation;
    }

    function _create(uint ownerId, uint poolIndex) internal returns(address) {
        require(spots[ownerId][poolIndex] == address(0), "spot already created");

        address stakingToken = IMasterChef2(pool).lpToken(poolIndex);
        require(stakingToken != address(0), "wrong pool index");

        address spot = Clones.clone(implementation);

        ISpotV2(spot).init(wrapper, pool, router, stakingToken, rewardToken, poolIndex, ownerId, registry, address(this));

        // pools[ownerId].push(poolIndex);
        spots[ownerId][poolIndex] = spot;
        
        emit SpotCreated(spot, ownerId, poolIndex);
        
        return spot;
    }

    function getAllUserSpots(uint ownerId) public view returns(address[] memory) {
        uint poolsCount = IMasterChef2(pool).poolLength();
        address[] memory spotsArray = new address[](poolsCount);
        for (uint i=0; i < poolsCount; i++) {
            spotsArray[i] = spots[ownerId][i];
        }
        return spotsArray;
    }

    function getSpotAddress(uint ownerId, uint poolIndex) public view returns(address) {
        return spots[ownerId][poolIndex];
    }

}

// File: src/DeFi/Spot/SpotRouterV2.sol


// File: src/DeFi/Spot/SpotV0.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./IMasterChef2.sol";
import "./IUniswapV2Pair.sol";
import "./IUniswapV2Router.sol";
import "./SafeUniswapV2Router.sol";
import "../../RDN/RDNOwnable.sol";

contract SpotV0 is RDNOwnable, IERC20 {
    using SafeERC20 for IERC20;
    using SafeUniswapV2Router for IUniswapV2Router;

    // todo
    // RDN user as owner !!!
    // any lowlevel call by admin !!!
    // is ERC20, only for RDN owner. Deposit / withdraw based on strategy tokens (minting/burning) !!!
    // return remained
    // swap token0 to token0 !!!
    // swap fees support
    // safeERC20
    // BNB support
    // withdraw any !!!
    // call any !!!
    // restake rules
    // transfers logs to userId
    // informative name and symbol
    // owner should be active
    // tariffs / subscription rules
    // deposit / withdraw without restake ??
    // APR / APY
    // StableSwap support
    // separated ERC20 implementation

    // ERC20 implementation
    mapping(uint => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    uint private _totalSupply;
    string private _name;
    string private _symbol;

    struct Swap {
        address[] path;
        uint outMin;
    }

    address public pool;
    address public router;
    address public stakingToken;
    address public rewardToken;
    uint public poolIndex;

    address public factory;

    constructor() {

    }

    function init(
        address _pool,
        address _router,
        address _stakingToken,
        address _rewardToken,
        uint _poolIndex,
        uint _ownerId,
        address _registry,
        address _factory
    ) external {
        pool = _pool;
        router = _router;
        stakingToken = _stakingToken;
        rewardToken = _rewardToken;
        poolIndex = _poolIndex;

        initRDNOwnable(_registry, _ownerId);
        factory = _factory;

        _symbol = 'SPOT0';
        _name = "SPOTv0 Share Token";
    }

    function deposit(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) public {
        address _stakingToken = stakingToken; // gas savings
        address _pool = pool; // gas savings
        uint _poolIndex = poolIndex; //gas savings

        if (IMasterChef2(pool).pendingCake(poolIndex, address(this)) > 0) {
            _restake(deadline, swapReward0, swapReward1);
        }

        // prepare to mint
        uint beforeDepositSupply = _totalSupply;
        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint beforeDepositBalance = userInfo.amount;

        // buy liquidity and stake
        IERC20(swap0.path[0]).safeTransferFrom(msg.sender, address(this), amount);
        _buyLiquidity(amount, swap0, swap1, deadline);
        _stake(IERC20(_stakingToken).balanceOf(address(this)));

        // mint
        userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint afterDepositBalance = userInfo.amount;
        uint amountToMint;
        if (beforeDepositBalance == 0) {
            amountToMint = afterDepositBalance;
        } else {
            amountToMint = ((afterDepositBalance - beforeDepositBalance) * beforeDepositSupply) / beforeDepositBalance;
        }

        _mint(ownerId, amountToMint);
    }

    function withdraw(
        uint amountToBurn,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) public onlyRDNOwner(msg.sender) {
        address _pool = pool; // gas savings
        uint _poolIndex = poolIndex; //gas savings
        address tokenToWithdraw = swap0.path[swap0.path.length - 1];

        if (IMasterChef2(pool).pendingCake(poolIndex, address(this)) > 0) {
            _restake(deadline, swapReward0, swapReward1);
        }

        // prepare to burn
        uint beforeWithdrawSupply = _totalSupply;
        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint beforeWithdrawBalance = userInfo.amount;

        // sell liquidity
        // refactor to strategy tokens base calculation
        uint amountToWithdraw = ((amountToBurn * beforeWithdrawBalance)) / beforeWithdrawSupply;
        _unStake(amountToWithdraw);

        _sellLiquidity(amountToWithdraw, swap0, swap1, deadline);

        // withdraw tokens swap[0].path[swap.path.length - 1]
        IERC20(tokenToWithdraw).transfer(msg.sender, IERC20(tokenToWithdraw).balanceOf(address(this)));

        //burn
        _burn(ownerId, amountToBurn);
    }

    function callAny(address payable _addr, bytes memory _data) public payable onlyRDNOwner(msg.sender) returns(bool success, bytes memory data){
        (success, data) = _addr.call{value: msg.value}(_data);
    }
    
    function restake(
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) public {
        _restake(deadline, swapReward0, swapReward1);
    }

    function info() public view returns (uint, address, uint, uint) {
        address _pool = pool; // gas savings
        uint _poolIndex = poolIndex; //gas savings

        uint reward = IMasterChef2(_pool).pendingCake(_poolIndex, address(this));
        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint staking = userInfo.amount;

        return (poolIndex, stakingToken, reward, staking);
    }

    function _restake(
        uint deadline,
        Swap memory swap0,
        Swap memory swap1
    ) internal {
        IMasterChef2 _pool = IMasterChef2(pool); // gas savings
        IERC20 _rewardToken = IERC20(rewardToken); // gas savings

        require(_pool.pendingCake(poolIndex, address(this)) > 0, "nothing to claim");

        _pool.deposit(poolIndex, 0); // get all reward
        uint amount = _rewardToken.balanceOf(address(this));
        _buyLiquidity(amount, swap0, swap1, deadline);
        _stake(IERC20(stakingToken).balanceOf(address(this)));
    }

    function _buyLiquidity(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        uint deadline
    ) internal returns(address token0, address token1) {
        require(swap0.path[0] == swap1.path[0], "start tokens should be equal");
        
        IUniswapV2Pair to = IUniswapV2Pair(stakingToken);

        // prepare tokens
        token0 = to.token0();
        token1 = to.token1();
        require(swap0.path[swap0.path.length - 1] == token0, "token0 is invalid");
        require(swap1.path[swap1.path.length - 1] == token1, "token1 is invalid");

        // swap input tokens
        _approve(IERC20(swap0.path[0]), address(router), amount);
        uint amount0In = amount / 2;
        _swap(amount0In, swap0.outMin, swap0.path, deadline);
        uint amount1In = amount - amount0In;
        _swap(amount1In, swap1.outMin, swap1.path, deadline);

        _addLiquidity(token0, token1, deadline);

        // todo: return remained

    }

    function _sellLiquidity(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        uint deadline
    ) internal returns(address token0, address token1) {
        require(swap0.path[swap0.path.length-1] == swap1.path[swap1.path.length-1], "end tokens should be equal");
        
        IUniswapV2Pair from = IUniswapV2Pair(stakingToken);

        // prepare tokens / remove liquidity
        token0 = from.token0();
        token1 = from.token1();
        _removeLiquidity(amount, token0, token1, deadline);
        require(swap0.path[0] == token0, "token0 is invalid");
        require(swap1.path[0] == token1, "token1 is invalid");
        uint amount0 = IERC20(token0).balanceOf(address(this));
        uint amount1 = IERC20(token1).balanceOf(address(this));

        // swap from tokens
        _approve(IERC20(token0), address(router), amount0);
        _approve(IERC20(token1), address(router), amount1);
        _swap(amount0, swap0.outMin, swap0.path, deadline);
        _swap(amount1, swap1.outMin, swap1.path, deadline);

        // todo: return remained

    }

    function _addLiquidity(
        address token0,
        address token1,
        uint deadline
    ) internal {
        address _router = router; // gas savings
        uint amountIn0 = IERC20(token0).balanceOf(address(this));
        uint amountIn1 = IERC20(token1).balanceOf(address(this));
        _approve(IERC20(token0), _router, amountIn0);
        _approve(IERC20(token1), _router, amountIn1);
        IUniswapV2Router(_router).addLiquidity(
            token0,
            token1,
            amountIn0,
            amountIn1,
            0,
            0,
            address(this),
            deadline
        );
    }

    function _removeLiquidity(
        uint amount,
        address token0,
        address token1,
        uint deadline
    ) internal {
        address _router = router; // gas savings
        address _stakingToken = stakingToken; // gas savings

        require(amount <= IERC20(_stakingToken).balanceOf(address(this)), "not enough liquidity to remove");

        _approve(IERC20(_stakingToken), _router, amount);
        IUniswapV2Router(_router).removeLiquidity(
            token0,
            token1,
            amount,
            0,
            0,
            address(this),
            deadline
        );
    }

    function _approve(
        IERC20 token,
        address spender,
        uint amount
    ) internal {
        if (token.allowance(address(this), spender) != 0) {
            token.safeApprove(spender, 0);
        }
        token.safeApprove(spender, amount);
    }

    function _swap(
        uint amount,
        uint outMin,
        address[] memory path,
        uint deadline
    ) internal {
        if (path[0] == path[path.length - 1]) return;

        // IUniswapV2Router(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(
        IUniswapV2Router(router).swapExactTokensForTokens(
            amount,
            outMin,
            path,
            address(this),
            deadline
        );
    }

    function _stake(uint amount) internal {
        _approve(IERC20(stakingToken), pool, amount);
        IMasterChef2(pool).deposit(poolIndex, amount);
    }

    function _unStake(uint amount) internal {
        IMasterChef2(pool).withdraw(poolIndex, amount);
    }


    // ERC20 implementation

    function balanceOf(address _account) public view returns (uint) {
        uint userId = IRDNRegistry(registry).getUserIdByAddress(_account);
        return _balances[userId];
    }

    function allowance(address owner, address spender) public view returns (uint) {
        return _allowances[owner][spender];
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return 18;
    }

    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }

    // solc-ignore-next-line func-mutability
    function transfer(address to, uint amount) external returns (bool) {
        revert("non-transferable");  // SpotV0 is non-transferable
    }

    // solc-ignore-next-line func-mutability
    function approve(address spender, uint amount) external returns (bool) {
        revert("non-transferable");  // SpotV0 is non-transferable
    }

    // solc-ignore-next-line func-mutability
    function transferFrom(
        address from,
        address to,
        uint amount
    ) external returns (bool) {
        revert("non-transferable");  // SpotV0 is non-transferable
    }

    function _mint(uint userId, uint amount) internal {
        address account = IRDNRegistry(registry).getUserAddress(userId);
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply += amount;
        unchecked {
            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
            _balances[userId] += amount;
        }
        emit Transfer(address(0), account, amount);
    }

    function _burn(uint userId, uint amount) internal {
        address account = IRDNRegistry(registry).getUserAddress(userId);
        require(account != address(0), "ERC20: burn from zero address");

        uint accountBalance = _balances[userId];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[userId] = accountBalance - amount;
            // Overflow not possible: amount <= accountBalance <= totalSupply.
            _totalSupply -= amount;
        }

        emit Transfer(account, address(0), amount);
    }


}

// File: src/DeFi/Spot/SpotV1.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./IMasterChef2.sol";
import "./IUniswapV2Pair.sol";
import "./IUniswapV2Router.sol";
import "./ERC20Spot.sol";
import "./IWrap.sol";

contract SpotV1 is ERC20Spot {
    using SafeERC20 for IERC20;

    struct Swap {
        address[] path;
        uint outMin;
    }

    event SpotLog(
        uint8 indexed operationType, // 0 - deposit, 1 - withdrawal, 2 - restake
        address indexed token, // deposit or withdrawal token
        uint tokenAmount,
        uint lpAmount, // amount of LP deposited or withdrawn
        uint lpToken0Amount,
        uint lpToken1Amount
    );

    address public pool;
    address public router;
    address public stakingToken;
    address public rewardToken;
    uint public poolIndex;
    uint public totalEarned;

    address public factory;

    address public wrapper;

    constructor() {

    }

    function init(
        address _wrapper,
        address _pool,
        address _router,
        address _stakingToken,
        address _rewardToken,
        uint _poolIndex,
        uint _ownerId,
        address _registry,
        address _factory
    ) external {
        require(wrapper == address(0), "Already initialized");

        wrapper = _wrapper;
        pool = _pool;
        router = _router;
        stakingToken = _stakingToken;
        rewardToken = _rewardToken;
        poolIndex = _poolIndex;

        initERC20Spot(_registry, _ownerId);

        factory = _factory;
    }

    function deposit(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) public payable {
        require(isActiveRDNOwner(msg.sender) || msg.sender == factory, "Access denied");
        address _stakingToken = stakingToken; // gas savings
        address _pool = pool; // gas savings
        uint _poolIndex = poolIndex; //gas savings

        if (IMasterChef2(pool).pendingCake(poolIndex, address(this)) > 0) {
            _restake(deadline, swapReward0, swapReward1);
        }

        // prepare to mint
        uint beforeDepositSupply = totalSupply();
        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint beforeDepositBalance = userInfo.amount;

        // buy liquidity and stake
        if (msg.value > 0) {
            require(swap0.path[0] == wrapper, "wrong path");
            amount = msg.value;
            IWrap(wrapper).deposit{value: amount}();
        } else {
            IERC20(swap0.path[0]).safeTransferFrom(msg.sender, address(this), amount);
            amount = IERC20(swap0.path[0]).balanceOf(address(this));
        }
        
        _buyLiquidity(amount, swap0, swap1, deadline);
        uint stakingTokenAmount = IERC20(_stakingToken).balanceOf(address(this));
        _log(0, swap0.path[0], amount, stakingTokenAmount);
        _stake(stakingTokenAmount);

        // mint
        userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint afterDepositBalance = userInfo.amount;
        uint amountToMint;
        if (beforeDepositBalance == 0) {
            amountToMint = afterDepositBalance;
        } else {
            amountToMint = ((afterDepositBalance - beforeDepositBalance) * beforeDepositSupply) / beforeDepositBalance;
        }

        _mint(ownerId, amountToMint);

        // _returnRemainder(swap0.path[0]);
    }

    function withdraw(
        uint amountToBurn,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) public onlyActiveRDNOwner(msg.sender) {
        address _pool = pool; // gas savings
        uint _poolIndex = poolIndex; //gas savings
        address tokenToWithdraw = swap0.path[swap0.path.length - 1];

        if (IMasterChef2(pool).pendingCake(poolIndex, address(this)) > 0) {
            _restake(deadline, swapReward0, swapReward1);
        }

        // prepare to burn
        uint beforeWithdrawSupply = totalSupply();
        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint beforeWithdrawBalance = userInfo.amount;

        // sell liquidity
        uint amountToWithdraw = ((amountToBurn * beforeWithdrawBalance)) / beforeWithdrawSupply;
        _unStake(amountToWithdraw);

        _sellLiquidity(amountToWithdraw, swap0, swap1, deadline);

        

        // withdraw tokens tokenToWithdraw
        if (tokenToWithdraw == wrapper) {
            IWrap(wrapper).withdraw(IWrap(wrapper).balanceOf(address(this)));
            _log(1, tokenToWithdraw, address(this).balance, amountToWithdraw);
            (bool sentRecipient, ) = payable(msg.sender).call{value: address(this).balance}("");
            require(sentRecipient, "transfer BNB to recipeint failed");
        } else {
            uint withdrawTokenAmount = IERC20(tokenToWithdraw).balanceOf(address(this));
            _log(1, tokenToWithdraw, withdrawTokenAmount, amountToWithdraw);
            IERC20(tokenToWithdraw).safeTransfer(msg.sender, withdrawTokenAmount);
        }

        //burn
        _burn(ownerId, amountToBurn);

        // _returnRemainder(swap0.path[swap0.path.length - 1]);
    }

    function callAny(address payable _addr, bytes memory _data) public payable onlyRDNOwner(msg.sender) returns(bool success, bytes memory data){
        (success, data) = _addr.call{value: msg.value}(_data);
    }
    
    function restake(
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) public onlyActiveRDNOwner(msg.sender) {
        _restake(deadline, swapReward0, swapReward1);
        // _returnRemainder(swapReward0.path[0]);
    }

    function info() public view returns (uint, address, uint, uint, uint) {
        address _pool = pool; // gas savings
        uint _poolIndex = poolIndex; //gas savings

        uint reward = IMasterChef2(_pool).pendingCake(_poolIndex, address(this));
        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint staking = userInfo.amount;

        return (poolIndex, stakingToken, reward, staking, totalEarned+reward);
    }

    function _log(uint8 operationType, address token, uint tokenAmount, uint lpAmount) internal {
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(stakingToken).getReserves();
        uint totalLpSupply = IERC20(stakingToken).totalSupply();
        uint lpToken0Amount = (lpAmount * reserve0)/totalLpSupply;
        uint lpToken1Amount = (lpAmount * reserve1)/totalLpSupply;
        emit SpotLog(operationType, token, tokenAmount, lpAmount, lpToken0Amount, lpToken1Amount);
    }

    function _restake(
        uint deadline,
        Swap memory swap0,
        Swap memory swap1
    ) internal returns(address token0, address token1) {
        IMasterChef2 _pool = IMasterChef2(pool); // gas savings
        IERC20 _rewardToken = IERC20(rewardToken); // gas savings

        require(_pool.pendingCake(poolIndex, address(this)) > 0, "nothing to claim");

        totalEarned += _pool.pendingCake(poolIndex, address(this));
        _pool.deposit(poolIndex, 0); // get all reward
        uint amount = _rewardToken.balanceOf(address(this));
        (token0, token1) = _buyLiquidity(amount, swap0, swap1, deadline);
        uint stakingTokenAmount = IERC20(stakingToken).balanceOf(address(this));
        _log(2, rewardToken, amount, stakingTokenAmount);
        _stake(stakingTokenAmount);
    }

    function _buyLiquidity(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        uint deadline
    ) internal returns(address token0, address token1) {
        require(swap0.path[0] == swap1.path[0], "start tokens should be equal");
        
        IUniswapV2Pair to = IUniswapV2Pair(stakingToken);

        // prepare tokens
        token0 = to.token0();
        token1 = to.token1();
        require(swap0.path[swap0.path.length - 1] == token0, "token0 is invalidddd");
        require(swap1.path[swap1.path.length - 1] == token1, "token1 is invalid");

        // swap input tokens
        _approve(IERC20(swap0.path[0]), address(router), amount);
        uint amount0In = amount / 2;
        _swap(amount0In, swap0.outMin, swap0.path, deadline);
        uint amount1In = amount - amount0In;
        _swap(amount1In, swap1.outMin, swap1.path, deadline);

        _addLiquidity(token0, token1, deadline);

    }

    function _sellLiquidity(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        uint deadline
    ) internal returns(address token0, address token1) {
        require(swap0.path[swap0.path.length-1] == swap1.path[swap1.path.length-1], "end tokens should be equal");
        
        IUniswapV2Pair from = IUniswapV2Pair(stakingToken);

        // prepare tokens / remove liquidity
        token0 = from.token0();
        token1 = from.token1();
        _removeLiquidity(amount, token0, token1, deadline);
        require(swap0.path[0] == token0, "token0 is invalid");
        require(swap1.path[0] == token1, "token1 is invalid");
        uint amount0 = IERC20(token0).balanceOf(address(this));
        uint amount1 = IERC20(token1).balanceOf(address(this));

        // swap from tokens
        _approve(IERC20(token0), address(router), amount0);
        _approve(IERC20(token1), address(router), amount1);
        _swap(amount0, swap0.outMin, swap0.path, deadline);
        _swap(amount1, swap1.outMin, swap1.path, deadline);


    }

    function _addLiquidity(
        address token0,
        address token1,
        uint deadline
    ) internal {
        address _router = router; // gas savings
        uint amountIn0 = IERC20(token0).balanceOf(address(this));
        uint amountIn1 = IERC20(token1).balanceOf(address(this));
        _approve(IERC20(token0), _router, amountIn0);
        _approve(IERC20(token1), _router, amountIn1);
        IUniswapV2Router(_router).addLiquidity(
            token0,
            token1,
            amountIn0,
            amountIn1,
            0,
            0,
            address(this),
            deadline
        );
    }

    function _removeLiquidity(
        uint amount,
        address token0,
        address token1,
        uint deadline
    ) internal {
        address _router = router; // gas savings
        address _stakingToken = stakingToken; // gas savings

        require(amount <= IERC20(_stakingToken).balanceOf(address(this)), "not enough liquidity to remove");

        _approve(IERC20(_stakingToken), _router, amount);
        IUniswapV2Router(_router).removeLiquidity(
            token0,
            token1,
            amount,
            0,
            0,
            address(this),
            deadline
        );
    }

    function _approve(
        IERC20 token,
        address spender,
        uint amount
    ) internal {
        if (token.allowance(address(this), spender) != 0) {
            token.safeApprove(spender, 0);
        }
        token.safeApprove(spender, amount);
    }

    function _swap(
        uint amount,
        uint outMin,
        address[] memory path,
        uint deadline
    ) internal {
        if (path[0] == path[path.length - 1]) return;

        IUniswapV2Router(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(
        // IUniswapV2Router(router).swapExactTokensForTokens(
            amount,
            outMin,
            path,
            address(this),
            deadline
        );
    }

    function _stake(uint amount) internal {
        _approve(IERC20(stakingToken), pool, amount);
        IMasterChef2(pool).deposit(poolIndex, amount);
    }

    function _unStake(uint amount) internal {
        IMasterChef2(pool).withdraw(poolIndex, amount);
    }

    function _returnRemainder(address token3) internal {
        address[3] memory tokens = [IUniswapV2Pair(stakingToken).token0(), IUniswapV2Pair(stakingToken).token1(), token3];
        address target = IRDNRegistry(registry).getUserAddress(ownerId);

        for (uint256 i = 0; i < tokens.length; i++) {
            if (tokens[i] == address(0)) continue;
            uint256 tokenBalance = IERC20(tokens[i]).balanceOf(address(this));
            if (tokenBalance > 0) {
                if (tokens[i] == wrapper) {
                    IWrap(wrapper).withdraw(tokenBalance);
                    (bool sentRecipient, ) = payable(target).call{value: address(this).balance}("");
                    require(sentRecipient, "transfer ETH to recipeint failed");
                } else {
                    IERC20(tokens[i]).safeTransfer(target, tokenBalance);
                }
            }
        }
  }


}

// File: src/DeFi/Spot/SpotV2.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./IMasterChef2.sol";
import "./IUniswapV2Pair.sol";
import "./IUniswapV2Router.sol";
import "./ERC20Spot.sol";
import "./IWrap.sol";

contract SpotV2 is ERC20Spot {
    using SafeERC20 for IERC20;

    struct Swap {
        address[] path;
        uint outMin;
    }

    event SpotLog(
        uint8 indexed operationType, // 0 - deposit, 1 - withdrawal, 2 - restake
        address indexed token, // deposit or withdrawal token
        uint tokenAmount,
        uint lpAmount, // amount of LP deposited or withdrawn
        uint lpToken0Amount,
        uint lpToken1Amount
    );

    address public pool;
    address public router;
    address public stakingToken;
    address public rewardToken;
    uint public poolIndex;
    uint public totalEarned;

    address public factory;

    address public wrapper;

    constructor() {

    }

    function init(
        address _wrapper,
        address _pool,
        address _router,
        address _stakingToken,
        address _rewardToken,
        uint _poolIndex,
        uint _ownerId,
        address _registry,
        address _factory
    ) external {
        require(wrapper == address(0), "Already initialized");

        wrapper = _wrapper;
        pool = _pool;
        router = _router;
        stakingToken = _stakingToken;
        rewardToken = _rewardToken;
        poolIndex = _poolIndex;

        initERC20Spot(_registry, _ownerId);

        factory = _factory;
    }

    function deposit(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) public payable {
        require(isActiveRDNOwner(msg.sender) || msg.sender == factory, "Access denied");
        address _stakingToken = stakingToken; // gas savings
        address _pool = pool; // gas savings
        uint _poolIndex = poolIndex; //gas savings

        if (IMasterChef2(pool).pendingCake(poolIndex, address(this)) > 0) {
            _restake(deadline, swapReward0, swapReward1);
        }

        // prepare to mint
        uint beforeDepositSupply = totalSupply();
        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint beforeDepositBalance = userInfo.amount;

        // buy liquidity and stake
        if (msg.value > 0) {
            require(swap0.path[0] == wrapper, "wrong path");
            amount = msg.value;
            IWrap(wrapper).deposit{value: amount}();
        } else {
            IERC20(swap0.path[0]).safeTransferFrom(msg.sender, address(this), amount);
            amount = IERC20(swap0.path[0]).balanceOf(address(this));
        }
        
        _buyLiquidity(amount, swap0, swap1, deadline);
        uint stakingTokenAmount = IERC20(_stakingToken).balanceOf(address(this));
        _log(0, swap0.path[0], amount, stakingTokenAmount);
        _stake(stakingTokenAmount);

        // mint
        userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint afterDepositBalance = userInfo.amount;
        uint amountToMint;
        if (beforeDepositBalance == 0) {
            amountToMint = afterDepositBalance;
        } else {
            amountToMint = ((afterDepositBalance - beforeDepositBalance) * beforeDepositSupply) / beforeDepositBalance;
        }

        _mint(ownerId, amountToMint);

        // _returnRemainder(swap0.path[0]);
    }

    function withdraw(
        uint amountToBurn,
        Swap memory swap0,
        Swap memory swap1,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) public onlyActiveRDNOwner(msg.sender) {
        address _pool = pool; // gas savings
        uint _poolIndex = poolIndex; //gas savings
        address tokenToWithdraw = swap0.path[swap0.path.length - 1];

        if (IMasterChef2(pool).pendingCake(poolIndex, address(this)) > 0) {
            _restake(deadline, swapReward0, swapReward1);
        }

        // prepare to burn
        uint beforeWithdrawSupply = totalSupply();
        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint beforeWithdrawBalance = userInfo.amount;

        // sell liquidity
        uint amountToWithdraw = ((amountToBurn * beforeWithdrawBalance)) / beforeWithdrawSupply;
        _unStake(amountToWithdraw);

        _sellLiquidity(amountToWithdraw, swap0, swap1, deadline);

        

        // withdraw tokens tokenToWithdraw
        if (tokenToWithdraw == wrapper) {
            IWrap(wrapper).withdraw(IWrap(wrapper).balanceOf(address(this)));
            _log(1, tokenToWithdraw, address(this).balance, amountToWithdraw);
            (bool sentRecipient, ) = payable(msg.sender).call{value: address(this).balance}("");
            require(sentRecipient, "transfer BNB to recipeint failed");
        } else {
            uint withdrawTokenAmount = IERC20(tokenToWithdraw).balanceOf(address(this));
            _log(1, tokenToWithdraw, withdrawTokenAmount, amountToWithdraw);
            IERC20(tokenToWithdraw).safeTransfer(msg.sender, withdrawTokenAmount);
        }

        //burn
        _burn(ownerId, amountToBurn);

        // _returnRemainder(swap0.path[swap0.path.length - 1]);
    }

    function callAny(address payable _addr, bytes memory _data) public payable onlyRDNOwner(msg.sender) returns(bool success, bytes memory data){
        (success, data) = _addr.call{value: msg.value}(_data);
    }
    
    function restake(
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint deadline
    ) public onlyActiveRDNOwner(msg.sender) {
        _restake(deadline, swapReward0, swapReward1);
        // _returnRemainder(swapReward0.path[0]);
    }

    function info() public view returns (uint, address, uint, uint, uint) {
        address _pool = pool; // gas savings
        uint _poolIndex = poolIndex; //gas savings

        uint reward = IMasterChef2(_pool).pendingCake(_poolIndex, address(this));
        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
        uint staking = userInfo.amount;

        return (poolIndex, stakingToken, reward, staking, totalEarned+reward);
    }

    function _log(uint8 operationType, address token, uint tokenAmount, uint lpAmount) internal {
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(stakingToken).getReserves();
        uint totalLpSupply = IERC20(stakingToken).totalSupply();
        uint lpToken0Amount = (lpAmount * reserve0)/totalLpSupply;
        uint lpToken1Amount = (lpAmount * reserve1)/totalLpSupply;
        emit SpotLog(operationType, token, tokenAmount, lpAmount, lpToken0Amount, lpToken1Amount);
    }

    function _restake(
        uint deadline,
        Swap memory swap0,
        Swap memory swap1
    ) internal returns(address token0, address token1) {
        IMasterChef2 _pool = IMasterChef2(pool); // gas savings
        IERC20 _rewardToken = IERC20(rewardToken); // gas savings

        require(_pool.pendingCake(poolIndex, address(this)) > 0, "nothing to claim");

        totalEarned += _pool.pendingCake(poolIndex, address(this));
        _pool.deposit(poolIndex, 0); // get all reward
        uint amount = _rewardToken.balanceOf(address(this));
        (token0, token1) = _buyLiquidity(amount, swap0, swap1, deadline);
        uint stakingTokenAmount = IERC20(stakingToken).balanceOf(address(this));
        _log(2, rewardToken, amount, stakingTokenAmount);
        _stake(stakingTokenAmount);
    }

    function _buyLiquidity(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        uint deadline
    ) internal returns(address token0, address token1) {
        require(swap0.path[0] == swap1.path[0], "start tokens should be equal");
        
        IUniswapV2Pair to = IUniswapV2Pair(stakingToken);

        // prepare tokens
        token0 = to.token0();
        token1 = to.token1();
        require(swap0.path[swap0.path.length - 1] == token0, "token0 is invalidddd");
        require(swap1.path[swap1.path.length - 1] == token1, "token1 is invalid");

        // swap input tokens
        _approve(IERC20(swap0.path[0]), address(router), amount);
        uint amount0In = amount / 2;
        _swap(amount0In, swap0.outMin, swap0.path, deadline);
        uint amount1In = amount - amount0In;
        _swap(amount1In, swap1.outMin, swap1.path, deadline);

        _addLiquidity(token0, token1, deadline);

    }

    function _sellLiquidity(
        uint amount,
        Swap memory swap0,
        Swap memory swap1,
        uint deadline
    ) internal returns(address token0, address token1) {
        require(swap0.path[swap0.path.length-1] == swap1.path[swap1.path.length-1], "end tokens should be equal");
        
        IUniswapV2Pair from = IUniswapV2Pair(stakingToken);

        // prepare tokens / remove liquidity
        token0 = from.token0();
        token1 = from.token1();
        _removeLiquidity(amount, token0, token1, deadline);
        require(swap0.path[0] == token0, "token0 is invalid");
        require(swap1.path[0] == token1, "token1 is invalid");
        uint amount0 = IERC20(token0).balanceOf(address(this));
        uint amount1 = IERC20(token1).balanceOf(address(this));

        // swap from tokens
        _approve(IERC20(token0), address(router), amount0);
        _approve(IERC20(token1), address(router), amount1);
        _swap(amount0, swap0.outMin, swap0.path, deadline);
        _swap(amount1, swap1.outMin, swap1.path, deadline);


    }

    function _addLiquidity(
        address token0,
        address token1,
        uint deadline
    ) internal {
        address _router = router; // gas savings
        uint amountIn0 = IERC20(token0).balanceOf(address(this));
        uint amountIn1 = IERC20(token1).balanceOf(address(this));
        _approve(IERC20(token0), _router, amountIn0);
        _approve(IERC20(token1), _router, amountIn1);
        IUniswapV2Router(_router).addLiquidity(
            token0,
            token1,
            amountIn0,
            amountIn1,
            0,
            0,
            address(this),
            deadline
        );
    }

    function _removeLiquidity(
        uint amount,
        address token0,
        address token1,
        uint deadline
    ) internal {
        address _router = router; // gas savings
        address _stakingToken = stakingToken; // gas savings

        require(amount <= IERC20(_stakingToken).balanceOf(address(this)), "not enough liquidity to remove");

        _approve(IERC20(_stakingToken), _router, amount);
        IUniswapV2Router(_router).removeLiquidity(
            token0,
            token1,
            amount,
            0,
            0,
            address(this),
            deadline
        );
    }

    function _approve(
        IERC20 token,
        address spender,
        uint amount
    ) internal {
        if (token.allowance(address(this), spender) != 0) {
            token.safeApprove(spender, 0);
        }
        token.safeApprove(spender, amount);
    }

    function _swap(
        uint amount,
        uint outMin,
        address[] memory path,
        uint deadline
    ) internal {
        if (path[0] == path[path.length - 1]) return;

        IUniswapV2Router(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(
        // IUniswapV2Router(router).swapExactTokensForTokens(
            amount,
            outMin,
            path,
            address(this),
            deadline
        );
    }

    function _stake(uint amount) internal {
        _approve(IERC20(stakingToken), pool, amount);
        IMasterChef2(pool).deposit(poolIndex, amount);
    }

    function _unStake(uint amount) internal {
        IMasterChef2(pool).withdraw(poolIndex, amount);
    }

    function _returnRemainder(address token3) internal {
        address[3] memory tokens = [IUniswapV2Pair(stakingToken).token0(), IUniswapV2Pair(stakingToken).token1(), token3];
        address target = IRDNRegistry(registry).getUserAddress(ownerId);

        for (uint256 i = 0; i < tokens.length; i++) {
            if (tokens[i] == address(0)) continue;
            uint256 tokenBalance = IERC20(tokens[i]).balanceOf(address(this));
            if (tokenBalance > 0) {
                if (tokens[i] == wrapper) {
                    IWrap(wrapper).withdraw(tokenBalance);
                    (bool sentRecipient, ) = payable(target).call{value: address(this).balance}("");
                    require(sentRecipient, "transfer ETH to recipeint failed");
                } else {
                    IERC20(tokens[i]).safeTransfer(target, tokenBalance);
                }
            }
        }
  }


}

// File: src/DeFi/Spot/SpotV2MasterchefV3.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./IMasterChef2.sol";
import "../../interfaces/IPancakeV3Pool.sol";
import "../../interfaces/IMasterChefV3.sol";
import "../../interfaces/INonfungiblePositionManager.sol";
import "./IUniswapV2Router.sol";
import "./ERC20Spot.sol";
import "./IWrap.sol";

import "hardhat/console.sol";

contract SpotV2MasterchefV3 is ERC20Spot, Initializable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    receive() external payable {}

    struct Swap {
        address[] path;
        uint outMin;
    }

    IPancakeV3Pool public pool;  // v3Pool
    uint256 public pid;  // poolId
    address public token0;
    address public token1;
    uint24 public poolFee;

    IMasterChefV3 public masterchefV3;  // e.g. https://bscscan.com/address/0x556b9306565093c855aea9ae92a594704c2cd59e
    INonfungiblePositionManager public v3PositionManager;  // e.g. 0x46a15b0b27311cedf172ab29e4f4766fbe7f4364

    IUniswapV2Router public router;  // uniswap v2 interface router
    IERC20 public rewardToken;  // e.g. CAKE

    uint public totalEarned;  // just for stats
    address public factory;  // has access to deposit

    IWrap public wrapper;  // native coin erc20 wrapper
    
    event Deposit(
        address indexed sender,
        address indexed payToken,
        uint256 payTokenAmount,
        uint256 indexed positionTokenId,
        uint128 liquidityAmount,
        uint256 token0Amount,
        uint256 token1Amount
    );
    
    event RemainderReturned(
        address indexed token,
        uint256 amount,
        address indexed target
    );

    /**
     * @notice This event is emitted when a user withdraws tokens to a specified address.
     * @dev The `sender` is the address of the user who initiated the withdrawal transaction.
     * @dev The `token` is the address of the token contract from which the tokens are withdrawn.
     * @dev The `to` is the address to which the tokens are being sent.
     * @dev The `amount` is the number of tokens being withdrawn.
     */
    event WithdrawToken(
        address indexed sender,
        address indexed token,
        address indexed to,
        uint256 amount
    );

    /**
     * @notice This event is emitted when a user withdraws the entire deposit of a token with specified liquidity in exchange for another token.
     * @dev The `sender` is the address of the user who initiated the withdrawal transaction.
     * @dev The `tokenId` is the ID of the token being withdrawn.
     * @dev The `liquidity` is the amount of liquidity being withdrawn.
     * @dev The `amount0` is the amount of token0 being withdrawn.
     * @dev The `amount1` is the amount of token1 being withdrawn.
     * @dev The `targetToken` is the address of the token being received in exchange for the withdrawn token.
     * @dev The `targetTokenAmount` is the amount of target token being received in exchange for the withdrawn token.
     */
    event WithdrawEntireDeposit(
        address indexed sender,
        uint256 indexed tokenId,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1,
        address indexed targetToken,
        uint256 targetTokenAmount
    );

    /**
     * @notice This event is emitted when a user decreases the deposit of a token with specified liquidity in exchange for another token.
     * @dev The `sender` is the address of the user who initiated the decrease deposit transaction.
     * @dev The `tokenId` is the ID of the token whose deposit is being decreased.
     * @dev The `liquidity` is the amount of liquidity being burned.
     * @dev The `amount0` is the amount of token0 being withdrawn.
     * @dev The `amount1` is the amount of token1 being withdrawn.
     * @dev The `targetToken` is the address of the token being received in exchange for the withdrawn token.
     * @dev The `targetTokenAmount` is the amount of target token being received in exchange for the withdrawn token.
     */
    event DecreaseDeposit(
        address indexed sender,
        uint256 indexed tokenId,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1,
        address indexed targetToken,
        uint256 targetTokenAmount
    );

    /**
     * @notice This event is emitted when a user restakes rewards to the liquidity pool and receives additional liquidity tokens.
     * @dev The `sender` is the address of the user who initiated the restake transaction.
     * @dev The `tokenId` is the ID of the token being restaked.
     * @dev The `rewardAmount` is the amount of rewards being restaked.
     * @dev The `liquidity` is the amount of additional liquidity tokens being received.
     * @dev The `amount0` is the amount of token0 being received as part of the restaking process.
     * @dev The `amount1` is the amount of token1 being received as part of the restaking process.
     */
    event Restake(
        address indexed sender,
        uint256 indexed tokenId,
        uint256 rewardAmount,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1
    );

    /**
     * @notice This event is emitted when a user initiates a restake transaction without restaking any rewards.
     * @dev The `sender` is the address of the user who initiated the restake transaction.
     * @dev The `tokenId` is the ID of the token being restaked.
     */
    event RestakeNothing(
        address indexed sender,
        uint256 indexed tokenId
    );

    /**
     * @notice This event is emitted when a user deposits more liquidity to an existing position in the pool.
     * @dev The `sender` is the address of the user who initiated the deposit transaction.
     * @dev The `payToken` is the address of the token being used to pay for the additional liquidity.
     * @dev The `payTokenAmount` is the amount of pay token being used to pay for the additional liquidity.
     * @dev The `positionTokenId` is the ID of the token whose position is being added to.
     * @dev The `liquidityAmount` is the amount of additional liquidity tokens being minted.
     * @dev The `token0Amount` is the amount of token0 being added to the position.
     * @dev The `token1Amount` is the amount of token1 being added to the position.
     */
    event DepositMore(
        address indexed sender,
        address indexed payToken,
        uint256 payTokenAmount,
        uint256 indexed positionTokenId,
        uint128 liquidityAmount,
        uint256 token0Amount,
        uint256 token1Amount
    );


    modifier onlyActiveRDNOwnerOrFactory() {
        require(isActiveRDNOwner(msg.sender) || msg.sender == factory, "Access denied");
        _;
    }

    modifier validateBuySwaps(
        Swap memory swapBuy0,
        Swap memory swapBuy1
    ) {
        require(swapBuy0.path.length > 0, "empty swapBuy0");
        require(swapBuy1.path.length > 0, "empty swapBuy1");

        require(swapBuy0.path[0] == swapBuy1.path[0], "buy swaps start tokens not equal");
        require(swapBuy0.path[swapBuy0.path.length-1] == address(token0), "wrong swapBuy0 end token");
        require(swapBuy1.path[swapBuy1.path.length-1] == address(token1), "wrong swapBuy1 end token");
        _;
    }

    modifier validateRewardSwaps(
        Swap memory swapReward0,
        Swap memory swapReward1
    ) {
        require(swapReward0.path.length > 0, "empty swapReward0");
        require(swapReward1.path.length > 0, "empty swapReward1");

        require(swapReward0.path[0] == swapReward1.path[0], "swaps start tokens not equal");
        require(swapReward0.path[swapReward0.path.length-1] == address(token0), "wrong swap0 end token");
        require(swapReward1.path[swapReward1.path.length-1] == address(token1), "wrong swap1 end token");
        _;
    }

    modifier validateSellSwaps(
        Swap memory swapSell0,
        Swap memory swapSell1
    ) {
        require(swapSell0.path.length > 0, "empty swapSell0");
        require(swapSell1.path.length > 0, "empty swapSell1");

        require(swapSell0.path[swapSell0.path.length-1] == swapSell1.path[swapSell1.path.length-1], "swapSell end tokens not equal");
        require(swapSell0.path[0] == address(token0), "wrong swap0 start token");
        require(swapSell1.path[0] == address(token1), "wrong swap1 start token");
        _;
    }

    constructor() {/*empty because initialisable*/}

    function init(
        IMasterChefV3 _masterchefV3,
        uint256 _pid,
        IUniswapV2Router _router,
        uint _ownerId,
        address _registry,
        address _factory
    ) external initializer {
        masterchefV3 = _masterchefV3;
        wrapper = IWrap(_masterchefV3.WETH());
        v3PositionManager = INonfungiblePositionManager(_masterchefV3.nonfungiblePositionManager());

        pid = _pid;
        IMasterChefV3.PoolInfo memory _poolInfo = _masterchefV3.poolInfo(_pid);
        pool = _poolInfo.v3Pool;
        token0 = _poolInfo.token0;
        token1 = _poolInfo.token1;
        poolFee = _poolInfo.fee;

        router = _router;

        rewardToken = _masterchefV3.CAKE();

        initERC20Spot(_registry, _ownerId);
        factory = _factory;
    }

    event FactorySet(address factory);
    function setFactory(address _factory) external onlyActiveRDNOwnerOrFactory {
        factory = _factory;
        emit FactorySet(_factory);
    }

    struct DepositParams {
        uint256 amount;
        Swap swapBuy0;
        Swap swapBuy1;
        uint256 deadline;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Min;
        uint256 amount1Min;
    }

    /// @notice buy liquidity, provide to LP via positionmanager and deposit it to masterchef
    function deposit(DepositParams calldata params)
        external
        payable
        onlyActiveRDNOwnerOrFactory
        validateBuySwaps(params.swapBuy0, params.swapBuy1)
        nonReentrant
    {
        uint256 amount = params.amount;
        amount = _receiveInputToken(params.swapBuy0.path[0], params.amount);
        _buyLiquidityTokensForInputToken({
            amount: amount,
            swapBuy0: params.swapBuy0,
            swapBuy1: params.swapBuy1,
            deadline: params.deadline
        });
        console.log("IERC20(token0).balanceOf(address(this)) = ", IERC20(token0).balanceOf(address(this)));
        console.log("IERC20(token1).balanceOf(address(this)) = ", IERC20(token1).balanceOf(address(this)));
        (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        ) = _mintLiquidityNFT(
            MintLiquidityNFTParams({
                token0: token0,
                token1: token1,
                fee: poolFee,
                tickLower: params.tickLower,
                tickUpper: params.tickUpper,
                amount0Desired: IERC20(token0).balanceOf(address(this)),
                amount1Desired: IERC20(token1).balanceOf(address(this)),
                amount0Min: params.amount0Min,
                amount1Min: params.amount1Min,
                deadline: params.deadline
            })
        );
        v3PositionManager.safeTransferFrom(address(this), address(masterchefV3), tokenId);
        emit Deposit({
            sender: msg.sender,
            payToken: params.swapBuy0.path[0],
            payTokenAmount: params.amount,
            positionTokenId: tokenId,
            liquidityAmount: liquidity,
            token0Amount: amount0,
            token1Amount: amount1
        });
        _returnRemainder(params.swapBuy0.path[0]);
    }

    struct DepositMoreParams {
        uint256 tokenId;
        uint256 amount;
        Swap swapBuy0;
        Swap swapBuy1;
        Swap swapReward0;
        Swap swapReward1;
        uint256 deadline;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 restakeAmount0Min;
        uint256 restakeAmount1Min;
    }

    /// @notice buy more liquidity, provide to existent positionmanager tokenId in masterchef
    function depositMore(
        DepositMoreParams calldata params
    )
        external
        payable
        onlyActiveRDNOwnerOrFactory
        validateBuySwaps(params.swapBuy0, params.swapBuy0)
        validateRewardSwaps(params.swapReward0, params.swapReward1)
    {
        _restake({
            tokenId: params.tokenId,
            deadline: params.deadline,
            swapReward0: params.swapReward0,
            swapReward1: params.swapReward1,
            restakeAmount0Min: params.restakeAmount0Min,
            restakeAmount1Min: params.restakeAmount1Min
        });
        _receiveInputToken(params.swapBuy0.path[0], params.amount);
        _buyLiquidityTokensForInputToken({
            amount: params.amount,
            swapBuy0: params.swapBuy0,
            swapBuy1: params.swapBuy1,
            deadline: params.deadline
        });
        (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        ) = _increaseLiquidityNFT({
            tokenId: params.tokenId,
            amount0Min: params.amount0Min,
            amount1Min: params.amount1Min,
            deadline: params.deadline
        });
        emit DepositMore({
            sender: msg.sender,
            payToken: params.swapBuy0.path[0],
            payTokenAmount: params.amount,
            positionTokenId: params.tokenId,
            liquidityAmount: liquidity,
            token0Amount: amount0,
            token1Amount: amount1
        });
        _returnRemainder(params.swapBuy0.path[0]);
    }

    function restake(
        uint256 tokenId,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint256 restakeAmount0Min,
        uint256 restakeAmount1Min,
        uint deadline
    ) external onlyActiveRDNOwner(msg.sender) validateRewardSwaps(swapReward0, swapReward1) {
        _restake({
            tokenId: tokenId,
            deadline: deadline,
            swapReward0: swapReward0,
            swapReward1: swapReward1,
            restakeAmount0Min: restakeAmount0Min,
            restakeAmount1Min: restakeAmount1Min
        });
    }

    function _restake(
        uint256 tokenId,
        uint deadline,
        Swap memory swapReward0,
        Swap memory swapReward1,
        uint256 restakeAmount0Min,
        uint256 restakeAmount1Min
    ) internal {
        uint256 rewardAmount = masterchefV3.harvest({
            _tokenId: tokenId,
            _to: address(this)
        });
        if (rewardAmount == 0) {
            emit RestakeNothing({
                sender: msg.sender,
                tokenId: tokenId
            });
            return;
        }
        totalEarned += rewardAmount;

        _buyLiquidityTokensForInputToken({
            amount: rewardAmount,
            swapBuy0: swapReward0,
            swapBuy1: swapReward1,
            deadline: deadline
        });
        (uint128 liquidity, uint256 amount0, uint256 amount1) = _increaseLiquidityNFT({
            tokenId: tokenId,
            amount0Min: restakeAmount0Min,
            amount1Min: restakeAmount1Min,
            deadline: deadline
        });

        emit Restake({
            sender: msg.sender,
            tokenId: tokenId,
            rewardAmount: rewardAmount,
            liquidity: liquidity,
            amount0: amount0,
            amount1: amount1
        });

        _returnRemainder(swapReward0.path[0]);
    }

    struct DecreaseDepositParams {
        uint256 tokenId;
        uint128 liquidity;
        Swap swapSell0;
        Swap swapSell1;
        Swap swapReward0;
        Swap swapReward1;
        uint256 deadline;
        uint256 restakeAmount0Min;
        uint256 restakeAmount1Min;
        uint256 decreaseLPAmount0Min;
        uint256 decreaseLPAmount1Min;
    }

    function decreaseDeposit(DecreaseDepositParams memory params)
        external
        onlyActiveRDNOwner(msg.sender)
        validateSellSwaps(params.swapSell0, params.swapSell1)
        validateRewardSwaps(params.swapReward0, params.swapReward1)
    {
        _restake({
            tokenId: params.tokenId,
            deadline: params.deadline,
            swapReward0: params.swapReward0,
            swapReward1: params.swapReward1,
            restakeAmount0Min: params.restakeAmount0Min,
            restakeAmount1Min: params.restakeAmount1Min
        });

        (uint256 amount0, uint256 amount1) = _decreaseLiquidityNFT({
            tokenId: params.tokenId,
            liquidity: params.liquidity,
            amount0Min: params.decreaseLPAmount0Min,
            amount1Min: params.decreaseLPAmount1Min,
            deadline: params.deadline
        });

        _sellLiquidityTokensForTargetToken(amount0, amount1, params.swapSell0, params.swapSell1, params.deadline);
        address targetToken = params.swapSell0.path[params.swapSell0.path.length-1];
        uint256 targetTokenAmount = IERC20(targetToken).balanceOf(address(this));

        emit DecreaseDeposit({
            sender: msg.sender,
            tokenId: params.tokenId,
            liquidity: params.liquidity,
            amount0: amount0,
            amount1: amount1,
            targetToken: targetToken,
            targetTokenAmount: targetTokenAmount
        });
    }

    struct WithdrawEntireDepositParams {
        uint256 tokenId;
        Swap swapSell0;
        Swap swapSell1;
        Swap swapRewardToTargetToken;
        uint256 deadline;
        uint256 amount0Min;
        uint256 amount1Min;
    }

    function withdrawEntireDeposit(WithdrawEntireDepositParams calldata params)
        external
        onlyActiveRDNOwner(msg.sender)
        validateSellSwaps(params.swapSell0, params.swapSell1)
        nonReentrant
    {
        require(params.swapRewardToTargetToken.path.length > 0, "empty swapRewardToTargetToken");
        require(params.swapRewardToTargetToken.path[0] == address(rewardToken), "swapRewardToTargetToken start token not equal to rewardToken");
        require(params.swapRewardToTargetToken.path[params.swapRewardToTargetToken.path.length-1] == params.swapSell0.path[params.swapSell0.path.length-1], "swapRewardToTargetToken end token not equal to targetToken");

        // note: restake is not needed since we convert reward to target token

        (uint256 cakeAmount) = masterchefV3.withdraw(params.tokenId, address(this));
        _swap({
            amount: cakeAmount,
            outMin: params.swapRewardToTargetToken.outMin,
            path: params.swapRewardToTargetToken.path,
            deadline: params.deadline
        });

        (
            /*uint96 nonce*/,
            /*address operator*/,
            /*address token0*/,
            /*address token1*/,
            /*uint24 fee*/,
            /*int24 tickLower*/,
            /*int24 tickUpper*/,
            uint128 liquidity,
            /*uint256 feeGrowthInside0LastX128*/,
            /*uint256 feeGrowthInside1LastX128*/,
            /*uint128 tokensOwed0*/,
            /*uint128 tokensOwed1*/
        ) = v3PositionManager.positions(params.tokenId);
        (uint256 amount0, uint256 amount1) = _decreaseLiquidityNFT({
            tokenId: params.tokenId,
            liquidity: liquidity,
            amount0Min: params.amount0Min,
            amount1Min: params.amount1Min,
            deadline: params.deadline
        });
        v3PositionManager.burn(params.tokenId);

        _sellLiquidityTokensForTargetToken(amount0, amount1, params.swapSell0, params.swapSell1, params.deadline);
        address targetToken = params.swapSell0.path[params.swapSell0.path.length-1];
        uint256 targetTokenAmount = _withdrawToken(targetToken, msg.sender);

        emit WithdrawEntireDeposit({
            sender: msg.sender,
            tokenId: params.tokenId,
            liquidity: liquidity,
            amount0: amount0,
            amount1: amount1,
            targetToken: targetToken,
            targetTokenAmount: targetTokenAmount
        });

        // return remainder is not needed here since we withdraw the entire deposit
    }


    function callAny(address payable _addr, bytes memory _data) external payable onlyRDNOwner(msg.sender) returns(bool success, bytes memory data){
        (success, data) = _addr.call{value: msg.value}(_data);
    }

    // View methods

    // todo
//    function info() external view returns (uint, address, uint, uint, uint) {
//        address _pool = masterchefV3; // gas savings
//        uint _poolIndex = poolIndex; //gas savings
//
//        uint reward = IMasterChef2(_pool).pendingCake(_poolIndex, address(this));
//        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));
//        uint staking = userInfo.amount;
//
//        return (poolIndex, stakingToken, reward, staking, totalEarned+reward);
//    }

    // Swap utils
    
    function _swap(
        uint amount,
        uint outMin,
        address[] memory path,
        uint deadline
    ) internal {
        if (path[0] == path[path.length - 1]) {
            return;
        }
        IUniswapV2Router(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amount,
            outMin,
            path,
            address(this),
            deadline
        );
    }
    
    function _buyLiquidityTokensForInputToken(
        uint amount,
        Swap memory swapBuy0,
        Swap memory swapBuy1,
        uint deadline
    ) internal {
        // swap input tokens
        _approve(IERC20(swapBuy0.path[0]), address(router), amount);
        uint amount0In = amount / 2;
        _swap(amount0In, swapBuy0.outMin, swapBuy0.path, deadline);
        uint amount1In = amount - amount0In;
        _swap(amount1In, swapBuy1.outMin, swapBuy1.path, deadline);
    }
    
    function _sellLiquidityTokensForTargetToken(
        uint amount0,
        uint amount1,
        Swap memory swap0,
        Swap memory swap1,
        uint deadline
    ) internal {
        // swap from tokens
        _approve(IERC20(token0), address(router), amount0);
        _approve(IERC20(token1), address(router), amount1);
        _swap(amount0, swap0.outMin, swap0.path, deadline);
        _swap(amount1, swap1.outMin, swap1.path, deadline);
    }
    
    // LP NFT utils

    struct MintLiquidityNFTParams {
        address token0;
        address token1;
        uint256 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    function _mintLiquidityNFT(
        MintLiquidityNFTParams memory params
    ) internal returns(uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1) {
        INonfungiblePositionManager.MintParams memory _mintParams = INonfungiblePositionManager.MintParams({
            token0: params.token0,
            token1: params.token1,
            fee: poolFee,
            tickLower: params.tickLower,
            tickUpper: params.tickUpper,
            amount0Desired: params.amount0Desired,
            amount1Desired: params.amount1Desired,
            amount0Min: params.amount0Min,
            amount1Min: params.amount1Min,
            recipient: address(this),
            deadline: params.deadline
        });
        IERC20(params.token0).safeApprove(address(v3PositionManager), params.amount0Desired);
        IERC20(params.token1).safeApprove(address(v3PositionManager), params.amount1Desired);
        (
            uint256 tokenId,  // The ID of the token that represents the minted position
            uint128 liquidity,  // The amount of liquidity for this position
            uint256 amount0,
            uint256 amount1
        ) = v3PositionManager.mint(_mintParams);
        return (tokenId, liquidity, amount0, amount1);
    }

    function _increaseLiquidityNFT(
        uint256 tokenId,
        uint256 amount0Min,
        uint256 amount1Min,
        uint256 deadline
    ) internal returns(uint128 liquidity, uint256 amount0, uint256 amount1) {
        uint amountIn0 = IERC20(token0).balanceOf(address(this));
        uint amountIn1 = IERC20(token1).balanceOf(address(this));
        _approve(IERC20(token0), address(router), amountIn0);
        _approve(IERC20(token1), address(router), amountIn1);
        INonfungiblePositionManagerStruct.IncreaseLiquidityParams memory _params = INonfungiblePositionManagerStruct.IncreaseLiquidityParams({
            tokenId: tokenId,
            amount0Desired: amountIn0,
            amount1Desired: amountIn1,
            amount0Min: amount0Min,
            amount1Min: amount1Min,
            deadline: deadline
        });
        (liquidity, amount0, amount1) = masterchefV3.increaseLiquidity(_params);
    }

    function _decreaseLiquidityNFT(
        uint128 liquidity,
        uint256 tokenId,
        uint256 amount0Min,
        uint256 amount1Min,
        uint256 deadline
    ) internal returns(uint256 amount0, uint256 amount1) {
        INonfungiblePositionManagerStruct.DecreaseLiquidityParams memory _params = INonfungiblePositionManagerStruct.DecreaseLiquidityParams({
            tokenId: tokenId,
            liquidity: liquidity,
            amount0Min: amount0Min,
            amount1Min: amount1Min,
            deadline: deadline
        });
        (amount0, amount1) = masterchefV3.decreaseLiquidity(_params);
    }

    // ERC20 utils

    function _withdrawToken(address token, address to) internal returns(uint256 tokenAmount) {
        if (token == address(wrapper)) {
            tokenAmount = wrapper.balanceOf(address(this));
            wrapper.withdraw(tokenAmount);
            tokenAmount = address(this).balance;
            (bool sentRecipient, ) = payable(to).call{value: tokenAmount}("");
            require(sentRecipient, "transfer BNB to recipient failed");
        } else {
            tokenAmount = IERC20(token).balanceOf(address(this));
            IERC20(token).safeTransfer(to, tokenAmount);
        }
        emit WithdrawToken({
            sender: msg.sender,
            token: token,
            to: to,
            amount: tokenAmount
        });
    }

    function _receiveInputToken(address _token, uint256 _amount) internal returns(uint256) {
        require(_token != address(0), "use weth to handle native token");
        if (msg.value > 0) {
            require(_token == address(wrapper), "start token must be weth");
            require(_amount == msg.value, "wrong amount");  // avoid any unclear situations
            wrapper.deposit{value: _amount}();
        } else {
            IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
            _amount = IERC20(_token).balanceOf(address(this));  // protection against feeOnTransfer tokens
        }
        return _amount;
    }
    
    function _returnRemainder(address token3) internal {
        address[3] memory tokens = [
            token0,
            token1,
            token3
        ];
        address target = IRDNRegistry(registry).getUserAddress(ownerId);

        for (uint256 i = 0; i < tokens.length; i++) {
            address token = tokens[i];
            uint256 tokenAmount = _withdrawToken(token, target);
            emit RemainderReturned(token, tokenAmount, target);
        }
    }
    
    function _approve(
        IERC20 token,
        address spender,
        uint amount
    ) internal {
        if (token.allowance(address(this), spender) != 0) {  // todo is it really needed?
            token.safeApprove(spender, 0);
        }
        token.safeApprove(spender, amount);
    }
}

// File: src/interfaces/IBEP20.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IBEP20 {
    /**
     * @dev Returns the amount of tokens in existence.
   */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the token decimals.
   */
    function decimals() external view returns (uint8);

    /**
     * @dev Returns the token symbol.
   */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the token name.
   */
    function name() external view returns (string memory);

    /**
     * @dev Returns the bep token owner.
   */
    function getOwner() external view returns (address);

    /**
     * @dev Returns the amount of tokens owned by `account`.
   */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
   * allowed to spend on behalf of `owner` through {transferFrom}. This is
   * zero by default.
   *
   * This value changes when {approve} or {transferFrom} are called.
   */
    function allowance(address _owner, address spender)
    external
    view
    returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * IMPORTANT: Beware that changing an allowance with this method brings the risk
   * that someone may use both the old and the new allowance by unfortunate
   * transaction ordering. One possible solution to mitigate this race
   * condition is to first reduce the spender's allowance to 0 and set the
   * desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   *
   * Emits an {Approval} event.
   */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
   * allowance mechanism. `amount` is then deducted from the caller's
   * allowance.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
   * another (`to`).
   *
   * Note that `value` may be zero.
   */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
   * a call to {approve}. `value` is the new allowance.
   */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: src/interfaces/IERC20ext.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20ext {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);

    function mint(address to, uint256 amount) external;

    function transferOwnership(address to) external;
}


// File: src/interfaces/IERC721Permit.sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;

import '@openzeppelin/contracts/token/ERC721/IERC721.sol';

/// @title ERC721 with permit
/// @notice Extension to ERC721 that includes a permit function for signature based approvals
interface IERC721Permit is IERC721 {
    /// @notice The permit typehash used in the permit signature
    /// @return The typehash for the permit
    function PERMIT_TYPEHASH() external pure returns (bytes32);

    /// @notice The domain separator used in the permit signature
    /// @return The domain seperator used in encoding of permit signature
    function DOMAIN_SEPARATOR() external view returns (bytes32);

    /// @notice Approve of a specific token ID for spending by spender via signature
    /// @param spender The account that is being approved
    /// @param tokenId The ID of the token that is being approved for spending
    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work
    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
    function permit(
        address spender,
        uint256 tokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;
}


// File: src/interfaces/IFarmBooster.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

interface IFarmBooster {
    function getUserMultiplier(uint256 _tokenId) external view returns (uint256);

    function whiteList(uint256 _pid) external view returns (bool);

    function updatePositionBoostMultiplier(uint256 _tokenId) external returns (uint256 _multiplier);

    function removeBoostMultiplier(address _user, uint256 _tokenId, uint256 _pid) external;
}


// File: src/interfaces/ILMPool.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

interface ILMPool {
    function updatePosition(int24 tickLower, int24 tickUpper, int128 liquidityDelta) external;

    function getRewardGrowthInside(
        int24 tickLower,
        int24 tickUpper
    ) external view returns (uint256 rewardGrowthInsideX128);

    function accumulateReward(uint32 currTimestamp) external;
}


// File: src/interfaces/ILMPoolDeployer.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./IPancakeV3Pool.sol";
import "./ILMPool.sol";

interface ILMPoolDeployer {
    function deploy(IPancakeV3Pool pool) external returns (ILMPool lmPool);
}


// File: src/interfaces/IMasterChef.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IMasterChef {
    function deposit(uint256 _pid, uint256 _amount) external;

    function withdraw(uint256 _pid, uint256 _amount) external;

    function enterStaking(uint256 _amount) external;

    function leaveStaking(uint256 _amount) external;

    function pendingCake(uint256 _pid, address _user) external view returns (uint256);

    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);

    function emergencyWithdraw(uint256 _pid) external;
}

// File: src/interfaces/IMasterChefv2.sol
pragma solidity ^0.8.0;

// SPDX-License-Identifier: UNLICENSED

import "../interfaces/IBEP20.sol";

interface IMasterChefv2 {

    struct PoolInfo {
        uint256 accCakePerShare;
        uint256 lastRewardBlock;
        uint256 allocPoint;
        uint256 totalBoostedShare;
        bool isRegular;
    }

    struct UserInfo {
        uint256 amount;
        uint256 rewardDebt;
        uint256 boostMultiplier;
    }

    function init(IBEP20 dummyToken) external;

    function poolLength() external view returns (uint256 pools);

    function add(uint256 _allocPoint, IBEP20 _lpToken, bool _isRegular, bool _withUpdate) external;

    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;

    function pendingCake(uint256 _pid, address _user) external view returns (uint256);

    function massUpdatePools() external;

    function cakePerBlock(bool _isRegular) external view returns (uint256 amount);

    function deposit(uint256 _pid, uint256 _amount) external;

    function withdraw(uint256 _pid, uint256 _amount) external;

    function lptoken(uint256 _pid) external returns(IBEP20);

    function poolInfo(uint256 _pid) external returns (PoolInfo memory);

    function userInfo(uint256 _pid, address _userAddress) external returns (UserInfo memory);

}

// File: src/interfaces/IMasterChefV3.sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.10;

import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./INonfungiblePositionManagerStruct.sol";
import "./IPancakeV3Pool.sol";
import "./ILMPoolDeployer.sol";
import "./IFarmBooster.sol";

interface IMasterChefV3 is IERC721Enumerable, INonfungiblePositionManagerStruct {
    struct PoolInfo {
        uint256 allocPoint;
        // V3 pool address
        IPancakeV3Pool v3Pool;
        // V3 pool token0 address
        address token0;
        // V3 pool token1 address
        address token1;
        // V3 pool fee
        uint24 fee;
        // total liquidity staking in the pool
        uint256 totalLiquidity;
        // total boost liquidity staking in the pool
        uint256 totalBoostLiquidity;
    }

    struct UserPositionInfo {
        uint128 liquidity;
        uint128 boostLiquidity;
        int24 tickLower;
        int24 tickUpper;
        uint256 rewardGrowthInside;
        uint256 reward;
        address user;
        uint256 pid;
        uint256 boostMultiplier;
    }

    function poolLength() external view returns(uint256);
    /// @notice Info of each MCV3 pool.
    function poolInfo(uint256) external view returns(PoolInfo memory);

    /// @notice userPositionInfos[tokenId] => UserPositionInfo
    /// @dev TokenId is unique, and we can query the pid by tokenId.
    function userPositionInfos(uint256) external view returns(UserPositionInfo memory);

    /// @notice v3PoolPid[token0][token1][fee] => pid
    function v3PoolPid(address, address, uint24) external view returns(uint256);
    /// @notice v3PoolAddressPid[v3PoolAddress] => pid
    function v3PoolAddressPid(address) external view returns(uint256);

    /// @notice Address of CAKE contract.
    function CAKE() external view returns(IERC20);

    /// @notice Address of WETH contract.
    function WETH() external view returns(address);

    /// @notice Address of Receiver contract.
    function receiver() external view returns(address);

    function nonfungiblePositionManager() external view returns(address);

    /// @notice Address of liquidity mining pool deployer contract.
    function LMPoolDeployer() external view returns(ILMPoolDeployer);

    /// @notice Address of farm booster contract.
    function FARM_BOOSTER() external view returns(IFarmBooster);

    /// @notice Only use for emergency situations.
    function emergency() external view returns(bool);

    /// @notice Total allocation points. Must be the sum of all pools' allocation points.
    function totalAllocPoint() external view returns(uint256);

    function latestPeriodNumber() external view returns(uint256);
    function latestPeriodStartTime() external view returns(uint256);
    function latestPeriodEndTime() external view returns(uint256);
    function latestPeriodCakePerSecond() external view returns(uint256);

    /// @notice Address of the operator.
    function operatorAddress() external view returns(address);

    /// @notice Default period duration.
    function PERIOD_DURATION() external view returns(uint256);
    function MAX_DURATION() external view returns(uint256);
    function MIN_DURATION() external view returns(uint256);
    function PRECISION() external view returns(uint256);

    /// @notice Basic boost factor, none boosted user's boost factor
    function BOOST_PRECISION() external view returns(uint256);
    /// @notice Hard limit for maxmium boost factor, it must greater than BOOST_PRECISION
    function MAX_BOOST_PRECISION() external view returns(uint256);

    /// @notice Record the cake amount belong to MasterChefV3.
    function cakeAmountBelongToMC() external view returns(uint256);

    error ZeroAddress();
    error NotOwnerOrOperator();
    error NoBalance();
    error NotPancakeNFT();
    error InvalidNFT();
    error NotOwner();
    error NoLiquidity();
    error InvalidPeriodDuration();
    error NoLMPool();
    error InvalidPid();
    error DuplicatedPool(uint256 pid);
    error NotEmpty();
    error WrongReceiver();
    error InconsistentAmount();
    error InsufficientAmount();

    event AddPool(uint256 indexed pid, uint256 allocPoint, IPancakeV3Pool indexed v3Pool, ILMPool indexed lmPool);
    event SetPool(uint256 indexed pid, uint256 allocPoint);
    event Deposit(
        address indexed from,
        uint256 indexed pid,
        uint256 indexed tokenId,
        uint256 liquidity,
        int24 tickLower,
        int24 tickUpper
    );
    event Withdraw(address indexed from, address to, uint256 indexed pid, uint256 indexed tokenId);
    event UpdateLiquidity(
        address indexed from,
        uint256 indexed pid,
        uint256 indexed tokenId,
        int128 liquidity,
        int24 tickLower,
        int24 tickUpper
    );
    event NewOperatorAddress(address operator);
    event NewLMPoolDeployerAddress(address deployer);
    event NewReceiver(address receiver);
    event NewPeriodDuration(uint256 periodDuration);
    event Harvest(address indexed sender, address to, uint256 indexed pid, uint256 indexed tokenId, uint256 reward);
    event NewUpkeepPeriod(
        uint256 indexed periodNumber,
        uint256 startTime,
        uint256 endTime,
        uint256 cakePerSecond,
        uint256 cakeAmount
    );
    event UpdateUpkeepPeriod(
        uint256 indexed periodNumber,
        uint256 oldEndTime,
        uint256 newEndTime,
        uint256 remainingCake
    );
    event UpdateFarmBoostContract(address indexed farmBoostContract);
    event SetEmergency(bool emergency);

    /// @notice Returns the cake per second , period end time.
    /// @param _pid The pool pid.
    /// @return cakePerSecond Cake reward per second.
    /// @return endTime Period end time.
    function getLatestPeriodInfoByPid(uint256 _pid) external view returns (uint256 cakePerSecond, uint256 endTime);

    /// @notice Returns the cake per second , period end time. This is for liquidity mining pool.
    /// @param _v3Pool Address of the V3 pool.
    /// @return cakePerSecond Cake reward per second.
    /// @return endTime Period end time.
    function getLatestPeriodInfo(address _v3Pool) external view returns (uint256 cakePerSecond, uint256 endTime);

    /// @notice View function for checking pending CAKE rewards.
    /// @dev The pending cake amount is based on the last state in LMPool. The actual amount will happen whenever liquidity changes or harvest.
    /// @param _tokenId Token Id of NFT.
    /// @return reward Pending reward.
    function pendingCake(uint256 _tokenId) external view returns (uint256 reward);

    struct DepositCache {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint128 liquidity;
    }

    /// @notice Upon receiving a ERC721
    function onERC721Received(
        address,
        address _from,
        uint256 _tokenId,
        bytes calldata
    ) external returns (bytes4);

    /// @notice harvest cake from pool.
    /// @param _tokenId Token Id of NFT.
    /// @param _to Address to.
    /// @return reward Cake reward.
    function harvest(uint256 _tokenId, address _to) external returns (uint256 reward);


    /// @notice Withdraw LP tokens from pool.
    /// @param _tokenId Token Id of NFT to deposit.
    /// @param _to Address to which NFT token to withdraw.
    /// @return reward Cake reward.
    function withdraw(uint256 _tokenId, address _to) external returns (uint256 reward);

    /// @notice Update liquidity for the NFT position.
    /// @param _tokenId Token Id of NFT to update.
    function updateLiquidity(uint256 _tokenId) external;

    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
    /// @param params tokenId The ID of the token for which liquidity is being increased,
    /// amount0Desired The desired amount of token0 to be spent,
    /// amount1Desired The desired amount of token1 to be spent,
    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return liquidity The new liquidity amount as a result of the increase
    /// @return amount0 The amount of token0 to acheive resulting liquidity
    /// @return amount1 The amount of token1 to acheive resulting liquidity
    function increaseLiquidity(
        IncreaseLiquidityParams memory params
    ) external payable returns (uint128 liquidity, uint256 amount0, uint256 amount1);

    /// @notice Decreases the amount of liquidity in a position and accounts it to the position
    /// @param params tokenId The ID of the token for which liquidity is being decreased,
    /// amount The amount by which liquidity will be decreased,
    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return amount0 The amount of token0 accounted to the position's tokens owed
    /// @return amount1 The amount of token1 accounted to the position's tokens owed
    function decreaseLiquidity(
        DecreaseLiquidityParams memory params
    ) external returns (uint256 amount0, uint256 amount1);

    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
    /// @param params tokenId The ID of the NFT for which tokens are being collected,
    /// recipient The account that should receive the tokens,
    /// @dev Warning!!! Please make sure to use multicall to call unwrapWETH9 or sweepToken when set recipient address(0), or you will lose your funds.
    /// amount0Max The maximum amount of token0 to collect,
    /// amount1Max The maximum amount of token1 to collect
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(CollectParams memory params) external returns (uint256 amount0, uint256 amount1);

    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient, then refund.
    /// @param params CollectParams.
    /// @param to Refund recipent.
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collectTo(
        CollectParams memory params,
        address to
    ) external returns (uint256 amount0, uint256 amount1);

    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
    /// must be collected first.
    /// @param _tokenId The ID of the token that is being burned
    function burn(uint256 _tokenId) external;
}


// File: src/interfaces/INonfungiblePositionManager.sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.10;
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
import "./IERC721Permit.sol";
import "./INonfungiblePositionManagerStruct.sol";
import "./IPoolInitializer.sol";
import "./IPeripheryPayments.sol";
import "./IPeripheryImmutableState.sol";

/// @title Non-fungible token for positions
/// @notice Wraps PancakeSwap V3 positions in a non-fungible token interface which allows for them to be transferred
/// and authorized.
interface INonfungiblePositionManager is
    IPoolInitializer,
    IPeripheryPayments,
    IPeripheryImmutableState,
    IERC721Metadata,
    IERC721Enumerable,
    IERC721Permit
{
    /// @notice Emitted when liquidity is increased for a position NFT
    /// @dev Also emitted when a token is minted
    /// @param tokenId The ID of the token for which liquidity was increased
    /// @param liquidity The amount by which liquidity for the NFT position was increased
    /// @param amount0 The amount of token0 that was paid for the increase in liquidity
    /// @param amount1 The amount of token1 that was paid for the increase in liquidity
    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when liquidity is decreased for a position NFT
    /// @param tokenId The ID of the token for which liquidity was decreased
    /// @param liquidity The amount by which liquidity for the NFT position was decreased
    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity
    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity
    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when tokens are collected for a position NFT
    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior
    /// @param tokenId The ID of the token for which underlying tokens were collected
    /// @param recipient The address of the account that received the collected tokens
    /// @param amount0 The amount of token0 owed to the position that was collected
    /// @param amount1 The amount of token1 owed to the position that was collected
    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);

    /// @notice Returns the position information associated with a given token ID.
    /// @dev Throws if the token ID is not valid.
    /// @param tokenId The ID of the token that represents the position
    /// @return nonce The nonce for permits
    /// @return operator The address that is approved for spending
    /// @return token0 The address of the token0 for a specific pool
    /// @return token1 The address of the token1 for a specific pool
    /// @return fee The fee associated with the pool
    /// @return tickLower The lower end of the tick range for the position
    /// @return tickUpper The higher end of the tick range for the position
    /// @return liquidity The liquidity of the position
    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
    function positions(uint256 tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }

    /// @notice Creates a new position wrapped in a NFT
    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
    /// a method does not exist, i.e. the pool is assumed to be initialized.
    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
    /// @return tokenId The ID of the token that represents the minted position
    /// @return liquidity The amount of liquidity for this position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mint(MintParams calldata params)
        external
        payable
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
    /// @param params tokenId The ID of the token for which liquidity is being increased,
    /// amount0Desired The desired amount of token0 to be spent,
    /// amount1Desired The desired amount of token1 to be spent,
    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return liquidity The new liquidity amount as a result of the increase
    /// @return amount0 The amount of token0 to acheive resulting liquidity
    /// @return amount1 The amount of token1 to acheive resulting liquidity
    function increaseLiquidity(IncreaseLiquidityParams calldata params)
        external
        payable
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Decreases the amount of liquidity in a position and accounts it to the position
    /// @param params tokenId The ID of the token for which liquidity is being decreased,
    /// amount The amount by which liquidity will be decreased,
    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return amount0 The amount of token0 accounted to the position's tokens owed
    /// @return amount1 The amount of token1 accounted to the position's tokens owed
    function decreaseLiquidity(DecreaseLiquidityParams calldata params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }

    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
    /// @param params tokenId The ID of the NFT for which tokens are being collected,
    /// recipient The account that should receive the tokens,
    /// amount0Max The maximum amount of token0 to collect,
    /// amount1Max The maximum amount of token1 to collect
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);

    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
    /// must be collected first.
    /// @param tokenId The ID of the token that is being burned
    function burn(uint256 tokenId) external payable;
}



// File: src/interfaces/INonfungiblePositionManagerStruct.sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.10;

interface INonfungiblePositionManagerStruct {
    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }
}


// File: src/interfaces/IPancakeFactory.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IPancakeFactory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;

    function INIT_CODE_PAIR_HASH() external view returns (bytes32);
}

// File: src/interfaces/IPancakeRouter01.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IPancakeRouter01 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountToken, uint256 amountETH);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) external pure returns (uint256 amountB);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountIn);

    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);

    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);

    function tPair(address factory, address tokenA, address tokenB) external view returns(address);
}


// File: src/interfaces/IPancakeRouter02.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import "./IPancakeRouter01.sol";

interface IPancakeRouter02 is IPancakeRouter01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}

// File: src/interfaces/IPancakeV3Pool.sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.10;

interface IPancakeV3Pool {
    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function fee() external view returns (uint24);

    function lmPool() external view returns (address);
}


// File: src/interfaces/IPeripheryImmutableState.sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Immutable state
/// @notice Functions that return immutable state of the router
interface IPeripheryImmutableState {
    /// @return Returns the address of the PancakeSwap V3 deployer
    function deployer() external view returns (address);

    /// @return Returns the address of the PancakeSwap V3 factory
    function factory() external view returns (address);

    /// @return Returns the address of WETH9
    function WETH9() external view returns (address);
}


// File: src/interfaces/IPeripheryPayments.sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;

/// @title Periphery Payments
/// @notice Functions to ease deposits and withdrawals of ETH
interface IPeripheryPayments {
    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.
    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.
    /// @param amountMinimum The minimum amount of WETH9 to unwrap
    /// @param recipient The address receiving ETH
    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;

    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`
    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps
    /// that use ether for the input amount. And in PancakeSwap Router, this would be called 
    /// at the very end of swap
    function refundETH() external payable;

    /// @notice Transfers the full amount of a token held by this contract to recipient
    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users
    /// @param token The contract address of the token which will be transferred to `recipient`
    /// @param amountMinimum The minimum amount of token required for a transfer
    /// @param recipient The destination address of the token
    function sweepToken(
        address token,
        uint256 amountMinimum,
        address recipient
    ) external payable;
}


// File: src/interfaces/IPoolInitializer.sol
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;
pragma abicoder v2;

/// @title Creates and initializes V3 Pools
/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that
/// require the pool to exist.
interface IPoolInitializer {
    /// @notice Creates a new pool if it does not exist, then initializes if not initialized
    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool
    /// @param token0 The contract address of token0 of the pool
    /// @param token1 The contract address of token1 of the pool
    /// @param fee The fee amount of the v3 pool for the specified token pair
    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value
    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary
    function createAndInitializePoolIfNecessary(
        address token0,
        address token1,
        uint24 fee,
        uint160 sqrtPriceX96
    ) external payable returns (address pool);
}


// File: src/interfaces/IWETH.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IWETH {
    function deposit() external payable;

    function transfer(address to, uint256 value) external returns (bool);

    function withdraw(uint256) external;
}

// File: src/MOSTToken.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts

// ERC20 Token Contract based on OpenZeppelin
//
// ## Minting:
// Mintable. Mint can be stopped forever by stopMint().
//
// ## AccessControl:
// DEFAULT_ADMIN_ROLE can grantRole to any other address.
// MINTER_ROLE - can mint
// PAUSER_ROLE - can pause transfers
// MINTSTOPPER_ROLE - can stop minting FOREVER
// Any role can be revoked from any address by DEFAULT_ADMIN_ROLE
// All role members can be listed anytime by getRoleMemberCount and getRoleMember
//
// ## Burning:
// tokens can be burnt by tokens holder
//
// ## Pausing:
// All transfers can be paused and unpaused anytime by PAUSER_ROLE
//
// ## Allowance and Approve:
// Default ERC20 allowance, approve, transferFrom 


pragma solidity 0.8.17;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/utils/Context.sol";

contract MOSTToken is Context, AccessControlEnumerable, ERC20, ERC20Burnable, ERC20Pausable {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant MINTSTOPPER_ROLE = keccak256("MINTSTOPPER_ROLE");

    // Mint is Stoppable
    bool public mintStopped = false;

    constructor(string memory name, string memory symbol, uint256 _initialSupply, address _initialHolder, address _admin) ERC20(name, symbol) {
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(MINTER_ROLE, _admin);
        _setupRole(PAUSER_ROLE, _admin);
        _setupRole(MINTSTOPPER_ROLE, _admin);

        _mint(_initialHolder, _initialSupply);
    }

    function mint(address to, uint256 amount) public virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have minter role to mint");
        require(mintStopped != true, "Mint stopped");
        _mint(to, amount);
    }

    function pause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have pauser role to pause");
        _pause();
    }

    function unpause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have pauser role to unpause");
        _unpause();
    }

    function stopMint() public onlyRole(MINTSTOPPER_ROLE) {
        mintStopped = true;
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override(ERC20, ERC20Pausable) {
        super._beforeTokenTransfer(from, to, amount);
    }
}

// File: src/PancakeExchange/interfaces/IERC20.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);
}


// File: src/PancakeExchange/interfaces/IPancakeCallee.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0;

interface IPancakeCallee {
    function pancakeCall(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
}


// File: src/PancakeExchange/interfaces/IPancakeERC20.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0;

interface IPancakeERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}


// File: src/PancakeExchange/interfaces/IPancakeFactory.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0;

interface IPancakeFactory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;

    function INIT_CODE_PAIR_HASH() external view returns (bytes32);
}


// File: src/PancakeExchange/interfaces/IPancakeMigrator.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0;

interface IPancakeMigrator {
    function migrate(
        address token,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external;
}


// File: src/PancakeExchange/interfaces/IPancakePair.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0;

interface IPancakePair {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint256);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );

    function price0CumulativeLast() external view returns (uint256);

    function price1CumulativeLast() external view returns (uint256);

    function kLast() external view returns (uint256);

    function mint(address to) external returns (uint256 liquidity);

    function burn(address to) external returns (uint256 amount0, uint256 amount1);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;

    function initialize(address, address) external;
}


// File: src/PancakeExchange/interfaces/IPancakeRouter01.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.2;

interface IPancakeRouter01 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountToken, uint256 amountETH);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) external pure returns (uint256 amountB);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountIn);

    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);

    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);
}


// File: src/PancakeExchange/interfaces/IPancakeRouter02.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.2;

import "./IPancakeRouter01.sol";

interface IPancakeRouter02 is IPancakeRouter01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}


// File: src/PancakeExchange/interfaces/IWETH.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0;

interface IWETH {
    function deposit() external payable;

    function transfer(address to, uint256 value) external returns (bool);

    function withdraw(uint256) external;
}


// File: src/PancakeExchange/libraries/Babylonian.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

/*
 * @author Uniswap
 * @notice Library from Uniswap
 */
library Babylonian {
    function sqrt(uint256 x) internal pure returns (uint256) {
        if (x == 0) return 0;

        uint256 xx = x;
        uint256 r = 1;
        if (xx >= 0x100000000000000000000000000000000) {
            xx >>= 128;
            r <<= 64;
        }
        if (xx >= 0x10000000000000000) {
            xx >>= 64;
            r <<= 32;
        }
        if (xx >= 0x100000000) {
            xx >>= 32;
            r <<= 16;
        }
        if (xx >= 0x10000) {
            xx >>= 16;
            r <<= 8;
        }
        if (xx >= 0x100) {
            xx >>= 8;
            r <<= 4;
        }
        if (xx >= 0x10) {
            xx >>= 4;
            r <<= 2;
        }
        if (xx >= 0x8) {
            r <<= 1;
        }
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;

        uint256 r1 = x / r;

        return (r < r1 ? r : r1);
    }
}


// File: src/PancakeExchange/PancakeZapV1.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import {IPancakePair} from "./interfaces/IPancakePair.sol";
import {IPancakeRouter02} from "./interfaces/IPancakeRouter02.sol";
import {IWETH} from "./interfaces/IWETH.sol";
import {Babylonian} from "./libraries/Babylonian.sol";

/*
 * @author Inspiration from the work of Zapper and Beefy.
 * Implemented and modified by PancakeSwap teams.
 */
contract PancakeZapV1 is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    // Interface for Wrapped BNB (WBNB)
    IWETH public WBNB;

    // PancakeRouter interface
    IPancakeRouter02 public pancakeRouter;

    // Maximum integer (used for managing allowance)
    uint256 public constant MAX_INT = 2**256 - 1;

    // Minimum amount for a swap (derived from PancakeSwap)
    uint256 public constant MINIMUM_AMOUNT = 1000;

    // Maximum reverse zap ratio (100 --> 1%, 1000 --> 0.1%)
    uint256 public maxZapReverseRatio;

    // Address PancakeRouter
    address private pancakeRouterAddress;

    // Address Wrapped BNB (WBNB)
    address private WBNBAddress;

    // Owner recovers token
    event AdminTokenRecovery(address indexed tokenAddress, uint256 amountTokens);

    // Owner changes the maxZapReverseRatio
    event NewMaxZapReverseRatio(uint256 maxZapReverseRatio);

    // tokenToZap = 0x00 address if BNB
    event ZapIn(
        address indexed tokenToZap,
        address indexed lpToken,
        uint256 tokenAmountIn,
        uint256 lpTokenAmountReceived,
        address indexed user
    );

    // token0ToZap = 0x00 address if BNB
    event ZapInRebalancing(
        address indexed token0ToZap,
        address indexed token1ToZap,
        address lpToken,
        uint256 token0AmountIn,
        uint256 token1AmountIn,
        uint256 lpTokenAmountReceived,
        address indexed user
    );

    // tokenToReceive = 0x00 address if BNB
    event ZapOut(
        address indexed lpToken,
        address indexed tokenToReceive,
        uint256 lpTokenAmount,
        uint256 tokenAmountReceived,
        address indexed user
    );

    /*
     * @notice Fallback for WBNB
     */
    receive() external payable {
        assert(msg.sender == WBNBAddress);
    }

    /*
     * @notice Constructor
     * @param _WBNBAddress: address of the WBNB contract
     * @param _pancakeRouter: address of the PancakeRouter
     * @param _maxZapReverseRatio: maximum zap ratio
     */
    constructor(
        address _WBNBAddress,
        address _pancakeRouter,
        uint256 _maxZapReverseRatio
    ) {
        WBNBAddress = _WBNBAddress;
        WBNB = IWETH(_WBNBAddress);
        pancakeRouterAddress = _pancakeRouter;
        pancakeRouter = IPancakeRouter02(_pancakeRouter);
        maxZapReverseRatio = _maxZapReverseRatio;
    }

    /*
     * @notice Zap BNB in a WBNB pool (e.g. WBNB/token)
     * @param _lpToken: LP token address (e.g. CAKE/BNB)
     * @param _tokenAmountOutMin: minimum token amount (e.g. CAKE) to receive in the intermediary swap (e.g. BNB --> CAKE)
     */
    function zapInBNB(address _lpToken, uint256 _tokenAmountOutMin) external payable nonReentrant {
        WBNB.deposit{value: msg.value}();

        // Call zap function
        uint256 lpTokenAmountTransferred = _zapIn(WBNBAddress, msg.value, _lpToken, _tokenAmountOutMin);

        // Emit event
        emit ZapIn(
            address(0x0000000000000000000000000000000000000000),
            _lpToken,
            msg.value,
            lpTokenAmountTransferred,
            address(msg.sender)
        );
    }

    /*
     * @notice Zap a token in (e.g. token/other token)
     * @param _tokenToZap: token to zap
     * @param _tokenAmountIn: amount of token to swap
     * @param _lpToken: LP token address (e.g. CAKE/BUSD)
     * @param _tokenAmountOutMin: minimum token to receive (e.g. CAKE) in the intermediary swap (e.g. BUSD --> CAKE)
     */
    function zapInToken(
        address _tokenToZap,
        uint256 _tokenAmountIn,
        address _lpToken,
        uint256 _tokenAmountOutMin
    ) external nonReentrant {
        // Transfer tokens to this contract
        IERC20(_tokenToZap).safeTransferFrom(address(msg.sender), address(this), _tokenAmountIn);

        // Call zap function
        uint256 lpTokenAmountTransferred = _zapIn(_tokenToZap, _tokenAmountIn, _lpToken, _tokenAmountOutMin);

        // Emit event
        emit ZapIn(_tokenToZap, _lpToken, _tokenAmountIn, lpTokenAmountTransferred, address(msg.sender));
    }

    /*
     * @notice Zap two tokens in, rebalance them to 50-50, before adding them to LP
     * @param _token0ToZap: address of token0 to zap
     * @param _token1ToZap: address of token1 to zap
     * @param _token0AmountIn: amount of token0 to zap
     * @param _token1AmountIn: amount of token1 to zap
     * @param _lpToken: LP token address (token0/token1)
     * @param _tokenAmountInMax: maximum token amount to sell (in token to sell in the intermediary swap)
     * @param _tokenAmountOutMin: minimum token to receive in the intermediary swap
     * @param _isToken0Sold: whether token0 is expected to be sold (if false, sell token1)
     */
    function zapInTokenRebalancing(
        address _token0ToZap,
        address _token1ToZap,
        uint256 _token0AmountIn,
        uint256 _token1AmountIn,
        address _lpToken,
        uint256 _tokenAmountInMax,
        uint256 _tokenAmountOutMin,
        bool _isToken0Sold
    ) external nonReentrant {
        // Transfer tokens to this contract
        IERC20(_token0ToZap).safeTransferFrom(address(msg.sender), address(this), _token0AmountIn);
        IERC20(_token1ToZap).safeTransferFrom(address(msg.sender), address(this), _token1AmountIn);

        // Call zapIn function
        uint256 lpTokenAmountTransferred = _zapInRebalancing(
            _token0ToZap,
            _token1ToZap,
            _token0AmountIn,
            _token1AmountIn,
            _lpToken,
            _tokenAmountInMax,
            _tokenAmountOutMin,
            _isToken0Sold
        );

        // Emit event
        emit ZapInRebalancing(
            _token0ToZap,
            _token1ToZap,
            _lpToken,
            _token0AmountIn,
            _token1AmountIn,
            lpTokenAmountTransferred,
            address(msg.sender)
        );
    }

    /*
     * @notice Zap 1 token and BNB, rebalance them to 50-50, before adding them to LP
     * @param _token1ToZap: address of token1 to zap
     * @param _token1AmountIn: amount of token1 to zap
     * @param _lpToken: LP token address
     * @param _tokenAmountInMax: maximum token amount to sell (in token to sell in the intermediary swap)
     * @param _tokenAmountOutMin: minimum token to receive in the intermediary swap
     * @param _isToken0Sold: whether token0 is expected to be sold (if false, sell token1)
     */
    function zapInBNBRebalancing(
        address _token1ToZap,
        uint256 _token1AmountIn,
        address _lpToken,
        uint256 _tokenAmountInMax,
        uint256 _tokenAmountOutMin,
        bool _isToken0Sold
    ) external payable nonReentrant {
        WBNB.deposit{value: msg.value}();

        IERC20(_token1ToZap).safeTransferFrom(address(msg.sender), address(this), _token1AmountIn);

        // Call zapIn function
        uint256 lpTokenAmountTransferred = _zapInRebalancing(
            WBNBAddress,
            _token1ToZap,
            msg.value,
            _token1AmountIn,
            _lpToken,
            _tokenAmountInMax,
            _tokenAmountOutMin,
            _isToken0Sold
        );

        // Emit event
        emit ZapInRebalancing(
            address(0x0000000000000000000000000000000000000000),
            _token1ToZap,
            _lpToken,
            msg.value,
            _token1AmountIn,
            lpTokenAmountTransferred,
            address(msg.sender)
        );
    }

    /*
     * @notice Zap a LP token out to receive BNB
     * @param _lpToken: LP token address (e.g. CAKE/WBNB)
     * @param _lpTokenAmount: amount of LP tokens to zap out
     * @param _tokenAmountOutMin: minimum amount to receive (in BNB/WBNB) in the intermediary swap (e.g. CAKE --> BNB)
     */
    function zapOutBNB(
        address _lpToken,
        uint256 _lpTokenAmount,
        uint256 _tokenAmountOutMin
    ) external nonReentrant {
        // Transfer LP token to this address
        IERC20(_lpToken).safeTransferFrom(address(msg.sender), address(_lpToken), _lpTokenAmount);

        // Call zapOut
        uint256 tokenAmountToTransfer = _zapOut(_lpToken, WBNBAddress, _tokenAmountOutMin);

        // Unwrap BNB
        WBNB.withdraw(tokenAmountToTransfer);

        // Transfer BNB to the msg.sender
        (bool success, ) = msg.sender.call{value: tokenAmountToTransfer}(new bytes(0));
        require(success, "BNB: transfer fail");

        // Emit event
        emit ZapOut(
            _lpToken,
            address(0x0000000000000000000000000000000000000000),
            _lpTokenAmount,
            tokenAmountToTransfer,
            address(msg.sender)
        );
    }

    /*
     * @notice Zap a LP token out (to receive a token)
     * @param _lpToken: LP token address (e.g. CAKE/BUSD)
     * @param _tokenToReceive: one of the 2 tokens from the LP (e.g. CAKE or BUSD)
     * @param _lpTokenAmount: amount of LP tokens to zap out
     * @param _tokenAmountOutMin: minimum token to receive (e.g. CAKE) in the intermediary swap (e.g. BUSD --> CAKE)
     */
    function zapOutToken(
        address _lpToken,
        address _tokenToReceive,
        uint256 _lpTokenAmount,
        uint256 _tokenAmountOutMin
    ) external nonReentrant {
        // Transfer LP token to this address
        IERC20(_lpToken).safeTransferFrom(address(msg.sender), address(_lpToken), _lpTokenAmount);

        uint256 tokenAmountToTransfer = _zapOut(_lpToken, _tokenToReceive, _tokenAmountOutMin);

        IERC20(_tokenToReceive).safeTransfer(address(msg.sender), tokenAmountToTransfer);

        emit ZapOut(_lpToken, _tokenToReceive, _lpTokenAmount, tokenAmountToTransfer, msg.sender);
    }

    /**
     * @notice It allows the owner to change the risk parameter for quantities
     * @param _maxZapInverseRatio: new inverse ratio
     * @dev This function is only callable by owner.
     */
    function updateMaxZapInverseRatio(uint256 _maxZapInverseRatio) external onlyOwner {
        maxZapReverseRatio = _maxZapInverseRatio;
        emit NewMaxZapReverseRatio(_maxZapInverseRatio);
    }

    /**
     * @notice It allows the owner to recover wrong tokens sent to the contract
     * @param _tokenAddress: the address of the token to withdraw (18 decimals)
     * @param _tokenAmount: the number of token amount to withdraw
     * @dev This function is only callable by owner.
     */
    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);
        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);
    }

    /*
     * @notice View the details for single zap
     * @dev Use WBNB for _tokenToZap (if BNB is the input)
     * @param _tokenToZap: address of the token to zap
     * @param _tokenAmountIn: amount of token to zap inputed
     * @param _lpToken: address of the LP token
     * @return swapAmountIn: amount that is expected to get swapped in intermediary swap
     * @return swapAmountOut: amount that is expected to get received in intermediary swap
     * @return swapTokenOut: token address of the token that is used in the intermediary swap
     */
    function estimateZapInSwap(
        address _tokenToZap,
        uint256 _tokenAmountIn,
        address _lpToken
    )
        external
        view
        returns (
            uint256 swapAmountIn,
            uint256 swapAmountOut,
            address swapTokenOut
        )
    {
        address token0 = IPancakePair(_lpToken).token0();
        address token1 = IPancakePair(_lpToken).token1();

        require(_tokenToZap == token0 || _tokenToZap == token1, "Zap: Wrong tokens");

        // Convert to uint256 (from uint112)
        (uint256 reserveA, uint256 reserveB, ) = IPancakePair(_lpToken).getReserves();

        if (token0 == _tokenToZap) {
            swapTokenOut = token1;
            swapAmountIn = _calculateAmountToSwap(_tokenAmountIn, reserveA, reserveB);
            swapAmountOut = pancakeRouter.getAmountOut(swapAmountIn, reserveA, reserveB);
        } else {
            swapTokenOut = token0;
            swapAmountIn = _calculateAmountToSwap(_tokenAmountIn, reserveB, reserveA);
            swapAmountOut = pancakeRouter.getAmountOut(swapAmountIn, reserveB, reserveA);
        }

        return (swapAmountIn, swapAmountOut, swapTokenOut);
    }

    /*
     * @notice View the details for a rebalancing zap
     * @dev Use WBNB for _token0ToZap (if BNB is the input)
     * @param _token0ToZap: address of the token0 to zap
     * @param _token1ToZap: address of the token0 to zap
     * @param _token0AmountIn: amount for token0 to zap
     * @param _token1AmountIn: amount for token1 to zap
     * @param _lpToken: address of the LP token
     * @return swapAmountIn: amount that is expected to get swapped in intermediary swap
     * @return swapAmountOut: amount that is expected to get received in intermediary swap
     * @return isToken0Sold: whether the token0 is sold (false --> token1 is sold in the intermediary swap)
     */
    function estimateZapInRebalancingSwap(
        address _token0ToZap,
        address _token1ToZap,
        uint256 _token0AmountIn,
        uint256 _token1AmountIn,
        address _lpToken
    )
        external
        view
        returns (
            uint256 swapAmountIn,
            uint256 swapAmountOut,
            bool sellToken0
        )
    {
        require(
            _token0ToZap == IPancakePair(_lpToken).token0() || _token0ToZap == IPancakePair(_lpToken).token1(),
            "Zap: Wrong token0"
        );
        require(
            _token1ToZap == IPancakePair(_lpToken).token0() || _token1ToZap == IPancakePair(_lpToken).token1(),
            "Zap: Wrong token1"
        );

        require(_token0ToZap != _token1ToZap, "Zap: Same tokens");

        // Convert to uint256 (from uint112)
        (uint256 reserveA, uint256 reserveB, ) = IPancakePair(_lpToken).getReserves();

        if (_token0ToZap == IPancakePair(_lpToken).token0()) {
            sellToken0 = (_token0AmountIn * reserveB > _token1AmountIn * reserveA) ? true : false;

            // Calculate the amount that is expected to be swapped
            swapAmountIn = _calculateAmountToSwapForRebalancing(
                _token0AmountIn,
                _token1AmountIn,
                reserveA,
                reserveB,
                sellToken0
            );

            // Calculate the amount expected to be received in the intermediary swap
            if (sellToken0) {
                swapAmountOut = pancakeRouter.getAmountOut(swapAmountIn, reserveA, reserveB);
            } else {
                swapAmountOut = pancakeRouter.getAmountOut(swapAmountIn, reserveB, reserveA);
            }
        } else {
            sellToken0 = (_token0AmountIn * reserveA > _token1AmountIn * reserveB) ? true : false;
            // Calculate the amount that is expected to be swapped
            swapAmountIn = _calculateAmountToSwapForRebalancing(
                _token0AmountIn,
                _token1AmountIn,
                reserveB,
                reserveA,
                sellToken0
            );

            // Calculate the amount expected to be received in the intermediary swap
            if (sellToken0) {
                swapAmountOut = pancakeRouter.getAmountOut(swapAmountIn, reserveB, reserveA);
            } else {
                swapAmountOut = pancakeRouter.getAmountOut(swapAmountIn, reserveA, reserveB);
            }
        }

        return (swapAmountIn, swapAmountOut, sellToken0);
    }

    /*
     * @notice View the details for single zap
     * @dev Use WBNB for _tokenToReceive (if BNB is the asset to be received)
     * @param _lpToken: address of the LP token to zap out
     * @param _lpTokenAmount: amount of LP token to zap out
     * @param _tokenToReceive: token address to receive
     * @return swapAmountIn: amount that is expected to get swapped for intermediary swap
     * @return swapAmountOut: amount that is expected to get received for intermediary swap
     * @return swapTokenOut: address of the token that is sold in the intermediary swap
     */
    function estimateZapOutSwap(
        address _lpToken,
        uint256 _lpTokenAmount,
        address _tokenToReceive
    )
        external
        view
        returns (
            uint256 swapAmountIn,
            uint256 swapAmountOut,
            address swapTokenOut
        )
    {
        address token0 = IPancakePair(_lpToken).token0();
        address token1 = IPancakePair(_lpToken).token1();

        require(_tokenToReceive == token0 || _tokenToReceive == token1, "Zap: Token not in LP");

        // Convert to uint256 (from uint112)
        (uint256 reserveA, uint256 reserveB, ) = IPancakePair(_lpToken).getReserves();

        if (token1 == _tokenToReceive) {
            // sell token0
            uint256 tokenAmountIn = (_lpTokenAmount * reserveA) / IPancakePair(_lpToken).totalSupply();

            swapAmountIn = _calculateAmountToSwap(tokenAmountIn, reserveA, reserveB);
            swapAmountOut = pancakeRouter.getAmountOut(swapAmountIn, reserveA, reserveB);

            swapTokenOut = token0;
        } else {
            // sell token1
            uint256 tokenAmountIn = (_lpTokenAmount * reserveB) / IPancakePair(_lpToken).totalSupply();

            swapAmountIn = _calculateAmountToSwap(tokenAmountIn, reserveB, reserveA);
            swapAmountOut = pancakeRouter.getAmountOut(swapAmountIn, reserveB, reserveA);

            swapTokenOut = token1;
        }

        return (swapAmountIn, swapAmountOut, swapTokenOut);
    }

    /*
     * @notice Zap a token in (e.g. token/other token)
     * @param _tokenToZap: token to zap
     * @param _tokenAmountIn: amount of token to swap
     * @param _lpToken: LP token address
     * @param _tokenAmountOutMin: minimum token to receive in the intermediary swap
     */
    function _zapIn(
        address _tokenToZap,
        uint256 _tokenAmountIn,
        address _lpToken,
        uint256 _tokenAmountOutMin
    ) internal returns (uint256 lpTokenReceived) {
        require(_tokenAmountIn >= MINIMUM_AMOUNT, "Zap: Amount too low");

        address token0 = IPancakePair(_lpToken).token0();
        address token1 = IPancakePair(_lpToken).token1();

        require(_tokenToZap == token0 || _tokenToZap == token1, "Zap: Wrong tokens");

        // Retrieve the path
        address[] memory path = new address[](2);
        path[0] = _tokenToZap;

        // Initiates an estimation to swap
        uint256 swapAmountIn;

        {
            // Convert to uint256 (from uint112)
            (uint256 reserveA, uint256 reserveB, ) = IPancakePair(_lpToken).getReserves();

            require((reserveA >= MINIMUM_AMOUNT) && (reserveB >= MINIMUM_AMOUNT), "Zap: Reserves too low");

            if (token0 == _tokenToZap) {
                swapAmountIn = _calculateAmountToSwap(_tokenAmountIn, reserveA, reserveB);
                path[1] = token1;
                require(reserveA / swapAmountIn >= maxZapReverseRatio, "Zap: Quantity higher than limit");
            } else {
                swapAmountIn = _calculateAmountToSwap(_tokenAmountIn, reserveB, reserveA);
                path[1] = token0;
                require(reserveB / swapAmountIn >= maxZapReverseRatio, "Zap: Quantity higher than limit");
            }
        }

        // Approve token to zap if necessary
        _approveTokenIfNeeded(_tokenToZap);

        uint256[] memory swapedAmounts = pancakeRouter.swapExactTokensForTokens(
            swapAmountIn,
            _tokenAmountOutMin,
            path,
            address(this),
            block.timestamp
        );

        // Approve other token if necessary
        if (token0 == _tokenToZap) {
            _approveTokenIfNeeded(token1);
        } else {
            _approveTokenIfNeeded(token0);
        }

        // Add liquidity and retrieve the amount of LP received by the sender
        (, , lpTokenReceived) = pancakeRouter.addLiquidity(
            path[0],
            path[1],
            _tokenAmountIn - swapedAmounts[0],
            swapedAmounts[1],
            1,
            1,
            address(msg.sender),
            block.timestamp
        );

        return lpTokenReceived;
    }

    /*
     * @notice Zap two tokens in, rebalance them to 50-50, before adding them to LP
     * @param _token0ToZap: address of token0 to zap
     * @param _token1ToZap: address of token1 to zap
     * @param _token0AmountIn: amount of token0 to zap
     * @param _token1AmountIn: amount of token1 to zap
     * @param _lpToken: LP token address
     * @param _tokenAmountInMax: maximum token amount to sell (in token to sell in the intermediary swap)
     * @param _tokenAmountOutMin: minimum token to receive in the intermediary swap
     * @param _isToken0Sold: whether token0 is expected to be sold (if false, sell token1)
     */
    function _zapInRebalancing(
        address _token0ToZap,
        address _token1ToZap,
        uint256 _token0AmountIn,
        uint256 _token1AmountIn,
        address _lpToken,
        uint256 _tokenAmountInMax,
        uint256 _tokenAmountOutMin,
        bool _isToken0Sold
    ) internal returns (uint256 lpTokenReceived) {
        require(
            _token0ToZap == IPancakePair(_lpToken).token0() || _token0ToZap == IPancakePair(_lpToken).token1(),
            "Zap: Wrong token0"
        );
        require(
            _token1ToZap == IPancakePair(_lpToken).token0() || _token1ToZap == IPancakePair(_lpToken).token1(),
            "Zap: Wrong token1"
        );

        require(_token0ToZap != _token1ToZap, "Zap: Same tokens");

        // Initiates an estimation to swap
        uint256 swapAmountIn;

        {
            // Convert to uint256 (from uint112)
            (uint256 reserveA, uint256 reserveB, ) = IPancakePair(_lpToken).getReserves();

            require((reserveA >= MINIMUM_AMOUNT) && (reserveB >= MINIMUM_AMOUNT), "Zap: Reserves too low");

            if (_token0ToZap == IPancakePair(_lpToken).token0()) {
                swapAmountIn = _calculateAmountToSwapForRebalancing(
                    _token0AmountIn,
                    _token1AmountIn,
                    reserveA,
                    reserveB,
                    _isToken0Sold
                );
                require(reserveA / swapAmountIn >= maxZapReverseRatio, "Zap: Quantity higher than limit");
            } else {
                swapAmountIn = _calculateAmountToSwapForRebalancing(
                    _token0AmountIn,
                    _token1AmountIn,
                    reserveB,
                    reserveA,
                    _isToken0Sold
                );

                require(reserveB / swapAmountIn >= maxZapReverseRatio, "Zap: Quantity higher than limit");
            }
        }

        require(swapAmountIn <= _tokenAmountInMax, "Zap: Amount to swap too high");

        address[] memory path = new address[](2);

        // Define path for swapping and check whether to approve token to sell in intermediary swap
        if (_isToken0Sold) {
            path[0] = _token0ToZap;
            path[1] = _token1ToZap;
            _approveTokenIfNeeded(_token0ToZap);
        } else {
            path[0] = _token1ToZap;
            path[1] = _token0ToZap;
            _approveTokenIfNeeded(_token1ToZap);
        }

        // Execute the swap and retrieve quantity received
        uint256[] memory swapedAmounts = pancakeRouter.swapExactTokensForTokens(
            swapAmountIn,
            _tokenAmountOutMin,
            path,
            address(this),
            block.timestamp
        );

        // Check whether to approve other token and add liquidity to LP
        if (_isToken0Sold) {
            _approveTokenIfNeeded(_token1ToZap);

            (, , lpTokenReceived) = pancakeRouter.addLiquidity(
                path[0],
                path[1],
                (_token0AmountIn - swapedAmounts[0]),
                (_token1AmountIn + swapedAmounts[1]),
                1,
                1,
                address(msg.sender),
                block.timestamp
            );
        } else {
            _approveTokenIfNeeded(_token0ToZap);
            (, , lpTokenReceived) = pancakeRouter.addLiquidity(
                path[0],
                path[1],
                (_token1AmountIn - swapedAmounts[0]),
                (_token0AmountIn + swapedAmounts[1]),
                1,
                1,
                address(msg.sender),
                block.timestamp
            );
        }

        return lpTokenReceived;
    }

    /*
     * @notice Zap a LP token out to a token (e.g. token/other token)
     * @param _lpToken: LP token address
     * @param _tokenToReceive: token address
     * @param _tokenAmountOutMin: minimum token to receive in the intermediary swap
     */
    function _zapOut(
        address _lpToken,
        address _tokenToReceive,
        uint256 _tokenAmountOutMin
    ) internal returns (uint256) {
        address token0 = IPancakePair(_lpToken).token0();
        address token1 = IPancakePair(_lpToken).token1();

        require(_tokenToReceive == token0 || _tokenToReceive == token1, "Zap: Token not in LP");

        // Burn all LP tokens to receive the two tokens to this address
        (uint256 amount0, uint256 amount1) = IPancakePair(_lpToken).burn(address(this));

        require(amount0 >= MINIMUM_AMOUNT, "PancakeRouter: INSUFFICIENT_A_AMOUNT");
        require(amount1 >= MINIMUM_AMOUNT, "PancakeRouter: INSUFFICIENT_B_AMOUNT");

        address[] memory path = new address[](2);
        path[1] = _tokenToReceive;

        uint256 swapAmountIn;

        if (token0 == _tokenToReceive) {
            path[0] = token1;
            swapAmountIn = IERC20(token1).balanceOf(address(this));

            // Approve token to sell if necessary
            _approveTokenIfNeeded(token1);
        } else {
            path[0] = token0;
            swapAmountIn = IERC20(token0).balanceOf(address(this));

            // Approve token to sell if necessary
            _approveTokenIfNeeded(token0);
        }

        // Swap tokens
        pancakeRouter.swapExactTokensForTokens(swapAmountIn, _tokenAmountOutMin, path, address(this), block.timestamp);

        // Return full balance for the token to receive by the sender
        return IERC20(_tokenToReceive).balanceOf(address(this));
    }

    /*
     * @notice Allows to zap a token in (e.g. token/other token)
     * @param _token: token address
     */
    function _approveTokenIfNeeded(address _token) private {
        if (IERC20(_token).allowance(address(this), pancakeRouterAddress) < 1e24) {
            // Re-approve
            IERC20(_token).safeApprove(pancakeRouterAddress, MAX_INT);
        }
    }

    /*
     * @notice Calculate the swap amount to get the price at 50/50 split
     * @param _token0AmountIn: amount of token 0
     * @param _reserve0: amount in reserve for token0
     * @param _reserve1: amount in reserve for token1
     * @return amountToSwap: swapped amount (in token0)
     */
    function _calculateAmountToSwap(
        uint256 _token0AmountIn,
        uint256 _reserve0,
        uint256 _reserve1
    ) private view returns (uint256 amountToSwap) {
        uint256 halfToken0Amount = _token0AmountIn / 2;
        uint256 nominator = pancakeRouter.getAmountOut(halfToken0Amount, _reserve0, _reserve1);
        uint256 denominator = pancakeRouter.quote(
            halfToken0Amount,
            _reserve0 + halfToken0Amount,
            _reserve1 - nominator
        );

        // Adjustment for price impact
        amountToSwap =
            _token0AmountIn -
            Babylonian.sqrt((halfToken0Amount * halfToken0Amount * nominator) / denominator);

        return amountToSwap;
    }

    /*
     * @notice Calculate the amount to swap to get the tokens at a 50/50 split
     * @param _token0AmountIn: amount of token 0
     * @param _token1AmountIn: amount of token 1
     * @param _reserve0: amount in reserve for token0
     * @param _reserve1: amount in reserve for token1
     * @param _isToken0Sold: whether token0 is expected to be sold (if false, sell token1)
     * @return amountToSwap: swapped amount in token0 (if _isToken0Sold is true) or token1 (if _isToken0Sold is false)
     */
    function _calculateAmountToSwapForRebalancing(
        uint256 _token0AmountIn,
        uint256 _token1AmountIn,
        uint256 _reserve0,
        uint256 _reserve1,
        bool _isToken0Sold
    ) private view returns (uint256 amountToSwap) {
        bool sellToken0 = (_token0AmountIn * _reserve1 > _token1AmountIn * _reserve0) ? true : false;

        require(sellToken0 == _isToken0Sold, "Zap: Wrong trade direction");

        if (sellToken0) {
            uint256 token0AmountToSell = (_token0AmountIn - (_token1AmountIn * _reserve0) / _reserve1) / 2;
            uint256 nominator = pancakeRouter.getAmountOut(token0AmountToSell, _reserve0, _reserve1);
            uint256 denominator = pancakeRouter.quote(
                token0AmountToSell,
                _reserve0 + token0AmountToSell,
                _reserve1 - nominator
            );

            // Calculate the amount to sell (in token0)
            token0AmountToSell =
                (_token0AmountIn - (_token1AmountIn * (_reserve0 + token0AmountToSell)) / (_reserve1 - nominator)) /
                2;

            // Adjustment for price impact
            amountToSwap =
                2 *
                token0AmountToSell -
                Babylonian.sqrt((token0AmountToSell * token0AmountToSell * nominator) / denominator);
        } else {
            uint256 token1AmountToSell = (_token1AmountIn - (_token0AmountIn * _reserve1) / _reserve0) / 2;
            uint256 nominator = pancakeRouter.getAmountOut(token1AmountToSell, _reserve1, _reserve0);

            uint256 denominator = pancakeRouter.quote(
                token1AmountToSell,
                _reserve1 + token1AmountToSell,
                _reserve0 - nominator
            );

            // Calculate the amount to sell (in token1)
            token1AmountToSell =
                (_token1AmountIn - ((_token0AmountIn * (_reserve1 + token1AmountToSell)) / (_reserve0 - nominator))) /
                2;

            // Adjustment for price impact
            amountToSwap =
                2 *
                token1AmountToSell -
                Babylonian.sqrt((token1AmountToSell * token1AmountToSell * nominator) / denominator);
        }

        return amountToSwap;
    }
}


// File: src/PancakeExchange/utils/MockERC20.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor(
        string memory name,
        string memory symbol,
        uint256 supply
    ) ERC20(name, symbol) {
        _mint(msg.sender, supply);
    }

    function mintTokens(uint256 _amount) external {
        _mint(msg.sender, _amount);
    }
}


// File: src/Payments.sol
pragma solidity 0.8.17;

// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import {IRDNRegistry} from "./RDN/interfaces/IRDNRegistry.sol";
import {IRDNDistributor} from "./RDN/interfaces/IRDNDistributor.sol";
import {WithdrawAnyERC20Token} from "./Utils/WithdrawAnyERC20Token.sol";

contract Payments is AccessControlEnumerable, WithdrawAnyERC20Token {
    IRDNRegistry immutable public REGISTRY;
    uint public fee;

    struct Order {
        address currency;
        uint amount;
    }

    struct POS {
        address[] currencies;
        uint ownerId;
        uint rewards;
        bool paused;
        bool rdnOnly;
        uint activeTill;
        uint maxPaidAmount;
        uint maxOrdersCount;
        uint paidAmount;
    }

    mapping(uint => uint[]) public usersPOS;
    POS[] public POSRegistry;

    mapping(uint => mapping(uint => Order)) public orders;
    uint[][] public posPaidOrders;

    bytes32 public constant SETFEE_ROLE = keccak256("SETFEE_ROLE");

    event Payment(
        uint indexed posId,
        uint indexed orderId,
        address indexed currency,
        uint amount,
        uint totalOrderAmount,
        uint rewardsAmount,
        uint feeAmount
    );

    constructor(address _registry, address _admin) WithdrawAnyERC20Token(_admin, false) {
        REGISTRY = IRDNRegistry(_registry);
        fee = 1000;
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(SETFEE_ROLE, _admin);
    }

    function pay(uint _posId, uint _orderId, address _currency, uint _amount) public{
        POS memory pos = POSRegistry[_posId]; // gas savings
        require(inArray(pos.currencies, _currency), 'Invalid _currency or _posId');
        require(isActive(_posId), "POS not active");
        if (pos.rdnOnly) {
            require(REGISTRY.isRegisteredByAddress(msg.sender), 'Not registered in RDN');
        }
        require(_amount > 0, '_amount should be positive');
        IERC20 token = IERC20(_currency);
        token.transferFrom(msg.sender, address(this), _amount);
        uint remainedAmount = _amount;
        uint feeAmount = _amount * fee / 10000;
        remainedAmount -= feeAmount;
        uint rewardsAmount = 0;
        if (pos.rewards > 0 && REGISTRY.isRegisteredByAddress(msg.sender)) { // if msg.sender is out of RDN, rewards forwards to POS owner
            rewardsAmount = remainedAmount * pos.rewards / 10000;
            remainedAmount -= rewardsAmount;
            IRDNDistributor distributor = IRDNDistributor(REGISTRY.getDistributor(_currency));
            token.approve(address(distributor), rewardsAmount);
            distributor.distribute(msg.sender, rewardsAmount);
        }

        if (remainedAmount > 0) {
            token.transfer(REGISTRY.getUserAddress(pos.ownerId), remainedAmount);
        }

        if (pos.maxPaidAmount > 0) {
            POSRegistry[_posId].paidAmount += _amount;
        }

        if (orders[_posId][_orderId].amount > 0) {
            require(orders[_posId][_orderId].currency == _currency, "Order must be paid by same tokens");
            orders[_posId][_orderId].amount += _amount;
        } else {
            Order memory newOrder = Order(_currency, _amount);
            orders[_posId][_orderId] = newOrder;
            posPaidOrders[_posId].push(_orderId);
        }
        
        emit Payment(_posId, _orderId, _currency, _amount, orders[_posId][_orderId].amount, rewardsAmount, feeAmount);
        
    }

    function inArray(address[] memory _haystack, address _needl) internal pure returns(bool) {
        for (uint i=0; i < _haystack.length; i++) {
            if (_haystack[i] == _needl) {
                return true;
            }
        }
        return false;
    }

    function createPOS(address[] calldata _currencies, uint _rewards, bool _rdnOnly, uint _activeTill, uint _maxOrdersCount, uint _maxPaidAmount) public {
        uint ownerId = REGISTRY.getUserIdByAddress(msg.sender);
        require(ownerId > 0, "Not registered in RDN");
        if (_maxPaidAmount > 0) {
            require(_currencies.length == 1, "_maxPaidAmount can't be positive for multiple currencies");
        }
        POS storage newPOS = POSRegistry.push();
        posPaidOrders.push();
        newPOS.ownerId = ownerId;
        newPOS.currencies = _currencies;
        newPOS.rewards = _rewards;
        newPOS.rdnOnly = _rdnOnly;
        newPOS.maxPaidAmount = _maxPaidAmount;
        newPOS.maxOrdersCount = _maxOrdersCount;
        newPOS.activeTill = _activeTill;
        uint posId = POSRegistry.length - 1;
        usersPOS[ownerId].push(posId);
    }


    function setFee(uint _fee) public onlyRole(SETFEE_ROLE) {
        fee = _fee;
    }

    function pause(uint _posId) public {
        uint ownerId = REGISTRY.getUserIdByAddress(msg.sender);
        require(POSRegistry[_posId].ownerId == ownerId, "Access denied");
        POSRegistry[_posId].paused = true;
    }

    function unPause(uint _posId) public {
        uint ownerId = REGISTRY.getUserIdByAddress(msg.sender);
        require(POSRegistry[_posId].ownerId == ownerId, "Access denied");
        POSRegistry[_posId].paused = false;
    }

    function isActive(uint _posId) public view returns(bool) {
        if (isPaused(_posId) || isStopped(_posId)) {
            return false;
        }
        return true;
    }

    function isPaused(uint _posId) public view returns(bool) {
        return POSRegistry[_posId].paused;
    }

    function isStopped(uint _posId) public view returns(bool) {
        POS memory pos = POSRegistry[_posId]; // gas savings
        if (pos.activeTill > 0 && pos.activeTill < block.timestamp) {
            return true;
        }
        if (pos.maxPaidAmount > 0 && pos.paidAmount >= pos.maxPaidAmount) {
            return true;
        }
        if (pos.maxOrdersCount > 0 && posPaidOrders[_posId].length >= pos.maxOrdersCount) {
            return true;
        }
        return false;
    }

    function getAllPOS() public view returns(POS[] memory) {
        return POSRegistry;
    }

    function getPOS(uint _posId) public view returns(POS memory) {
        return POSRegistry[_posId];
    }

    function getAllPOSOrders(uint _posId) public view returns(uint[] memory) {
        return posPaidOrders[_posId];
    }

}

// File: src/RDN/interfaces/IRDNDistributor.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;


interface IRDNDistributor {
    
    function distribute(address _initAddress, uint _amount) external;

    function getToken() external view returns(address);
}

// File: src/RDN/interfaces/IRDNFactors.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

import {IRDNRegistry} from "./IRDNRegistry.sol";

interface IRDNFactors {

    function getFactor(IRDNRegistry.User memory user) external view returns(uint);

    function calc(IRDNRegistry.User memory user) external pure returns(uint);

    function getDecimals() external view returns(uint);
}

// File: src/RDN/interfaces/IRDNRegistry.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

interface IRDNRegistry {
    
    struct User {
        uint level;
        address userAddress;
        uint parentId;
        uint tariff;
        uint activeUntill;
        uint created;
    }

    function register(uint _parentId) external;

    function getUser(uint) external view returns(User memory);

    function getUserIdByAddress(address _userAddress) external view returns(uint);

    function usersCount() external view returns(uint);
    
    function getUsersCount() external view returns(uint);
    
    function getChildren(uint _userId) external view returns(uint[] memory);

    function isRegistered(uint _userId) external view returns(bool);
    
    function isValidUser(uint _userId) external view returns(bool);
    
    function isRegisteredByAddress(address _userAddress) external view returns(bool);

    function isActive(uint _userId) external view returns(bool);

    function factorsAddress() external view returns(address);

    function getParentId(uint _userId) external view returns(uint);

    function getLevel(uint _userId) external view returns(uint);

    function getTariff(uint _userId) external view returns(uint);

    function getActiveUntill(uint _userId) external view returns(uint);

    function getUserAddress(uint _userId) external view returns(address);

    function getDistributor(address _token) external view returns(address);

    function setTariff(uint _userId, uint _tariff) external;
    
    function setActiveUntill(uint _userId, uint _activeUntill) external;

}


// File: src/RDN/interfaces/IRDNTariffPosBonusStorage.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

interface IRDNTariffPosBonusStorage {

    function setCounter(uint _userId, uint _value) external;

    function addCounter(uint _userId, uint _value) external;

    function setCandidate(uint _userId, bool _value) external;

    function getCounter(uint _userId) external view returns(uint);

    function isCandidate(uint _userId) external view returns(bool);

    function getCandidatesCount() external view returns(uint);

}

// File: src/RDN/RDNAccountLinking.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract RDNAccountLinking {
    event AccountLinked (
        address indexed addr,
        uint256 indexed code
    );

    function linkAccount(uint256 _code) public {
        emit AccountLinked(msg.sender, _code);
    }
}

// File: src/RDN/RDNAdjustments.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

contract RDNAdjustments is AccessControlEnumerable {
    bytes32 public constant ADJUST_ROLE = keccak256("ADJUSTSTRUCTINC_ROLE");

    struct Adjustment {
        uint structPointsInc;
        uint ownPointsInc;
        uint structPointsMin;
        uint ownPointsMin;
        uint levelMin;
        uint dirLevelMin;
    }

    mapping (uint => Adjustment) public adjustments;

    constructor(address _admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(ADJUST_ROLE, _admin);
    }

    function adjustUser(uint _userId, uint _structPointsInc, uint _ownPointsInc, uint _structPointsMin, uint _ownPointsMin, uint _levelMin, uint _dirLevelMin) public onlyRole(ADJUST_ROLE) {
        Adjustment memory adjustment = Adjustment(_structPointsInc, _ownPointsInc, _structPointsMin, _ownPointsMin, _levelMin, _dirLevelMin);
        adjustments[_userId] = adjustment;
    }

    function getAdjustment(uint _userId) public view returns(Adjustment memory) {
        return adjustments[_userId];
    }

}

// File: src/RDN/RDNDepositary.sol
pragma solidity 0.8.17;

// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IRDNRegistry} from "./interfaces/IRDNRegistry.sol";

interface IRDNDepositary {
    
    event TokensLocked(address indexed userAddress, uint indexed userId, uint amount, uint unlockAfter);

    event TokensUnlocked(address indexed userADDRESS, uint indexed userId, uint amount);

    function getLockedAmount(uint _userId) external view returns(uint);

    function getTotalLockedAmount() external view returns(uint);

}

contract RDNDepositary is Context, AccessControlEnumerable {
    bytes32 public constant WITHDRAW_OVERAGE_ROLE = keccak256("WITHDRAW_OVERAGE_ROLE");
    bytes32 public constant PAUSE_LOCKING_ROLE = keccak256("PAUSE_LOCKING_ROLE");
    bytes32 public constant LOCK_PERIOD_ROLE = keccak256("LOCK_PERIOD_ROLE");
    
    mapping (uint => uint) balances;
    mapping (uint => uint) unlockAfter;
    uint public totalLocked;
    uint public lockPeriod;
    bool public lockingPaused;

    IERC20 public token;
    IRDNRegistry registry;

    event TokensLocked(address indexed userAddress, uint indexed userId, uint amount, uint unlockAfter);

    event TokensUnlocked(address indexed userADDRESS, uint indexed userId, uint amount);

    constructor (address _tokenAddress, address _registryAddress, uint _lockPeriod) {
        token = IERC20(_tokenAddress);
        registry = IRDNRegistry(_registryAddress);
        lockPeriod = _lockPeriod;
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(WITHDRAW_OVERAGE_ROLE, _msgSender());
        _setupRole(PAUSE_LOCKING_ROLE, _msgSender());
    }
    
    function lockTokens(uint _amount) public {
        require(lockingPaused == false, "Locking is paused");
        uint userId = registry.getUserIdByAddress(_msgSender());
        require(userId > 0, "Sender address is not registered");
        token.transferFrom(_msgSender(), address(this), _amount);
        balances[userId] += _amount;
        totalLocked += _amount;
        unlockAfter[userId] = block.timestamp + lockPeriod;
        emit TokensLocked(_msgSender(), userId, _amount, unlockAfter[userId]);
    }
    
    function unlockTokens() public {
        uint userId = registry.getUserIdByAddress(_msgSender());
        uint balance = balances[userId];
        require(userId > 0, "Sender address is not registered");
        require(balance > 0, "Balance is empty");
        require(unlockAfter[userId] < block.timestamp);
        token.transfer(_msgSender(), balance);
        balances[userId]  = 0;
        totalLocked -= balance;
        emit TokensUnlocked(_msgSender(), userId, balance);
    }

    function withdrawOverage(address _recipient) public onlyRole(WITHDRAW_OVERAGE_ROLE) {
        uint realBalance = token.balanceOf(address(this));
        uint overage = realBalance - totalLocked;
        require(overage > 0, "Nothing to withdraw");
        token.transfer(_recipient, overage);
    }

    function pauseLocking() public onlyRole(PAUSE_LOCKING_ROLE) {
        require(lockingPaused == false, "Locking is already paused");
        lockingPaused = true;
    }

    function unpauseLocking() public  onlyRole(PAUSE_LOCKING_ROLE){
        require(lockingPaused == true, "Locking is not paused");
        lockingPaused = false;
    }

    function setupLockPeriod(uint _lockPeriod) public onlyRole(LOCK_PERIOD_ROLE) {
        lockPeriod = _lockPeriod;
    }

    function getLockedAmount(uint _userId) public view returns(uint) {
        return balances[_userId];
    }

    function getTotalLockedAmount() public view returns(uint) {
        return totalLocked;
    }

}

// File: src/RDN/RDNDistributor.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IRDNRegistry} from "./interfaces/IRDNRegistry.sol";
import {IRDNFactors} from "./interfaces/IRDNFactors.sol";
import {WithdrawAnyERC20Token} from "../Utils/WithdrawAnyERC20Token.sol";

contract RDNDistributor is AccessControlEnumerable, WithdrawAnyERC20Token {

    IERC20 public immutable token;
    IRDNRegistry public immutable registry;

    event Distributed(uint indexed userId, address indexed userAddress, address indexed tokenAddress, uint initUserId, address initAddress, uint amount);

    constructor(address _token, address _registry, address _admin) WithdrawAnyERC20Token(_admin, true) {
        token = IERC20(_token);
        registry = IRDNRegistry(_registry);
    }

    function distribute(address _initAddress, uint _amount) public {
        token.transferFrom(msg.sender, address(this), _amount);
        uint userId = registry.getUserIdByAddress(_initAddress);
        uint initUserId = userId;
        IRDNFactors factors = IRDNFactors(registry.factorsAddress());
        uint8 count;
        uint factor;
        uint maxFactor;
        uint bonus;
        uint amountRemained = _amount;
        IRDNRegistry.User memory user = registry.getUser(userId);
        while (user.parentId > 0 && count < 12) {
            count += 1;
            userId = user.parentId;
            user = registry.getUser(userId);
            factor = factors.getFactor(user);
            if (factor > maxFactor) {
                bonus = (_amount * (factor - maxFactor))/ (10 ** factors.getDecimals());
                maxFactor = factor;
                amountRemained -= bonus;
                if (user.activeUntill > block.timestamp) {
                    token.transfer(user.userAddress, bonus);
                    emit Distributed(userId, user.userAddress, address(token), initUserId, _initAddress, bonus);
                }
            }
        }
    }

    function getToken() public view returns(address) {
        return address(token);
    }
    
}

// File: src/RDN/RDNEventPos.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./interfaces/IRDNRegistry.sol";
import {WithdrawAnyERC20Token} from "../Utils/WithdrawAnyERC20Token.sol";


contract RDNEventPos is AccessControlEnumerable, Pausable, WithdrawAnyERC20Token {

    using SafeERC20 for IERC20;
    
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant CONFIG_ROLE = keccak256("CONFIG_ROLE");

    address immutable registry;
    address public token;

    uint reward0 = 500;
    uint reward1 = 2000;

    uint createdStamp;

    mapping (uint => uint) public prices;

    struct Participant {
        uint date;
        uint tariff;
        uint userId;
    }

    Participant[] public participants;
    mapping (uint=>uint) participantId; // userId => id in contributors array

    event Distributed(uint indexed userId, address indexed userAddress, address indexed tokenAddress, uint initUserId, address initAddress, uint amount);


    constructor (address _admin, address _registry, address _token) WithdrawAnyERC20Token(_admin, false) {
        registry = _registry;
        token = _token;

        createdStamp = block.timestamp;
        prices[0] = 300 ether;
        
        Participant memory defaultParticipant = Participant(0, 0, 0);
        participants.push(defaultParticipant);

        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(CONFIG_ROLE, _admin);
        _setupRole(PAUSER_ROLE, _admin);
    }

    function participate(uint tariff) public whenNotPaused {
        uint userId = IRDNRegistry(registry).getUserIdByAddress(msg.sender);
        require(userId > 0, "Not RDN user");
        require(!isParticipant(userId), "Already participant");
        require(prices[tariff] > 0, "Wrong tariff");

        IERC20(token).safeTransferFrom(msg.sender, address(this), prices[tariff]);

        Participant memory participant = Participant(block.timestamp, tariff, userId);
        participants.push(participant);
        participantId[userId] = participants.length - 1;

        // reward distribution
        uint parentId = IRDNRegistry(registry).getParentId(userId);
        if (IRDNRegistry(registry).isActive(parentId)) {
            address parentAddress = IRDNRegistry(registry).getUserAddress(parentId);
            IRDNRegistry.User memory user = IRDNRegistry(registry).getUser(userId);
            uint reward;
            if (user.created >= createdStamp) {
                reward = (prices[tariff] * reward1)/(10**4);
            } else {
                reward = (prices[tariff] * reward0)/(10**4);
            }
            if (reward > 0) {
                IERC20(token).safeTransfer(parentAddress, reward);
                emit Distributed(parentId, parentAddress, token, userId, msg.sender, reward);
            }
        }
    }


    function setToken(address _token) public onlyRole(CONFIG_ROLE) {
        token = _token;
    }

    function setReward(uint _reward0, uint _reward1) public onlyRole(CONFIG_ROLE) {
        reward0 = _reward0;
        reward1 = _reward1;
    }

    function setCreatedStamp(uint _createdStamp) public onlyRole(CONFIG_ROLE) {
        createdStamp = _createdStamp;
    }

    function setPrice(uint _tariff, uint _price) public onlyRole(CONFIG_ROLE) {
        prices[_tariff] = _price;
    }

    function pause() public onlyRole(PAUSER_ROLE) {
        _pause();
    }

    function unPause() public onlyRole(PAUSER_ROLE) {
        _unpause();
    }


    function isParticipant(uint userId) public view returns(bool) {
        if (participantId[userId] > 0) {
            return true;
        }
        return false;
    }

    function isParticipantByAddress(address userAddress) public view returns(bool) {
        uint userId = IRDNRegistry(registry).getUserIdByAddress(userAddress);
        return isParticipant(userId);
    }

    function getAllParticipants() public view returns(Participant[] memory) {
        return participants;
    }

    function getPrice(uint tariff) public view returns(uint) {
        return prices[tariff];
    }

    function getReward0() public view returns(uint) {
        return reward0;
    }

    function getReward1() public view returns(uint) {
        return reward1;
    }

    function getCreatedStamp() public view returns(uint) {
        return createdStamp;
    }

    function getToken() public view returns(address) {
        return token;
    }




    

}

// File: src/RDN/RDNFactors.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

import {IRDNRegistry} from "./interfaces/IRDNRegistry.sol";

contract RDNFactors {

    IRDNRegistry public registry;

    uint public decimals = 4;

    uint[7][12] public factors = [
        [1500, 1956, 2413, 2869, 3326, 3782, 4239 ],
        [4239, 4467, 4695, 4924, 5152, 5380, 5608 ],
        [5608, 5760, 5913, 6065, 6217, 6369, 6521 ],
        [6521, 6635, 6750, 6864, 6978, 7092, 7206 ],
        [7206, 7297, 7389, 7480, 7571, 7663, 7754 ],
        [7754, 7830, 7906, 7982, 8058, 8134, 8210 ],
        [8210, 8276, 8341, 8406, 8471, 8536, 8602 ],
        [8602, 8659, 8716, 8773, 8830, 8887, 8944 ],
        [8944, 8995, 9045, 9096, 9147, 9198, 9248 ],
        [9248, 9294, 9340, 9385, 9431, 9477, 9522 ],
        [9522, 9564, 9605, 9647, 9688, 9730, 9771 ],
        [9771, 9809, 9847, 9885, 9923, 9961, 10000 ]
    ];

    constructor (address _registry) {
        registry = IRDNRegistry(_registry);
    }
    
    function getFactor(IRDNRegistry.User memory user) public view returns(uint) {
        if (user.level == 0 || user.tariff == 0) return 0;
        user.level = (user.level >= 12)?11:(user.level-1);
        user.tariff = (user.tariff >= 7)?6:(user.tariff-1);
        return factors[user.level][user.tariff];
    }

    function calc(IRDNRegistry.User memory user) public pure returns(uint) {
        uint tariffsCount = 7;
        uint maxFactor = 1 ether;

        // return _level*(maxFactor/12)/(10**14);

        uint min = (user.level >= 12 && user.tariff >= 7)?maxFactor:(maxFactor - calcStep(user.level, 12));
        uint max = (user.level >= 12 && user.tariff >= 7)?maxFactor:(maxFactor - calcStep(user.level+1, 12));
        uint tariffStep = (max - min)/(tariffsCount-1);
        uint factor = min + tariffStep * (user.tariff - 1);
        return factor/(10**14);
    }

    function test(uint x) public pure returns(uint) {
        return x*2;
    }

    function calcStep(uint _level, uint _levelMax) pure private returns(uint) {
        uint base = 0.2739 ether;
        if (_level > _levelMax) {
            return 0;
        } else {
            return (base/_levelMax + calcStep(_level, _levelMax-1));
        }
    }

    function getDecimals() public view returns(uint) {
        return decimals;
    }

    function getAllFactors() public view returns(uint[7][12] memory) {
        return factors;
    }

}


// File: src/RDN/RDNOwnable.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

import {IRDNRegistry} from "./interfaces/IRDNRegistry.sol";

contract RDNOwnable {
    address public registry;
    uint public ownerId;

    function initRDNOwnable(address _registry, uint _ownerId) internal {
        registry = _registry;
        require(IRDNRegistry(registry).isValidUser(_ownerId));
        ownerId = _ownerId;
    }

    modifier onlyRDNOwner(address _userAddress) {
        require(isRDNOwner(_userAddress), "RDNOwnable: access denied");
        _;
    }

    modifier onlyActiveRDNOwner(address _userAddress) {
        require(isActiveRDNOwner(_userAddress), "RDNOwnable: access denied");
        _;
    }

    function isRDNOwner(address _userAddress) public view returns(bool) {
        return(IRDNRegistry(registry).getUserIdByAddress(_userAddress) == ownerId);
    }

    function isActiveRDNOwner(address _userAddress) public view returns(bool) {
        IRDNRegistry registryInterface = IRDNRegistry(registry);
        uint _userId = registryInterface.getUserIdByAddress(_userAddress);
        return(registryInterface.isActive(_userId) && (ownerId == _userId));
    }

}

// File: src/RDN/RDNRegistry.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import {WithdrawAnyERC20Token} from "../Utils/WithdrawAnyERC20Token.sol";
import {IRDNRegistry} from "./interfaces/IRDNRegistry.sol";

// Parent 0 address restricted
// Default level 1

contract RDNRegistry is IRDNRegistry, AccessControlEnumerable, WithdrawAnyERC20Token {

    // admin role for userlevel change (setLevel function)
    bytes32 public constant SETLEVEL_ROLE = keccak256("SETLEVEL_ROLE");
    // admin role for userlevel change (levelUp function)
    bytes32 public constant LEVELUP_ROLE = keccak256("LEVELUP_ROLE");
    // admin role for changing factors contract address
    bytes32 public constant FACTORSADDRESS_ROLE = keccak256("FACTORSADDRESS_ROLE");
    // admin role for RDNPOS contract
    bytes32 public constant TARIFFUPDATE_ROLE = keccak256("TARIFFUPDATE_ROLE");
    // admin role for RDNPOS contract 
    bytes32 public constant ACTIVEUNTILLUPDATE_ROLE = keccak256("ACTIVEUNTILLUPDATE_ROLE");
    // admin role fore points rate updating
    bytes32 public constant POINTSRATEUPDATE_ROLE = keccak256("POINTSRATEUPDATE_ROLE");
    // admin role for RDNDistributors configuration
    bytes32 public constant SETDISTRIBUTOR_ROLE = keccak256("SETDISTRIBUTOR_ROLE");
    // admin role for adding custom users
    bytes32 public constant ADDUSERBYADMIN_ROLE = keccak256("ADDUSERBYADMIN_ROLE");

    // actual userAddress => userId
    mapping (address => uint) public userId;
    // users registry
    User[] public users;
    // gas saving counter
    uint public usersCount;
    mapping(uint => uint[]) public children;

    // addresses granted to change userAddress for userId;
    mapping(uint => mapping(address => bool)) public changeAddressAccess;
    mapping(uint => address[]) public changeAddressAddresses;

    // actual factors contract
    address public factorsAddress;

    // token => rate (rate is 1/USDprice for token, based in token.decimals)
    mapping (address => uint) public pointsRate;

    // actual RDNDistributors registry. token => RDNDistributor
    mapping (address => address) public distributors;

    // when new user created
    event UserAdded(uint indexed userId, uint indexed parentId, address indexed userAddress);
    // when users level updated
    event UserLevelUpdated(uint indexed userId, uint levelBefore, uint levelAfter);
    // when users tariff updated
    event UserTariffUpdated(uint indexed userId, uint tariffBefore, uint tariffAfter);
    // when users activeUntill updated
    event UserActiveUntillUpdated(uint indexed userId, uint activeUntill);
    // when tokens points rate value updated
    event PointsRateUpdated(address indexed token, uint rate);
    // when userAddress changed
    event UserAddressChanged(uint indexed userId, address indexed userAddress, address indexed sender, address oldAddress);
    // when granted change user address
    event GrantedUserAddressChange(uint indexed userId, address indexed grantedAddress);
    // when revoked access to change user address
    event RevokedUserAddressChange(uint indexed userId, address indexed revokedAddress);

    /*
     * @notice Constructor
     * @param _root: userAdrress for userId = 1
     * @param _admin: default admin
    */
    constructor (address _root, address _admin) WithdrawAnyERC20Token(_admin, false) {
        // add 0 user. No one user can reference 0 in parentId, excluding user 1.
        User memory _zeroUser = User(0, address(0), 0, 0, 0, block.timestamp);
        users.push(_zeroUser);
        userId[address(0)] = 0;
        
        //add root user (userId 1), referencing parentId=0.
        User memory _rootUser = User(12, _root, 0, 7, block.timestamp + 36500 days, block.timestamp);
        users.push(_rootUser);
        userId[_root] = 1;
        children[0].push(1);

        usersCount = 2;

        // default roles setup
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(SETLEVEL_ROLE, _admin);
        _setupRole(LEVELUP_ROLE, _admin);
        _setupRole(FACTORSADDRESS_ROLE, _admin);
        _setupRole(TARIFFUPDATE_ROLE, _admin);
        _setupRole(ACTIVEUNTILLUPDATE_ROLE, _admin);
        _setupRole(POINTSRATEUPDATE_ROLE, _admin);
        _setupRole(SETDISTRIBUTOR_ROLE, _admin);
        _setupRole(ADDUSERBYADMIN_ROLE, _admin);
    }

    ///////////////////////////////////////
    // public user functions
    ///////////////////////////////////////
    
    /* 
     * @notice user registration
     * @param _parentId: registered user with tariff > 0
    */
    function register(uint _parentId) external {
        _addUser(msg.sender, _parentId);
    }

    /*
     * @notice user or granted addresses can change userAddress
    */
    function changeAddress(uint _userId, address _newAddress) public hasChangeAddressAccess(_userId) {
        require(!isRegisteredByAddress(_newAddress), "user already registered");
        emit UserAddressChanged(_userId, _newAddress, msg.sender, users[_userId].userAddress);
        userId[users[_userId].userAddress] = 0;
        userId[_newAddress] = _userId;
        users[_userId].userAddress = _newAddress;
    }

    /*
     * @notice user can grant other addresses to change userAddress
    */
    function grantChangeAddressAccess(address _grantedAddress) public onlyRegisteredByAddress(msg.sender) {
        uint _userId = userId[msg.sender];
        changeAddressAddresses[_userId].push(_grantedAddress);
        changeAddressAccess[_userId][_grantedAddress] = true;
        emit GrantedUserAddressChange(_userId, _grantedAddress);
    }

    /*
    * @notice user can revoke changeAddressAccess. Granted address can revoke its own access
    */
    function revokeChangeAddressAccess(uint _userId, address _grantedAddress) public {
        require(users[_userId].userAddress == msg.sender || _grantedAddress == msg.sender, "Access denied");
        changeAddressAccess[_userId][_grantedAddress] = false;
        emit RevokedUserAddressChange(_userId, _grantedAddress);
    }

    //////////////////////////////////////
    // admin functions
    //////////////////////////////////////

    function levelUp(uint _userId, uint _level) public onlyRole(LEVELUP_ROLE) onlyValidUser(_userId) {
        require(_level > users[_userId].level, "_level must be greater");
        emit UserLevelUpdated(_userId, users[_userId].level, _level);
        users[_userId].level = _level;
    }

    function setLevel(uint _userId, uint _level) public onlyRole(SETLEVEL_ROLE) onlyValidUser(_userId) {
        emit UserLevelUpdated(_userId, users[_userId].level, _level);
        users[_userId].level = _level;
    }

    function setFactorsAddress(address _factorsAddress) public onlyRole(FACTORSADDRESS_ROLE) {
        factorsAddress = _factorsAddress;
    }

    function setTariff(uint _userId, uint _tariff) public onlyRole(TARIFFUPDATE_ROLE) onlyValidUser(_userId) {
        emit UserTariffUpdated(_userId, users[_userId].tariff, _tariff);
        users[_userId].tariff = _tariff;
    }

    function setActiveUntill(uint _userId, uint _activeUntill) public onlyRole(ACTIVEUNTILLUPDATE_ROLE) onlyValidUser(_userId) {
        users[_userId].activeUntill = _activeUntill;
        emit UserActiveUntillUpdated(_userId, _activeUntill);
    }

    function setPointsRate(address _token, uint _rate) public onlyRole(POINTSRATEUPDATE_ROLE) {
        pointsRate[_token] = _rate;
        emit PointsRateUpdated(_token, _rate);
    }

    function setDistributor(address _token, address _distributor) public onlyRole(SETDISTRIBUTOR_ROLE) {
        distributors[_token] = _distributor;
    }

    function grantCompleteAdmin(address _admin) public {
        grantRole(DEFAULT_ADMIN_ROLE, _admin);
        grantRole(SETLEVEL_ROLE, _admin);
        grantRole(LEVELUP_ROLE, _admin);
        grantRole(FACTORSADDRESS_ROLE, _admin);
        grantRole(TARIFFUPDATE_ROLE, _admin);
        grantRole(ACTIVEUNTILLUPDATE_ROLE, _admin);
        grantRole(POINTSRATEUPDATE_ROLE, _admin);
        grantRole(SETDISTRIBUTOR_ROLE, _admin);
        grantRole(ADDUSERBYADMIN_ROLE, _admin);
    }

    function revokeCompleteAdmin(address _admin) public {
        revokeRole(SETLEVEL_ROLE, _admin);
        revokeRole(LEVELUP_ROLE, _admin);
        revokeRole(FACTORSADDRESS_ROLE, _admin);
        revokeRole(TARIFFUPDATE_ROLE, _admin);
        revokeRole(ACTIVEUNTILLUPDATE_ROLE, _admin);
        revokeRole(POINTSRATEUPDATE_ROLE, _admin);
        revokeRole(SETDISTRIBUTOR_ROLE, _admin);
        revokeRole(ADDUSERBYADMIN_ROLE, _admin);
        revokeRole(DEFAULT_ADMIN_ROLE, _admin);
    }

    /*
     * @notice sender must have 3 roles
    */
    function addUserByAdmin(uint _parentId, address _userAddress, uint _tariff, uint _activeUntill, uint _level) public onlyRole(ADDUSERBYADMIN_ROLE) {
        (uint _userId) = _addUser(_userAddress, _parentId);
        setTariff(_userId, _tariff);
        setActiveUntill(_userId, _activeUntill);
        setLevel(_userId, _level);
    }

    //////////////////////////////////////
    // private functions
    //////////////////////////////////////

    function _addUser(address _userAddress, uint _parentId) private returns(uint) {
        require(!isRegisteredByAddress(_userAddress), "user already registered");
        require(isRegistered(_parentId), "_parentId not found");
        require(users[_parentId].tariff > 0, "_parentId can not be parent");
        User memory _user = User(1, _userAddress, _parentId, 0, 0, block.timestamp);
        users.push(_user);
        usersCount += 1;
        userId[_userAddress] = usersCount - 1;
        children[_parentId].push(usersCount - 1);
        emit UserAdded(usersCount - 1, _parentId, _userAddress);
        return (usersCount - 1);
    }


    //////////////////////////////////////
    // modifiers
    //////////////////////////////////////


    modifier onlyRegisteredByAddress(address _userAddress) {
        require(isRegisteredByAddress(_userAddress), "user not registered");
        _;
    }

    modifier onlyRegistered(uint _userId) {
        require(isRegistered(_userId), "user not registered");
        _;
    }

    modifier onlyValidUser(uint _userId) {
        require(isValidUser(_userId), "invalid userId");
        _;
    }

    modifier hasChangeAddressAccess(uint _userId) {
        require(isValidUser(_userId), "UserId not valid");
        require(users[_userId].userAddress == msg.sender || changeAddressAccess[_userId][msg.sender], "Access denied");
        _;
    }


    //////////////////////////////////////
    // public getters and checkers
    //////////////////////////////////////

    /*
     * @notice 0 user is also registered
    */
    function isRegistered(uint _userId) public view returns(bool) {
        if (_userId < usersCount) {
            return true;
        }
        return false;
    }

    /*
     * @notice 0 user is not valid
    */
    function isValidUser(uint _userId) public view returns(bool) {
        if ((_userId > 0) && (_userId < usersCount)) {
            return true;
        }
        return false;
    }

    function isRegisteredByAddress(address _userAddress) public view returns(bool) {
        if (userId[_userAddress] != 0 || _userAddress == address(0)) {
            return true;
        }
        return false;
    }

    function isActive(uint _userId) public view returns(bool) {
        return (users[_userId].activeUntill > block.timestamp);
    }

    function getParentId(uint _userId) public view returns(uint) {
        return users[_userId].parentId;
    }

    function getLevel(uint _userId) public view returns(uint) {
        return users[_userId].level;
    }

    function getTariff(uint _userId) public view returns(uint) {
        return users[_userId].tariff;
    }

    function getActiveUntill(uint _userId) public view returns(uint) {
        return users[_userId].activeUntill;
    }

    function getUserAddress(uint _userId) public view returns(address) {
        return users[_userId].userAddress;
    }

    function getAllUsers() public view returns(User[] memory) {
        return users;
    }

    function getUser(uint _userId) public view returns(User memory) {
        return users[_userId];
    }

    function getUserIdByAddress(address _userAddress) public view returns(uint) {
        return userId[_userAddress];
    }

    function getUsersCount() public view returns(uint) {
        return usersCount;
    }

    function getChildren(uint _userId) public view returns(uint[] memory) {
        return children[_userId];
    }

    function getPointsRate(address _token) public view returns(uint) {
        return pointsRate[_token];
    }

    function getDistributor(address _token) public view returns(address) {
        require (distributors[_token] != address(0), "Distributor not found");
        return distributors[_token];
    }

    function isHasChangeAddressAccess(uint _userId, address _grantedAddress) public view returns(bool) {
        return (users[_userId].userAddress == _grantedAddress || changeAddressAccess[_userId][_grantedAddress]);
    }

    function getGrantedChangeAddress(uint _userId) public view returns(address[] memory) {
        return changeAddressAddresses[_userId];
    }


}

// File: src/RDN/RDNTariffPos.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import {IRDNRegistry} from "./interfaces/IRDNRegistry.sol";
import {IRDNDistributor} from "./interfaces/IRDNDistributor.sol";
import {WithdrawAnyERC20Token} from "../Utils/WithdrawAnyERC20Token.sol";

contract RDNTariffPos is
    Context,
    AccessControlEnumerable,
    WithdrawAnyERC20Token
{

    event Turnover(
        uint indexed userId,
        address indexed token,
        uint turnoverAmount,
        uint normalizedTurnover
    );

    event RDNSubscriptionBonus(
        uint indexed userId,
        address indexed userAddress,
        uint bonusAmount
    );

    IERC20 public immutable token1;
    IERC20 public immutable token2;
    IRDNRegistry public immutable registry;

    mapping(uint => uint[2]) public tariffPrices;
    mapping(uint => mapping(uint => uint)) public subscriptionPackagePrices;
    uint public defaultSubscriptionPeriod = 30 * 24 * 60 * 60;
    uint public reward = 4800;
    mapping(uint => uint[2]) public usersPaid;

    mapping(uint => uint) public bonusCounter;
    mapping (uint => uint) public bonusAmountPerTariff;
    mapping (uint => bool) public bonusCandidatesExcluded;
    uint public bonusCandidatesCounter;
    uint public bonusCandidatesLimit;
    uint public bonusCandidatesLimitRDN;
    uint public bonusRequirement;

    bool public token2Points;

    bytes32 public constant CONFIG_ROLE = keccak256("CONFIG_ROLE");

    constructor(
        address _token1,
        address _token2,
        address _registry,
        address _admin
    ) WithdrawAnyERC20Token(_admin, false) {
        token1 = IERC20(_token1);
        token2 = IERC20(_token2);
        registry = IRDNRegistry(_registry);

        token2Points = false;

        tariffPrices[1] = [150 ether, 0];
        tariffPrices[2] = [300 ether, 3 ether];
        tariffPrices[3] = [600 ether, 6 ether];
        tariffPrices[4] = [900 ether, 12 ether];
        tariffPrices[5] = [1200 ether, 15 ether];
        tariffPrices[6] = [1500 ether, 21 ether];
        tariffPrices[7] = [1800 ether, 24 ether];

        subscriptionPackagePrices[1][30] = 24 ether;
        subscriptionPackagePrices[1][90] = 72 ether;
        subscriptionPackagePrices[1][180] = 144 ether;
        subscriptionPackagePrices[1][360] = 288 ether;

        subscriptionPackagePrices[2][30] = 42 ether;
        subscriptionPackagePrices[2][90] = 126 ether;
        subscriptionPackagePrices[2][180] = 252 ether;
        subscriptionPackagePrices[2][360] = 504 ether;

        subscriptionPackagePrices[3][30] = 42 ether;
        subscriptionPackagePrices[3][90] = 126 ether;
        subscriptionPackagePrices[3][180] = 252 ether;
        subscriptionPackagePrices[3][360] = 504 ether;

        subscriptionPackagePrices[4][30] = 42 ether;
        subscriptionPackagePrices[4][90] = 126 ether;
        subscriptionPackagePrices[4][180] = 252 ether;
        subscriptionPackagePrices[4][360] = 504 ether;

        subscriptionPackagePrices[5][30] = 42 ether;
        subscriptionPackagePrices[5][90] = 126 ether;
        subscriptionPackagePrices[5][180] = 252 ether;
        subscriptionPackagePrices[5][360] = 504 ether;

        subscriptionPackagePrices[6][30] = 42 ether;
        subscriptionPackagePrices[6][90] = 126 ether;
        subscriptionPackagePrices[6][180] = 252 ether;
        subscriptionPackagePrices[6][360] = 504 ether;

        subscriptionPackagePrices[7][30] = 42 ether;
        subscriptionPackagePrices[7][90] = 126 ether;
        subscriptionPackagePrices[7][180] = 252 ether;
        subscriptionPackagePrices[7][360] = 504 ether;

        bonusAmountPerTariff[1] = 12 ether;
        bonusAmountPerTariff[2] = 30 ether;
        bonusAmountPerTariff[3] = 30 ether;
        bonusAmountPerTariff[4] = 30 ether;
        bonusAmountPerTariff[5] = 30 ether;
        bonusAmountPerTariff[6] = 30 ether;
        bonusAmountPerTariff[7] = 30 ether;

        bonusCandidatesLimit = 10000;
        bonusCandidatesLimitRDN = 3000;
        bonusRequirement = 360;

        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(CONFIG_ROLE, _admin);
    }

    // todo             RDNLimit

    function activateTariff(uint _tariff) public {
        uint userId = registry.getUserIdByAddress(_msgSender());
        require(userId > 0, "Not registered in RDN");
        IRDNRegistry.User memory user = registry.getUser(userId);
        require(
            tariffPrices[_tariff][0] > 0 || tariffPrices[_tariff][1] > 0,
            "Invalid tariff"
        );
        require(_tariff > user.tariff, "New tariff is lower than current");

        // bonus counters
        if ((user.tariff == 0) && (userId > bonusCandidatesLimitRDN) && (bonusCandidatesCounter < bonusCandidatesLimit)) {
            bonusCandidatesCounter += 1;
            bonusCounter[userId] = 30;
        }

        uint[2] memory amountReq = calcActivationPrice(
            userId,
            user.tariff,
            _tariff
        );

        if (amountReq[0] > 0) {
            token1.transferFrom(_msgSender(), address(this), amountReq[0]);
            usersPaid[userId][0] += amountReq[0];
            IRDNDistributor distributor1 = IRDNDistributor(
                registry.getDistributor(address(token1))
            );
            uint rewardsAmount1 = (amountReq[0] * reward) / 10000;
            token1.approve(address(distributor1), rewardsAmount1);
            distributor1.distribute(_msgSender(), rewardsAmount1);
            emit Turnover(
                userId,
                address(token1),
                amountReq[0],
                amountReq[0] / 10
            );
        }
        if (amountReq[1] > 0) {
            token2.transferFrom(_msgSender(), address(this), amountReq[1]);
            usersPaid[userId][1] += amountReq[1];
            IRDNDistributor distributor2 = IRDNDistributor(
                registry.getDistributor(address(token2))
            );
            uint rewardsAmount2 = (amountReq[1] * reward) / 10000;
            token2.approve(address(distributor2), rewardsAmount2);
            distributor2.distribute(_msgSender(), rewardsAmount2);
            if (token2Points) {
                emit Turnover(
                    userId,
                    address(token2),
                    amountReq[1],
                    amountReq[1] / 10
                );
            }
        }
        if (user.tariff == 0) {
            registry.setActiveUntill(
                userId,
                block.timestamp + defaultSubscriptionPeriod
            );
        }
        registry.setTariff(userId, _tariff);
    }

    function prolongSubscription(uint _package) public {
        uint userId = registry.getUserIdByAddress(_msgSender());
        require(userId > 0, "Not registered in RDN");
        IRDNRegistry.User memory user = registry.getUser(userId);
        uint amount = _calcProlongPrice(user, _package); // gas savings
        require(amount > 0, "Package is not available");
        require(user.tariff > 0, "User tariff is 0");

        // bonus excluding
        if (
            ((userId <= bonusCandidatesLimitRDN) || (bonusCounter[userId] > 0)) &&
            user.activeUntill < block.timestamp
        ) {
            bonusCandidatesExcluded[userId] = true;
        }

        if (user.activeUntill == 0) {
            registry.setActiveUntill(
                userId,
                block.timestamp + _package * 60 * 60 * 24
            );
        } else {
            registry.setActiveUntill(
                userId,
                user.activeUntill + _package * 60 * 60 * 24
            );
        }

        token1.transferFrom(_msgSender(), address(this), amount);

        uint rewardsAmount = (amount * reward) / 10000;
        IRDNDistributor distributor1 = IRDNDistributor(
            registry.getDistributor(address(token1))
        );
        token1.approve(address(distributor1), rewardsAmount);
        distributor1.distribute(_msgSender(), rewardsAmount);

        emit Turnover(userId, address(token1), amount, amount / 10);

        // bonus counter / execution
        (, uint bonusAmount) = estimateBonus(userId);
        // if ((reqBefore > 0) && (reqBefore < bonusRequirement)) {
        if (bonusAmount > 0) {
            bonusCounter[userId] += _package;
            if (bonusCounter[userId] >= bonusRequirement) {
                token2.transfer(user.userAddress, bonusAmount);
                emit RDNSubscriptionBonus(userId, user.userAddress, bonusAmount);
            }
        }
    }

    function calcActivationPrice(
        uint _userId,
        uint _tariffFrom,
        uint _tariffTo
    ) public view returns (uint[2] memory) {
        uint[2] memory price;
        // gas savings
        uint[2] memory _usersPaid = usersPaid[_userId];
        uint[2] memory _tariffPrices = tariffPrices[_tariffTo];

        if (_usersPaid[0] > 0 || _usersPaid[1] > 0) {
            if (_tariffPrices[0] > _usersPaid[0]) {
                price[0] = _tariffPrices[0] - _usersPaid[0];
            } else {
                price[0] = 0;
            }
            if (_tariffPrices[1] > _usersPaid[1]) {
                price[1] = _tariffPrices[1] - _usersPaid[1];
            } else {
                price[1] = 0;
            }
        } else {
            price[0] = _tariffPrices[0] - tariffPrices[_tariffFrom][0];
            price[1] = _tariffPrices[1] - tariffPrices[_tariffFrom][1];
        }

        if (
            _tariffFrom > 0 &&
            (subscriptionPackagePrices[_tariffTo][30] >
                subscriptionPackagePrices[_tariffFrom][30]) &&
            registry.isActive(_userId)
        ) {
            uint remaindSeconds = registry.getActiveUntill(_userId) - block.timestamp;
            uint diffSecondPrice = 
                (
                    subscriptionPackagePrices[_tariffTo][30] - 
                    subscriptionPackagePrices[_tariffFrom][30]
                ) /
                (30 * 24 * 60 * 60);
            price[0] += remaindSeconds * diffSecondPrice;
        }

        return price;
    }

    function calcProlongPrice(uint _userId, uint _package)
        public
        view
        returns (uint)
    {
        IRDNRegistry.User memory user = registry.getUser(_userId);
        return _calcProlongPrice(user, _package);
    }

    function _calcProlongPrice(IRDNRegistry.User memory _user, uint _package)
        private
        view
        returns (uint)
    {
        uint remaindSeconds = (block.timestamp < _user.activeUntill)
            ? (_user.activeUntill - block.timestamp)
            : 0;
        // should remain not more than 13 months after prolongation
        if ((_package * 24 * 60 * 60 + remaindSeconds) > (390 * 24 * 60 * 60)) {
            return 0;
        }
        return subscriptionPackagePrices[_user.tariff][_package];
    }

    function estimateBonus(uint _userId) public view returns(uint requirement, uint bonusAmount) {
        uint counter = bonusCounter[_userId];
        uint req = bonusRequirement;

        if (_userId <= bonusCandidatesLimitRDN) {
            counter += 30;
        }

        if (
            !registry.isActive(_userId) ||
            bonusCandidatesExcluded[_userId] || 
            (counter == 0) ||
            (counter >= req)
        ) {
            return (0, 0);
        }

        uint tariff = registry.getTariff(_userId);

        return ((req - counter), bonusAmountPerTariff[tariff]);
    }

    function getTariffPrice(uint _tariff)
        public
        view
        returns (uint[2] memory)
    {
        return tariffPrices[_tariff];
    }

    function getSubscriptionPackagePrice(uint _tariff, uint _package)
        public
        view
        returns (uint) 
    {
        return subscriptionPackagePrices[_tariff][_package];
    }

    function setReward(uint _reward) public onlyRole(CONFIG_ROLE) {
        reward = _reward;
    }

    function setTariffPrice(
        uint _tariff,
        uint _price1,
        uint _price2
    ) public onlyRole(CONFIG_ROLE) {
        tariffPrices[_tariff] = [_price1, _price2];
    }

    function setDefaultSupscriptionPeriod(uint _value) public onlyRole(CONFIG_ROLE)
    {
        defaultSubscriptionPeriod = _value;
    }

    function setBonusAmount(uint _tariff, uint _bonus) public onlyRole(CONFIG_ROLE) 
    {
        bonusAmountPerTariff[_tariff] = _bonus;
    }

    function setBonusCandidatesLimit(uint _limit) public onlyRole(CONFIG_ROLE)
    {
        bonusCandidatesLimit = _limit;
    }

    function setBonusCandidatesLimitRDN(uint _limit) public onlyRole(CONFIG_ROLE) 
    {
        bonusCandidatesLimitRDN = _limit;
    }

    function setBonusRequirement(uint _req) public onlyRole(CONFIG_ROLE) 
    {
        require(_req > bonusRequirement, "Must be greater");
        bonusRequirement = _req;
    }

    function setToken2Pioints(bool _token2Points) public onlyRole(CONFIG_ROLE) 
    {
        token2Points = _token2Points;
    }

    function setBonusCounter(uint _userId, uint _counter) public onlyRole(CONFIG_ROLE) {
        if ((bonusCounter[_userId] == 0) && (_counter > 0) && (_userId > bonusCandidatesLimitRDN)) {
            bonusCandidatesCounter += 1;
        }
        bonusCounter[_userId] = _counter;
    }
}


// File: src/RDN/RDNTariffPosBonusStorage.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

contract RDNTariffPosBonusStorage is AccessControlEnumerable {

    mapping(uint => uint) public counter;
    mapping(uint => bool) public candidates;
    uint public candidatesCount;

    bytes32 public constant BONUSSTORAGE_WRITE_ROLE = keccak256("BONUSSTORAGE_WRITE_ROLE");

    constructor (address _admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(BONUSSTORAGE_WRITE_ROLE, _admin);
    }

    function setCounter(uint _userId, uint _value) public onlyRole(BONUSSTORAGE_WRITE_ROLE) {
        counter[_userId] = _value;
    }

    function addCounter(uint _userId, uint _value) public onlyRole(BONUSSTORAGE_WRITE_ROLE) {
        counter[_userId] += _value;
    }

    function setCandidate(uint _userId, bool _value) public onlyRole(BONUSSTORAGE_WRITE_ROLE) {
        if ((candidates[_userId] == false) && (_value == true)) {
            candidatesCount += 1;
        }
        if ((candidates[_userId] == true) && (_value == false)) {
            candidatesCount -= 1;
        }
        candidates[_userId] = _value;
    }

    function getCounter(uint _userId) public view returns(uint) {
        return counter[_userId];
    }

    function isCandidate(uint _userId) public view returns(bool) {
        return candidates[_userId];
    }

    function getCandidatesCount() public view returns(uint) {
        return candidatesCount;
    }


}

// File: src/RDN/RDNTariffPosV2.sol
pragma solidity ^0.8.17;
// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import {IRDNRegistry} from "./interfaces/IRDNRegistry.sol";
import {IRDNDistributor} from "./interfaces/IRDNDistributor.sol";
import {WithdrawAnyERC20Token} from "../Utils/WithdrawAnyERC20Token.sol";
import {IRDNTariffPosBonusStorage} from "./interfaces/IRDNTariffPosBonusStorage.sol";

contract RDNTariffPosV2 is
    Context,
    AccessControlEnumerable,
    WithdrawAnyERC20Token
{

    event Turnover(
        uint indexed userId,
        address indexed token,
        uint turnoverAmount,
        uint normalizedTurnover
    );

    event RDNSubscriptionBonus(
        uint indexed userId,
        address indexed userAddress,
        uint bonusAmount
    );

    IERC20 public token1;
    IERC20 public token2;
    IRDNRegistry public immutable registry;
    IRDNTariffPosBonusStorage public bonusStorage;

    mapping(uint => uint[2]) public tariffPrices;
    mapping(uint => mapping(uint => uint)) public subscriptionPackagePrices;
    uint public defaultSubscriptionPeriod = 30 * 24 * 60 * 60;
    uint public reward = 4800;
    mapping(uint => uint[2]) public usersPaid;

    mapping (uint => uint) public bonusAmountPerTariff;
    uint public bonusCandidatesLimit;
    uint public bonusCandidatesLimitRDN;
    uint public bonusRequirement;

    bool public token2Points;

    bytes32 public constant CONFIG_ROLE = keccak256("CONFIG_ROLE");

    bool public paused;

    constructor(
        address _token1,
        address _token2,
        address _registry,
        address _admin
    ) WithdrawAnyERC20Token(_admin, false) {
        token1 = IERC20(_token1);
        token2 = IERC20(_token2);
        registry = IRDNRegistry(_registry);

        token2Points = false;

        tariffPrices[1] = [150 ether, 0];
        tariffPrices[2] = [300 ether, 3 ether];
        tariffPrices[3] = [600 ether, 6 ether];
        tariffPrices[4] = [900 ether, 12 ether];
        tariffPrices[5] = [1200 ether, 15 ether];
        tariffPrices[6] = [1500 ether, 21 ether];
        tariffPrices[7] = [1800 ether, 24 ether];

        subscriptionPackagePrices[1][30] = 24 ether;
        subscriptionPackagePrices[1][90] = 72 ether;
        subscriptionPackagePrices[1][180] = 144 ether;
        subscriptionPackagePrices[1][360] = 288 ether;

        subscriptionPackagePrices[2][30] = 42 ether;
        subscriptionPackagePrices[2][90] = 126 ether;
        subscriptionPackagePrices[2][180] = 252 ether;
        subscriptionPackagePrices[2][360] = 504 ether;

        subscriptionPackagePrices[3][30] = 42 ether;
        subscriptionPackagePrices[3][90] = 126 ether;
        subscriptionPackagePrices[3][180] = 252 ether;
        subscriptionPackagePrices[3][360] = 504 ether;

        subscriptionPackagePrices[4][30] = 42 ether;
        subscriptionPackagePrices[4][90] = 126 ether;
        subscriptionPackagePrices[4][180] = 252 ether;
        subscriptionPackagePrices[4][360] = 504 ether;

        subscriptionPackagePrices[5][30] = 42 ether;
        subscriptionPackagePrices[5][90] = 126 ether;
        subscriptionPackagePrices[5][180] = 252 ether;
        subscriptionPackagePrices[5][360] = 504 ether;

        subscriptionPackagePrices[6][30] = 42 ether;
        subscriptionPackagePrices[6][90] = 126 ether;
        subscriptionPackagePrices[6][180] = 252 ether;
        subscriptionPackagePrices[6][360] = 504 ether;

        subscriptionPackagePrices[7][30] = 42 ether;
        subscriptionPackagePrices[7][90] = 126 ether;
        subscriptionPackagePrices[7][180] = 252 ether;
        subscriptionPackagePrices[7][360] = 504 ether;

        bonusAmountPerTariff[1] = 12 ether;
        bonusAmountPerTariff[2] = 30 ether;
        bonusAmountPerTariff[3] = 30 ether;
        bonusAmountPerTariff[4] = 30 ether;
        bonusAmountPerTariff[5] = 30 ether;
        bonusAmountPerTariff[6] = 30 ether;
        bonusAmountPerTariff[7] = 30 ether;

        bonusCandidatesLimit = 10000;
        bonusCandidatesLimitRDN = 3000;
        bonusRequirement = 360;

        paused = true;

        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(CONFIG_ROLE, _admin);
    }

    // todo             RDNLimit

    function activateTariff(uint _tariff) public {
        require(paused == false, "RDNTariffPosV2: paused");
        uint userId = registry.getUserIdByAddress(_msgSender());
        require(userId > 0, "Not registered in RDN");
        IRDNRegistry.User memory user = registry.getUser(userId);
        require(
            tariffPrices[_tariff][0] > 0 || tariffPrices[_tariff][1] > 0,
            "Invalid tariff"
        );
        require(_tariff > user.tariff, "New tariff is lower than current");

        // bonus counters
        if ((user.tariff == 0) && (bonusStorage.getCandidatesCount() < bonusCandidatesLimit)) {
            bonusStorage.setCounter(userId, 30);
            bonusStorage.setCandidate(userId, true);
        }

        uint[2] memory amountReq = calcActivationPrice(
            userId,
            user.tariff,
            _tariff
        );

        uint[2] memory amountReqTariffOnly = calcActivationPriceTariffOnly(userId, user.tariff, _tariff);

        if (amountReq[0] > 0) {
            token1.transferFrom(_msgSender(), address(this), amountReq[0]);
            if (usersPaid[userId][0] == 0) {
                usersPaid[userId][0] += tariffPrices[_tariff][0];
            } else {
                usersPaid[userId][0] += amountReqTariffOnly[0];
            }
            IRDNDistributor distributor1 = IRDNDistributor(
                registry.getDistributor(address(token1))
            );
            uint rewardsAmount1 = (amountReq[0] * reward) / 10000;
            token1.approve(address(distributor1), rewardsAmount1);
            distributor1.distribute(_msgSender(), rewardsAmount1);
            emit Turnover(
                userId,
                address(token1),
                amountReq[0],
                amountReq[0] / 10
            );
        }
        if (amountReq[1] > 0) {
            token2.transferFrom(_msgSender(), address(this), amountReq[1]);
            if (usersPaid[userId][1] == 0) {
                usersPaid[userId][1] += tariffPrices[_tariff][1];
            } else {
                usersPaid[userId][1] += amountReqTariffOnly[1];
            }
            IRDNDistributor distributor2 = IRDNDistributor(
                registry.getDistributor(address(token2))
            );
            uint rewardsAmount2 = (amountReq[1] * reward) / 10000;
            token2.approve(address(distributor2), rewardsAmount2);
            distributor2.distribute(_msgSender(), rewardsAmount2);
            if (token2Points) {
                emit Turnover(
                    userId,
                    address(token2),
                    amountReq[1],
                    amountReq[1] / 10
                );
            }
        }
        if (user.tariff == 0) {
            registry.setActiveUntill(
                userId,
                block.timestamp + defaultSubscriptionPeriod
            );
        }
        registry.setTariff(userId, _tariff);
    }

    function prolongSubscription(uint _package) public {
        require(paused == false, "RDNTariffPosV2: paused");
        uint userId = registry.getUserIdByAddress(_msgSender());
        require(userId > 0, "Not registered in RDN");
        IRDNRegistry.User memory user = registry.getUser(userId);
        uint amount = _calcProlongPrice(user, _package); // gas savings
        require(amount > 0, "Package is not available");
        require(user.tariff > 0, "User tariff is 0");


        // bonus counter / execution
        uint bonusCounter = bonusStorage.getCounter(userId); // gas savings
        if (user.activeUntill < block.timestamp) {
            if (
                ((userId <= bonusCandidatesLimitRDN) && (bonusCounter < (bonusRequirement - 30)))
                ||
                ((userId > bonusCandidatesLimitRDN) && (bonusCounter < bonusRequirement ))
            ) {
                bonusStorage.setCounter(userId, 0);
            }
        }

        (uint requirement, uint bonusAmount) = estimateBonus(userId);
        // if ((reqBefore > 0) && (reqBefore < bonusRequirement)) {
        if (bonusAmount > 0) {
            bonusStorage.addCounter(userId, _package);
            // if (bonusCounter[userId] >= bonusRequirement) {
            if (requirement <= _package) {
                token2.transfer(user.userAddress, bonusAmount);
                emit RDNSubscriptionBonus(userId, user.userAddress, bonusAmount);
            }
        }

        if (user.activeUntill < block.timestamp) {
            registry.setActiveUntill(
                userId,
                block.timestamp + _package * 60 * 60 * 24
            );
        } else {
            registry.setActiveUntill(
                userId,
                user.activeUntill + _package * 60 * 60 * 24
            );
        }

        token1.transferFrom(_msgSender(), address(this), amount);

        uint rewardsAmount = (amount * reward) / 10000;
        IRDNDistributor distributor1 = IRDNDistributor(
            registry.getDistributor(address(token1))
        );
        token1.approve(address(distributor1), rewardsAmount);
        distributor1.distribute(_msgSender(), rewardsAmount);

        emit Turnover(userId, address(token1), amount, amount / 10);

    }

    function calcActivationPrice(
        uint _userId,
        uint _tariffFrom,
        uint _tariffTo
    ) public view returns (uint[2] memory) {
        uint[2] memory price = calcActivationPriceTariffOnly(_userId, _tariffFrom, _tariffTo);
        
        if (
            _tariffFrom > 0 &&
            (subscriptionPackagePrices[_tariffTo][30] >
                subscriptionPackagePrices[_tariffFrom][30]) &&
            registry.isActive(_userId)
        ) {
            uint remaindSeconds = registry.getActiveUntill(_userId) - block.timestamp;
            uint diffSecondPrice = 
                (
                    subscriptionPackagePrices[_tariffTo][30] - 
                    subscriptionPackagePrices[_tariffFrom][30]
                ) /
                (30 * 24 * 60 * 60);
            price[0] += remaindSeconds * diffSecondPrice;
        }

        return price;
    }

    function calcActivationPriceTariffOnly(
        uint _userId,
        uint _tariffFrom,
        uint _tariffTo
    ) public view returns (uint[2] memory) {
        uint[2] memory price;
        // gas savings
        uint[2] memory _usersPaid = usersPaid[_userId];
        uint[2] memory _tariffPrices = tariffPrices[_tariffTo];

        if (_usersPaid[0] > 0 || _usersPaid[1] > 0) {
            if (_tariffPrices[0] > _usersPaid[0]) {
                price[0] = _tariffPrices[0] - _usersPaid[0];
            } else {
                price[0] = 0;
            }
            if (_tariffPrices[1] > _usersPaid[1]) {
                price[1] = _tariffPrices[1] - _usersPaid[1];
            } else {
                price[1] = 0;
            }
        } else {
            price[0] = _tariffPrices[0] - tariffPrices[_tariffFrom][0];
            price[1] = _tariffPrices[1] - tariffPrices[_tariffFrom][1];
        }
        return price;
    }

    function calcProlongPrice(uint _userId, uint _package)
        public
        view
        returns (uint)
    {
        IRDNRegistry.User memory user = registry.getUser(_userId);
        return _calcProlongPrice(user, _package);
    }

    function _calcProlongPrice(IRDNRegistry.User memory _user, uint _package)
        private
        view
        returns (uint)
    {
        uint remaindSeconds = (block.timestamp < _user.activeUntill)
            ? (_user.activeUntill - block.timestamp)
            : 0;
        // should remain not more than 13 months after prolongation
        if ((_package * 24 * 60 * 60 + remaindSeconds) > (390 * 24 * 60 * 60)) {
            return 0;
        }
        return subscriptionPackagePrices[_user.tariff][_package];
    }

    function estimateBonus(uint _userId) public view returns(uint requirement, uint bonusAmount) {
        uint counter = bonusStorage.getCounter(_userId);
        uint req = bonusRequirement;

        if ((_userId > bonusCandidatesLimitRDN) && !bonusStorage.isCandidate(_userId)) {
            return(0, 0);
        }

        if (token2.balanceOf(address(this)) < 30 ether) {
            return (0, 0);
        }

        if (_userId <= bonusCandidatesLimitRDN) {
            counter += 30;
        }

        if ((counter >= req)) {
            return (0, 0);
        }

        if (!registry.isActive(_userId)) {
            counter = 0;
        }

        uint tariff = registry.getTariff(_userId);

        return ((req - counter), bonusAmountPerTariff[tariff]);
    }

    function getTariffPrice(uint _tariff)
        public
        view
        returns (uint[2] memory)
    {
        return tariffPrices[_tariff];
    }

    function getSubscriptionPackagePrice(uint _tariff, uint _package)
        public
        view
        returns (uint) 
    {
        return subscriptionPackagePrices[_tariff][_package];
    }

    function setReward(uint _reward) public onlyRole(CONFIG_ROLE) {
        reward = _reward;
    }

    function setTokens(address _token1, address _token2) public onlyRole(CONFIG_ROLE) {
        token1 = IERC20(_token1);
        token2 = IERC20(_token2);
    }

    function setTariffPrice(
        uint _tariff,
        uint _price1,
        uint _price2
    ) public onlyRole(CONFIG_ROLE) {
        tariffPrices[_tariff] = [_price1, _price2];
    }

    function setDefaultSupscriptionPeriod(uint _value) public onlyRole(CONFIG_ROLE)
    {
        defaultSubscriptionPeriod = _value;
    }

    function setBonusAmount(uint _tariff, uint _bonus) public onlyRole(CONFIG_ROLE) 
    {
        bonusAmountPerTariff[_tariff] = _bonus;
    }

    function setBonusCandidatesLimit(uint _limit) public onlyRole(CONFIG_ROLE)
    {
        bonusCandidatesLimit = _limit;
    }

    function setBonusCandidatesLimitRDN(uint _limit) public onlyRole(CONFIG_ROLE) 
    {
        bonusCandidatesLimitRDN = _limit;
    }

    function setBonusRequirement(uint _req) public onlyRole(CONFIG_ROLE) 
    {
        require(_req > bonusRequirement, "Must be greater");
        bonusRequirement = _req;
    }

    function setToken2Pioints(bool _token2Points) public onlyRole(CONFIG_ROLE) 
    {
        token2Points = _token2Points;
    }

    function setStorage(address _storage) public onlyRole(CONFIG_ROLE) {
        bonusStorage = IRDNTariffPosBonusStorage(_storage);
    }

    function getUsersPaid(uint _userId) public view returns(uint[2] memory) {
        return usersPaid[_userId];
    }

    function setPaused(bool _paused) public onlyRole(CONFIG_ROLE) {
        paused = _paused;
    }
}


// File: src/RDN/RDNWaitlist.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

// transfer/withdraw locked Tokens
// unlock tokens
// destroy contract / close addUser

contract RDNWaitlist is AccessControlEnumerable {
    // bytes32 public constant USERADD_ROLE = keccak256("USERADD_ROLE");

    uint[] public tokens;

    mapping (uint => address) public addressByToken;
    mapping (address => uint) public tokenByAddress;

    constructor (address _admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
    }

    function register(uint _token) public {
        require(addressByToken[_token] == address(0), "Token already registered");
        require(tokenByAddress[msg.sender] == 0, "Address already registered") ;
        addressByToken[_token] = msg.sender;
        tokenByAddress[msg.sender] = _token;
        tokens.push(_token);
    }

    function getAddressByToken(uint _token) public view returns(address) {
        return addressByToken[_token];
    }

    function getTokenByAddress(address _userAddress) public view returns(uint) {
        return tokenByAddress[_userAddress];
    }

    function getAllTokens() public view returns(uint[] memory) {
        return tokens;
    }

}

// File: src/Treasury/Example.sol
pragma solidity ^0.8.17;

import "src/Treasury/TreasuryHelper.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

contract Example is AccessControlEnumerable, TreasuryHelper{
    struct Counter {
        uint256 counter;
    }

    //uint256 private oldCounter;
    uint256 public newCounter;

    constructor(address _treasury, address _registry, uint256 _ownerId) TreasuryHelper(_treasury, _registry, _ownerId) {
    }

    function doSomething(uint256 argsFee) external transferTransactionFee(argsFee) {
        //oldCounter += 1;
        Counter memory _counter = Counter({counter: 6});
        newCounter = _counter.counter + 10;
    }
}

// File: src/Treasury/FifthExample.sol
pragma solidity ^0.8.17;

import "src/Treasury/TreasuryHelper.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

contract FifthExample is AccessControlEnumerable, TreasuryHelper{
    struct Counter {
        uint256 counter;
    }

    //uint256 private oldCounter;
    uint256 public newCounter;

    constructor(address _treasury, address _registry, uint256 _ownerId) TreasuryHelper(_treasury, _registry, _ownerId) {
    }

    function doSomething(uint256[] calldata arr, uint256 argsFee) external transferTransactionFee(argsFee) {
        //oldCounter += 1;
        Counter memory _counter = Counter({counter: arr[1]});
        newCounter = _counter.counter + 10;
    }
}

// File: src/Treasury/FourthExample.sol
pragma solidity ^0.8.17;

import "src/Treasury/TreasuryHelper.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

contract FourthExample is AccessControlEnumerable, TreasuryHelper{
    struct Counter {
        uint256 counter;
    }

    mapping(string => uint256) private counterChange;
    uint256 public newCounter;

    constructor(address _treasury, address _registry, uint256 _ownerId) TreasuryHelper(_treasury, _registry, _ownerId) {
    }

    function doSomething(uint256 argsFee) external transferTransactionFee(argsFee) {
        Counter memory _counter = Counter({counter: 6});
        counterChange["str"] = _counter.counter;
    }
}

// File: src/Treasury/SecondExample.sol
pragma solidity ^0.8.17;

import "src/Treasury/TreasuryHelper.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

contract SecondExample is AccessControlEnumerable, TreasuryHelper{
    struct Counter {
        uint256 counter;
    }

    mapping(string => uint256) private counterChange;
    uint256 public newCounter;

    constructor(address _treasury, address _registry, uint256 _ownerId) TreasuryHelper(_treasury, _registry, _ownerId) {
    }

    function doSomething(string calldata str, uint256 argsFee) external transferTransactionFee(argsFee) {
        Counter memory _counter = Counter({counter: 6});
        counterChange[str] = _counter.counter;
    }

    /*function doSomethingNew(string[] calldata arr, uint256) external transferTransactionFee {
        Counter memory _counter = Counter({counter: 6});
        counterChange[arr[0]] = _counter.counter;
    }
     /*
    function doSomethingNewSec() external transferTransactionFee {
        Counter memory _counter = Counter({counter: 6});
        counterChange["sec"] = _counter.counter;
    }

    function doNew(string[6] calldata arr) external transferTransactionFee {
        Counter memory _counter = Counter({counter: 6});
        counterChange[arr[2]] = _counter.counter;
    }

    function doNewSec(uint256[6] calldata arr) external transferTransactionFee {
        Counter memory _counter = Counter({counter: arr[3]});
        counterChange["new"] = _counter.counter;
    }*/
}

// File: src/Treasury/ThirdExample.sol
pragma solidity ^0.8.17;

import "src/Treasury/TreasuryHelper.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

contract ThirdExample is AccessControlEnumerable, TreasuryHelper {
    struct Counter {
        uint256 counter;
    }

    mapping(string => uint256) private counterChange;
    uint256 public newCounter;

    constructor(address _treasury, address _registry, uint256 _ownerId) TreasuryHelper(_treasury, _registry, _ownerId) {
    }

    function doSomething(string[] calldata arr, uint256 argsFee) external transferTransactionFee(argsFee) {
        Counter memory _counter = Counter({counter: 6});
        counterChange[arr[0]] = _counter.counter;
    }
}

// File: src/Treasury/Treasury.sol
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

contract Treasury is AccessControlEnumerable {
    bytes32 public constant WITHDRAW_ROLE = keccak256("WITHDRAW_ROLE");
    
    event Withdrawn(uint256 indexed amount, address indexed recipient);

    function initialize(address _user) external {
        _setupRole(DEFAULT_ADMIN_ROLE, _user);
        _setupRole(WITHDRAW_ROLE, _user);
    }

    function contribute() external payable {
        require(msg.value > 0.1 ether);
    }

    function withdraw(uint256 amount, address payable recipient) external onlyRole(WITHDRAW_ROLE) {
        require(address(this).balance > 0, "zero balance");
        recipient.transfer(amount);
        emit Withdrawn(amount, recipient);
    }
}

// File: src/Treasury/TreasuryFactory.sol
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/proxy/Clones.sol";
import "src/Treasury/Treasury.sol";
//import "hardhat/console.sol";

contract TreasuryFactory {
    event NewTreasury(address treasury);

    function createTreasury(address _treasuryBase) public {
        address treasury = Clones.clone(_treasuryBase);
        emit NewTreasury(treasury);
    }
}

// File: src/Treasury/TreasuryHelper.sol
pragma solidity ^0.8.17;

import "src/Treasury/Treasury.sol";
//import "hardhat/console.sol";
import "src/RDN/RDNOwnable.sol";

contract TreasuryHelper is RDNOwnable {
    uint256 public constant CONSTANT_FEE = 21000;
    uint256 public constant TRANSFER_FEE = 27102;  
   
    uint256 public maxArgsFee;

    Treasury private treasury;

    constructor(address _treasury, address _registry, uint256 _ownerId) {
        treasury = Treasury(_treasury);
        initRDNOwnable(_registry, _ownerId);
    }
    
    modifier transferTransactionFee(uint256 gasEstimation) {
        uint256 startGas = gasleft();
        _;
        uint256 gasUsed = startGas - gasleft();
        //console.log("gasUsed: ", gasUsed);
        //console.log("gasUsed + args: ", gasUsed + maxArgsFee);
        if (gasEstimation > gasUsed + maxArgsFee) {
            //console.log(true);
            treasury.withdraw((gasUsed + CONSTANT_FEE + TRANSFER_FEE + maxArgsFee) * tx.gasprice, payable(msg.sender));
        } else {
            treasury.withdraw((gasEstimation + CONSTANT_FEE + TRANSFER_FEE) * tx.gasprice, payable(msg.sender));
        }
    }

    function setMaxArgsFee(uint256 fee) external onlyRDNOwner(msg.sender) {
        maxArgsFee = fee;
    }
}

// File: src/Utils/IWithdrawAnyERC20Token.sol
pragma solidity 0.8.17;

// SPDX-License-Identifier: MIT

interface IWithdrawAnyERC20Token {
    
    function withdrawAnyERC20Token(address _token, address _target, uint _amount) external;

}

// File: src/Utils/WithdrawAnyERC20Token.sol
pragma solidity 0.8.17;

// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// interface IWithdrawAnyERC20Token {
    
//     function withdrawAnyERC20Token(address _token, address _target, uint _amount) external;

// }

contract WithdrawAnyERC20Token is AccessControlEnumerable {
    bytes32 public constant WITHDRAWANY_ROLE = keccak256("WITHDRAWANY_ROLE");

    constructor (address _admin, bool _isDefaultAdminRole) {
        if (_isDefaultAdminRole) {
            _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        }
        _setupRole(WITHDRAWANY_ROLE, _admin);
    }

    function withdrawAnyERC20Token(address _token, address _target, uint _amount) public onlyRole(WITHDRAWANY_ROLE) {
        IERC20(_token).transfer(_target, _amount);
    }

}

// File: src/WithdrawMaster.sol
pragma solidity 0.8.17;
// SPDX-License-Identifier: MIT

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "./Utils/IWithdrawAnyERC20Token.sol";
import "./Utils/WithdrawAnyERC20Token.sol";

contract WithdrawMaster is AccessControlEnumerable, WithdrawAnyERC20Token {
    address[] public Contracts;
    address[] public Tokens;

    bytes32 public constant WITHDRAW_ROLE = keccak256("WITHDRAW_ROLE");
    bytes32 public constant CONFIG_ROLE = keccak256("CONFIG_ROLE");

    constructor (address _admin) WithdrawAnyERC20Token(_admin, false) {
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        _setupRole(WITHDRAW_ROLE, _admin);
        _setupRole(CONFIG_ROLE, _admin);
    }

    function withdraw(address _target) public onlyRole(WITHDRAW_ROLE) {
        uint contractsCount = Contracts.length;
        uint tokensCount = Tokens.length;
        for (uint i = 0; i < contractsCount; i++) {
            for (uint j = 0; j < tokensCount; j++) {
                uint balance = IERC20(Tokens[j]).balanceOf(Contracts[i]);
                if (balance > 0) {
                    IWithdrawAnyERC20Token(Contracts[i]).withdrawAnyERC20Token(Tokens[j], _target, balance);
                }
            }
        }
    }

    function setContracts(address[] memory _contracts) public onlyRole(CONFIG_ROLE) {
        Contracts = _contracts;
    }

    function setTokens(address[] memory _tokens) public onlyRole(CONFIG_ROLE) {
        Tokens = _tokens;
    }
}
