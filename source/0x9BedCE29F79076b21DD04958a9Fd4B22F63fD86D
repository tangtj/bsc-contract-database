{"Freebie.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.6;\n\nimport \"./SafeMath.sol\";\nimport \"./IUniswapV2Router02.sol\";\n\ninterface IBEP20 {\n    function totalSupply() external view returns(uint256);\n    function balanceOf(address _owner)external view returns(uint256);\n    function transfer(address _to, uint256 _value)external returns(bool);\n    function approve(address _spender, uint256 _value)external returns(bool);\n    function transferFrom(address _from, address _to, uint256 _value)external returns(bool);    \n    function allowance(address _owner, address _spender)external view returns(uint256);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);    \n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n}\n\ncontract MyFeebie is IBEP20 {\n    using SafeMath for uint256;\n    address payable public creator;\n    mapping(address =\u003e uint256) private _balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n\n    string public name = \"Freebie Life Finance\";\n    string public symbol = \"FRB\";\n    uint public decimals = 18;\n    uint256 public _totalSupply;\n\n//for presale \n    uint256 public presaleAmout;\n    uint256 public totalInvestors;\n    bool public startPresale;\n    bool public endPresale;\n    uint256 hardCap = 525000000000000000000; //525 BNB\n    mapping(address =\u003e uint256) public investors;\n    bool public liveProject;\n\n    IUniswapV2Router02 _pancakeRouter;\n\n    uint256 public holders;\n    address[] public allAddresses;\n\n    mapping(address =\u003e bool) private _excludedFees;\n    address private vault;\n    address public marketingWl;\n    address private devWl;\n    address private forLP;\n\n    uint256 public balanceVault;\n    uint256 public balanceFreebie;\n    uint256 public deadlineFreebie;\n    uint256 public currentFreebieNo;\n    address public activatorFreebie;\n    mapping(address =\u003e bool) public excludeFreebie;\n\n    address[] public currentWinners50;\n    address[] public claimedAddresses;\n    uint256[] public AllrandomeNumbers;\n\n    modifier ownerOnly {\n        if (msg.sender == creator) {\n            _;\n        }\n    }\n\n    constructor() public{\n        creator = msg.sender;\n        _totalSupply = 1000000000000000000000000;\n        _balances[creator] = _totalSupply;\n        holders = 1;\n        allAddresses.push(creator);\n        vault = address(this);\n        marketingWl = 0x2fB48b3E3973d0a874658B000a77E6fD446463dE;\n        devWl = 0x5ff576c3f3CabD43309603843BF8E2B636F9253e; \n // to where LP will go\n        forLP = 0x000000000000000000000000000000000000dEaD;\n        _pancakeRouter = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        _excludedFees[creator]=true;\n        _excludedFees[vault]=true;\n        _excludedFees[marketingWl]=true;\n        _excludedFees[devWl]=true;\n\n        _transfer(creator, vault,       875000000000000000000000);\n        _transfer(creator, marketingWl, 100000000000000000000000);\n        _transfer(creator, devWl,        25000000000000000000000);\n\n        excludeFreebie[creator]=true;\n        excludeFreebie[vault]=true;\n        excludeFreebie[marketingWl]=true;\n        excludeFreebie[devWl]=true;  \n    }\n\n    function totalSupply() external override view returns(uint256){\n        return _totalSupply;\n    }\n\n    function balanceOf(address _owner)external override view returns(uint256 _returnedBalance){\n        _returnedBalance = _balances[_owner];\n        return _returnedBalance;\n    }\n\n    function _transfer(address _from, address _to, uint256 amount) internal {\n      require(_from != address(0), \"BEP20: Transfer from zero address\");\n      require(_to != address(0), \"BEP20: Transfer to the zero address\");\n      if (_excludedFees[_from]) {\n          _balances[_from] = _balances[_from].sub(amount);\n          _balances[_to] = _balances[_to].add(amount);\n          emit Transfer(_from, _to, amount);\n          if (_balances[_from] == 0 \u0026\u0026 amount \u003e 0) holders = holders.sub(1);\n          if (_balances[_to].sub(amount) == 0) holders = holders.add(1);\n          bool OnAddressList;\n          for (uint i = 0; i \u003c allAddresses.length; i++) {\n              if (allAddresses[i] == _to) OnAddressList = true;\n            } \n            if (OnAddressList == false) allAddresses.push(_to);\n      } \n      if (_excludedFees[_from] == false) {\n      uint256 fee;\n      uint256 rest;\n      fee = amount.div(20); // fee is 5% its 1/20 from all amount\n      rest = amount.sub(fee);\n        _balances[_from] = _balances[_from].sub(rest);\n        _balances[_to] = _balances[_to].add(rest);       \n        _balances[_from] = _balances[_from].sub(fee);\n        _balances[vault] = _balances[vault].add(fee);\n\n        emit Transfer(_from, _to, rest); \n        emit Transfer(_from, vault, fee);\n\n        //update addresses list\n        bool OnAddressList;\n        for (uint i = 0; i \u003c allAddresses.length; i++) {\n              if (allAddresses[i] == _to) OnAddressList = true;\n            } \n            if (OnAddressList == false) allAddresses.push(_to);\n        //add fee to vault balance\n        balanceVault = balanceVault.add(fee);\n        //update holders counter\n        if (_balances[_from] == 0 \u0026\u0026 amount \u003e 0) holders = holders.sub(1);\n        if (_balances[_to].sub(rest) == 0 ) holders = holders.add(1);\n      }\n    }\n\n    function transfer(address _to, uint256 _value)external override returns(bool){\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n      require(owner != address(0), \"BEP20: approve from the zero address\");\n      require(spender != address(0), \"BEP20: approve to the zero address\");\n      _allowances[owner][spender] = amount;\n      emit Approval(owner, spender, amount);\n    }\n\n    function approve(address _spender, uint256 _value)external override returns(bool success) {\n        _approve(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value)external override returns(bool success){\n        _transfer(_from, _to, _value);\n        _approve(_from, msg.sender, _allowances[_from][msg.sender].sub(_value));\n        return true;\n    }\n\n    function allowance(address _owner, address _spender)external override view returns(uint256 remaining){\n        return _allowances[_owner][_spender];\n    }\n\n//start presale manualy\n    function startPresaleManualy()public ownerOnly {\n        startPresale = true;\n    }\n\n//check how much investor purchase \n    function tierOfInvestor(address _investorWL) public view returns(uint256) {\n        return investors[_investorWL];\n    }\n\n//transfer BNB to contract\n    function sendBNBtoContract()external payable returns(uint256 _amount){\n        _amount = msg.value;\n        return _amount;\n    }\n//Function to purchace in presale\n    function sendToContract()external payable {\n        require(startPresale, \"Presale not active!\");\n        require(msg.value == 5000000000000000000 || //5 BNB\n                msg.value == 2500000000000000000 || //2.5 BNB\n                msg.value == 1000000000000000000 || //1 BNB\n                msg.value == 500000000000000000  || //0.5 BNB       \n                msg.value == 250000000000000000, //0.25 BNB\n                \"Amount must be: 0.25; 0.5; 1; 2,5; or 5 BNB\");\n        require(investors[msg.sender] == 0, \"You already invested!\");\n        require((msg.value.add(presaleAmout)) \u003c= hardCap, \"Amount is too high (almost reach hardcap)\");\n        investors[msg.sender] = msg.value;\n        presaleAmout = presaleAmout.add(msg.value);\n        totalInvestors = totalInvestors.add(1);\n        if (presaleAmout == hardCap) {\n            startPresale = false;\n            endPresale = true;\n        }\n    }\n\n//claim tokens from presale\n    function claimPresale()public {\n        uint256 amount;\n        require(endPresale, \"Presale not finished yet.\");\n        require(liveProject, \"Project not launched yet!\");\n        require(investors[msg.sender] \u003e 0, \"You are not in presale list!\");\n        require(investors[msg.sender] != 1, \"You already claim your tokens!\");      \n        amount = investors[msg.sender].mul(1000);\n        _transfer(vault, msg.sender, investors[msg.sender].mul(1000));\n        investors[msg.sender] = 1;\n    }\n\n//Launch project manualy after presale is finished (Live and add LP)\n    function liveProjectManualy()public ownerOnly payable{\n        require(endPresale, \"Presale not finished yet.\");\n        addMyLiquidity(350000000000000000000000, hardCap);\n        liveProject = true;\n    }\n// Add liquidity directly from contract\n    function addMyLiquidity(uint256 _tokensAmount, uint256 _BNBvalue)public ownerOnly payable {\n        _approve(vault, address(0x10ED43C718714eb63d5aA57B78B54704E256024E), _tokensAmount);\n        _pancakeRouter.addLiquidityETH {value: _BNBvalue}(\n        vault,\n        _tokensAmount,\n        0,\n        0,\n        forLP,\n        block.timestamp\n    );\n    }\n\n//can use to add on exclude freebie list holders(pancake router etc.)\n    function addToExcludedFromFreebie(address notwinner)public ownerOnly returns(address){\n        excludeFreebie[notwinner] = true;\n        return notwinner;\n    }\n    function removeFromExcludedFromFreebie(address maybeWinner)public ownerOnly returns(address){\n        excludeFreebie[maybeWinner] = false;\n        return maybeWinner;\n    }\n\n//change marketing wallet\n    function SetMarketingWL(address _newMarketingWL) public ownerOnly returns(address) {\n        marketingWl = _newMarketingWL;\n        return marketingWl;\n    }\n\n//exclude from fee or include (if excluded)\n    function ExcludeIncludeFee(address _addressExInc) public ownerOnly returns(bool){\n        if (_excludedFees[_addressExInc] == false) _excludedFees[_addressExInc] = true;\n        else _excludedFees[_addressExInc] = false;\n        return _excludedFees[_addressExInc];\n    }\n\n    function GetRandomNumber(uint256 _i) private view returns(uint256){\n        return uint(keccak256(abi.encodePacked(now, block.difficulty, allAddresses[_i])));\n    }\n\n    function checkClaimFromWinnersList(address _claimer)public view returns(bool _canClaim){\n        for (uint i = 0; i \u003c currentWinners50.length; i++) {\n            if (currentWinners50[i] == _claimer) \n                _canClaim = true;\n        }\n    }\n\n    function checkClaimedFreebie(address _claimer)public view returns(bool _Claimed){\n        for (uint i = 0; i \u003c claimedAddresses.length; i++) {\n            if (claimedAddresses[i] == _claimer) _Claimed = true;\n        }\n        return _Claimed;\n    }\n\n    function get500TokensHolders() public view returns(uint256 _500Holders) {\n        for (uint i = 0; i \u003c allAddresses.length; i++) {\n            if (_balances[allAddresses[i]] \u003e= 500000000000000000000) \n                _500Holders = _500Holders.add(1);\n        }\n        return _500Holders;\n    }\n\n//function to start freebie \n    function StartFreebie()public returns(bool){\n        require(_balances[msg.sender] \u003e= 500000000000000000000, \u0027Your balance must be 500 or more tokens!\u0027);\n        require(get500TokensHolders() \u003e= 20, \u0027Holderst with balances \u003e= 500 less then 20\u0027);\n        require(block.timestamp \u003e deadlineFreebie, \u0027Freebie already on air!\u0027);\n        require(balanceVault \u003e= 1200000000000000000000,\u0027Vault not full enough, must be 1200 tokens there or more\u0027);\n        if (balanceFreebie \u003e 0) _transfer(vault, activatorFreebie,balanceFreebie);\n\n        //reset winners list \u0026 claimed addresses lists\n        if (currentFreebieNo \u003e 0) \n        {\n            delete currentWinners50;\n            delete claimedAddresses;\n            delete AllrandomeNumbers;\n        }\n        //reset first winner who activated Freebie\n        currentWinners50.push(msg.sender);\n        activatorFreebie = currentWinners50[0];     \n        uint256 randomeNumberFull;\n        uint256 randomeNumber;\n        randomeNumberFull = GetRandomNumber(currentFreebieNo+1);\n        bool done = true;\n        for (uint j = 1; done; j++) \n        {\n            uint256 randomForJ = randomeNumberFull.div(j);\n            randomeNumber = randomForJ.mod(allAddresses.length);\n            AllrandomeNumbers.push(randomeNumber);\n            if (_balances[allAddresses[randomeNumber]] \u003e= 500000000000000000000 \u0026\u0026 \n            excludeFreebie[allAddresses[randomeNumber]] == false \u0026\u0026 \n                checkClaimFromWinnersList(allAddresses[randomeNumber]) == false) \n            {       \n                  currentWinners50.push(allAddresses[randomeNumber]);\n                  if (currentWinners50.length == 10) {\n                      done = false;\n                  }\n            }         \n        } \n//Freebie 1000, so total 1200 (200 goes to marketing wallet)\n        balanceVault = balanceVault.sub(1200000000000000000000);\n        balanceFreebie = 1000000000000000000000;\n        currentFreebieNo = currentFreebieNo.add(1);\n        _transfer(vault, marketingWl, 200000000000000000000);\n        deadlineFreebie = block.timestamp.add(86400); //86400 is 24h \n        return true;\n    }\n\n// Claim freebie for lucky winners\n    function ClaimFreebie()public {\n        require(balanceFreebie \u003e 0, \"Freebie not active yet! Or nothing left to claim.\");\n        require(checkClaimFromWinnersList(msg.sender),\"You are not lucky, you are not in current winners list\");\n        require(checkClaimedFreebie(msg.sender) == false, \"You already claim your freebie\");        \n        require(deadlineFreebie \u003e block.timestamp, \"Your time for claim is ower\");\n        _transfer(vault, msg.sender, 100000000000000000000);\n        balanceFreebie = balanceFreebie.sub(100000000000000000000);\n        claimedAddresses.push(msg.sender);\n        if (balanceFreebie == 0) deadlineFreebie = block.timestamp;\n    }\n\n// Function for claim tokens for freebie activator\n    function ClaimForActivatorFreebie()public {\n        require(balanceFreebie \u003e 0, \"Balance of Freebie is zero, nothing left to claim bro!\");\n        require(msg.sender == currentWinners50[0], \"You are not activator of the latest Freebie!\");\n        require(block.timestamp \u003e deadlineFreebie, \"Deadline still not finished yet!\");\n        _transfer(vault, currentWinners50[0],balanceFreebie);\n        balanceFreebie = 0;\n    }\n}"},"IUniswapV2Router02.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity =0.6.6;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address owner) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity =0.6.6;\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a, \"SafeMath: addition overflow\");\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b \u003c= a, errorMessage);\n    uint256 c = a - b;\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b \u003e 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}"}}