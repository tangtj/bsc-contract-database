/**
 *Submitted for verification at BscScan.com on 2023-07-14
*/

// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(
        address recipient,
        uint256 amount
    ) external returns (bool);

    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) external virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface IPancakeSwap {
    function getAmountsOut(
        uint256 amountIn,
        address[] memory path
    ) external view returns (uint256[] memory amounts);
}

interface IOriginalContract {
    struct User {
        uint256 checkpoint;
        uint256 totalInvested;
        uint256 totalTokenPurchase;
        uint256 totalUsdPurchase;
        address referrer;
        uint256[22] levels;
        uint256[22] totalBusiness;
        uint256 withdrawn;
        uint256 bonus;
        uint256 totalBonus;
        Stake[] stakes;
        Withdraw[] withdraws;
        uint256 leg;
        uint256 deposit_payouts;
        uint256 userId;
        uint256 directBonus;
        uint256 directBonusWithdrawn;
    }

    struct Stake {
        uint256 amount;
        uint256 checkpoint;
        uint256 recieved;
    }

    struct Withdraw {
        uint256 amount;
        uint256 checkpoint;
        uint256 recieved;
    }

    function getUserInfo(
        address userAddress
    ) external view returns (User memory);

    function getUserSellInfo(
        address userAddress,
        uint256 index
    )
        external
        view
        returns (uint256 amount, uint256 checkpoint, uint256 recieved);
}

contract AmpleApp is Ownable {
    using SafeMath for uint256;

    struct User {
        uint256 checkpoint;
        uint256 totalInvested;
        uint256 totalTokenPurchase;
        uint256 totalUsdPurchase;
        address referrer;
        uint256[22] levels;
        uint256[22] totalBusiness;
        uint256 withdrawn;
        uint256 bonus;
        uint256 totalBonus;
        Stake[] stakes;
        Withdraw[] withdraws;
        uint256 leg;
        uint256 deposit_payouts;
        uint256 userId;
        uint256 directBonus;
        uint256 directBonusWithdrawn;
    }

    struct Stake {
        uint256 amount;
        uint256 checkpoint;
        uint256 recieved;
    }
    struct Withdraw {
        uint256 amount;
        uint256 checkpoint;
        uint256 recieved;
    }

    struct Leg {
        uint256 legside;
        address user;
        uint256 rightamount;
        uint256 leftamount;
    }

    mapping(address => User) public users;
    mapping(uint256 => address) public usersIds;
    mapping(address => bool) public newUpdated;
    mapping(address => Leg) public legData;

    address payable public creatorWallet =
        payable(0x63BFD1C560314530E527d22E5962f89F0AD04F4a);
    uint256 public creatorFee = 100; // 10%
    uint256 public creatorFeeCollected;
    uint256 public constant PERCENTS_DIVIDER = 1000;
    uint256 public constant TIME_STEP = 1440 minutes; // 1 Day
    uint256 public MIN_AMOUNT = 10 ether; // 10 Dollar
    uint256 public totalInvested;
    uint256 public approxUser;
    uint256 public totalStakeCount;
    uint256 public totalWithdrawCount;
    bool public pancakePrice = false;
    uint256 public staticPrice = 3 ether;
    uint256 public userId = 48470;

    uint256[] public REFERRAL_PERCENTS = [
        70,
        200,
        100,
        50,
        50,
        50,
        50,
        50,
        50,
        50,
        50,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10
    ]; // 100 = 10%, 90 = 9%
    uint256[] public MINIMUM_BUSINESS = [
        10 ether,
        499 ether,
        500 ether,
        2999 ether,
        3000 ether,
        4999 ether,
        5000 ether
    ]; // Dollar Rates
    uint256[] public DAILY_BONUS = [4, 5, 6, 7]; // 0.4 = 4
    uint256[] public DAILY_BONUS_INCOME = [4, 5, 6, 7]; // 0.5 = 5

    event RefBonus(
        address indexed referrer,
        address indexed referral,
        uint256 indexed level,
        uint256 amount
    );
    event Newbie(address user);
    event NewDeposit(address indexed user, uint256 amount);

    // Mainnet - 0x10ED43C718714eb63d5aA57B78B54704E256024E
    // Testnet - 0xD99D1c33F9fC3444f8101754aBC46c52416550D1
    address public pancakeSwapAddress =
        0x10ED43C718714eb63d5aA57B78B54704E256024E; // Address of the PancakeSwap contract
    // Old Mainnet - 0xA2Df6b077d5036d4526A38Fb791b9aeE62435511
    // New Mainnet - 0x285C0eeD32d55896F070244d008852b2e996951A
    address public ampletoken = 0x285C0eeD32d55896F070244d008852b2e996951A;

    address private originalContractAddress =
        0xC0E08679b35E4A1c7BE31A0c04Ec67A604296A8c;
    IOriginalContract private originalContract;

    constructor() {
        originalContract = IOriginalContract(originalContractAddress);
    }

    function stake(uint256 _amount, address _referrer, uint256 _leg) external {
        // Calculate USD price using PancakeSwap contract interface
        uint256 usdPrice = getTokenToUsd(_amount);

        User storage user = users[msg.sender];

        require(_leg == 0 || _leg == 1, "Leg has to be Right(0) or Left(1)");
        require(
            usdPrice >= MIN_AMOUNT,
            "Ample Coin: Deposit value is too small"
        );
        require(
            IERC20(ampletoken).transferFrom(msg.sender, address(this), _amount),
            "Token transfer failed"
        );

        if (user.referrer == address(0) && _msgSender() != creatorWallet) {
            if (
                users[_referrer].totalTokenPurchase > 0 &&
                _referrer != msg.sender
            ) {
                user.referrer = _referrer;
            } else if (_referrer == creatorWallet) {
                user.referrer = creatorWallet;
            } else {
                user.referrer = creatorWallet;
            }
            address upline = user.referrer;
            for (uint256 i = 0; i < REFERRAL_PERCENTS.length; i++) {
                if (upline != address(0)) {
                    users[upline].levels[i] = users[upline].levels[i].add(1);
                    upline = users[upline].referrer;
                } else break;
            }
        }

        if (user.totalInvested == 0) {
            approxUser = approxUser.add(1);
            userId = userId.add(1);
            usersIds[userId] = msg.sender;
            user.userId = userId;
            user.checkpoint = block.timestamp;
            user.leg = _leg;
            emit Newbie(msg.sender);
            legData[msg.sender].legside = _leg;
            legData[msg.sender].user = _referrer;
        }else{
            withdrawTopup();
        }

        if (user.referrer != address(0)) {
            address upline = user.referrer;
            uint256 totalDirect = users[upline].levels[0];

            for (uint256 i = 0; i < REFERRAL_PERCENTS.length; i++) {
                if (upline != address(0)) {
                    users[upline].totalBusiness[i] = users[upline]
                        .totalBusiness[i]
                        .add(_amount);
                    if (i == 0) {
                        if (legData[msg.sender].legside == 0) {
                            legData[upline].rightamount = legData[upline]
                                .rightamount
                                .add(_amount);
                        } else {
                            legData[upline].leftamount = legData[upline]
                                .leftamount
                                .add(_amount);
                        }
                    } else {
                        if (legData[upline].legside == 0) {
                            legData[users[upline].referrer]
                                .rightamount = legData[users[upline].referrer]
                                .rightamount
                                .add(_amount);
                        } else {
                            legData[users[upline].referrer]
                                .leftamount = legData[users[upline].referrer]
                                .leftamount
                                .add(_amount);
                        }
                    }

                    uint256 rewardLevels = (2 * totalDirect) + 1;
                    if (i < rewardLevels) {
                        uint256 amount = _amount.mul(REFERRAL_PERCENTS[i]).div(
                            PERCENTS_DIVIDER
                        );

                        if (i == 0) {
                            users[upline].directBonus = users[upline]
                                .directBonus
                                .add((amount));
                        } 

                        users[upline].bonus = users[upline].bonus.add(
                                (amount)
                            );

                        emit RefBonus(
                            upline,
                            msg.sender,
                            i,
                            this.maxPayoutOf(amount)
                        );
                    }
                    upline = users[upline].referrer;
                    totalDirect = users[upline].levels[0];
                }
            }
        }

        user.totalInvested = user.totalInvested.add(_amount);
        totalInvested = totalInvested.add(_amount);
        totalStakeCount = totalStakeCount.add(1);

        user.totalTokenPurchase = user.totalTokenPurchase.add(_amount);
        user.totalUsdPurchase = user.totalUsdPurchase.add(usdPrice);
        user.stakes.push(Stake(_amount, block.timestamp, usdPrice));

        emit NewDeposit(msg.sender, _amount);
    }

    function getTokenToUsd(uint256 _tokenAmount) public view returns (uint256) {
        if (pancakePrice) {
            address[] memory path = new address[](2);
            path[0] = address(ampletoken); // Replace with the token address used for deposit
            path[1] = address(0x55d398326f99059fF775485246999027B3197955); // Assuming this is the address of a stablecoin like USDT

            uint256[] memory amounts = IPancakeSwap(pancakeSwapAddress)
                .getAmountsOut(_tokenAmount, path);
            return amounts[1]; // USD price of the token
        } else {
            return ((staticPrice / 1e18) * _tokenAmount);
        }
    }

    function getUsdToToken(uint256 _usdAmount) public view returns (uint256) {
        if (pancakePrice) {
            address[] memory path = new address[](2);
            path[0] = address(0x55d398326f99059fF775485246999027B3197955); // Assuming this is the address of a stablecoin like USDT
            path[1] = address(ampletoken); // Replace with the token address used for deposit

            uint256[] memory amounts = IPancakeSwap(pancakeSwapAddress)
                .getAmountsOut(_usdAmount, path);
            return amounts[1]; // Token Output
        } else {
            return (_usdAmount / (staticPrice / 1e18));
        }
    }

    function maxPayoutOf(uint256 _amount) external pure returns (uint256) {
        return (_amount * 30) / 10; // 3X ROI
    }

    function maxPayoutOfIncome(
        uint256 _amount
    ) external pure returns (uint256) {
        return (_amount * 20) / 10; // 2X Reward
    }

    function payoutOf(
        address _addr
    ) external view returns (uint256 payout, uint256 max_payout) {
        max_payout = this.maxPayoutOf(users[_addr].totalTokenPurchase);
        uint256 dailyPercent = DAILY_BONUS[0];

        if (
            users[_addr].totalUsdPurchase >= MINIMUM_BUSINESS[0] &&
            users[_addr].totalUsdPurchase <= MINIMUM_BUSINESS[1]
        ) {
            dailyPercent = DAILY_BONUS[0];
        } else if (
            users[_addr].totalUsdPurchase >= MINIMUM_BUSINESS[2] &&
            users[_addr].totalUsdPurchase <= MINIMUM_BUSINESS[3]
        ) {
            dailyPercent = DAILY_BONUS[1];
        } else if (
            users[_addr].totalUsdPurchase >= MINIMUM_BUSINESS[4] &&
            users[_addr].totalUsdPurchase <= MINIMUM_BUSINESS[5]
        ) {
            dailyPercent = DAILY_BONUS[2];
        } else {
            dailyPercent = DAILY_BONUS[3];
        }

        if (users[_addr].deposit_payouts < max_payout) {
            uint256 potentialPayout = (
                (users[_addr].totalTokenPurchase *
                dailyPercent *
                ((block.timestamp - users[_addr].checkpoint) / 1 days))
                .div(PERCENTS_DIVIDER)
            ).sub(users[_addr].deposit_payouts);

            // Ensure the potentialPayout is not negative
            if (potentialPayout > 0) {
                payout = potentialPayout;
                if (users[_addr].deposit_payouts.add(payout) > max_payout) {
                    payout = max_payout.sub(users[_addr].deposit_payouts);
                }
            }
        }

    }

    function payoutOfIncome(
        address _addr
    ) external view returns (uint256 payout, uint256 max_payout) {
        max_payout = this.maxPayoutOfIncome(users[_addr].totalTokenPurchase);
        uint256 dailyPercent = DAILY_BONUS_INCOME[0];

        if (
            users[_addr].totalUsdPurchase >= MINIMUM_BUSINESS[0] &&
            users[_addr].totalUsdPurchase <= MINIMUM_BUSINESS[1]
        ) {
            dailyPercent = DAILY_BONUS_INCOME[0];
        } else if (
            users[_addr].totalUsdPurchase >= MINIMUM_BUSINESS[2] &&
            users[_addr].totalUsdPurchase <= MINIMUM_BUSINESS[3]
        ) {
            dailyPercent = DAILY_BONUS_INCOME[1];
        } else if (
            users[_addr].totalUsdPurchase >= MINIMUM_BUSINESS[4] &&
            users[_addr].totalUsdPurchase <= MINIMUM_BUSINESS[5]
        ) {
            dailyPercent = DAILY_BONUS_INCOME[2];
        } else {
            dailyPercent = DAILY_BONUS_INCOME[3];
        }


        if (users[_addr].directBonusWithdrawn + users[_addr].totalBonus < max_payout) {
            uint256 potentialPayout = (
                (users[_addr].bonus * dailyPercent * ((block.timestamp - users[_addr].checkpoint) / 1 days))
                    .div(PERCENTS_DIVIDER)
            ).sub(users[_addr].totalBonus);

            // Ensure the potentialPayout is not negative
            if (potentialPayout > 0) {
                payout = potentialPayout;
                if (users[_addr].directBonusWithdrawn.add(payout).add(users[_addr].totalBonus) > max_payout) {
                    payout = max_payout.sub(users[_addr].totalBonus);
                }
            }
        }
    
    }

    function withdrawLevel() external {
        User storage user = users[msg.sender];
        uint256 withdrawal = 0;

        (uint256 to_payout, uint256 max_payout) = this.payoutOfIncome(
            msg.sender
        );

        require(
            users[msg.sender].totalBonus +
                users[msg.sender].directBonusWithdrawn <
                max_payout,
            "Full payouts"
        );

        withdrawal += to_payout;
        user.totalBonus = user.totalBonus.add(withdrawal);

        uint256 usdPrice = getTokenToUsd(withdrawal);

        uint256 feeCreator = withdrawal.mul(creatorFee).div(PERCENTS_DIVIDER);
        withdrawal = withdrawal - feeCreator;
        require(
            usdPrice >= MIN_AMOUNT,
            "Ample Coin: Withdrawal value is too small"
        );

        // Transfer the withdrawal amount to the user
        require(
            IERC20(ampletoken).transfer(msg.sender, withdrawal),
            "Token transfer failed"
        );
        require(
            IERC20(ampletoken).transfer(creatorWallet, feeCreator),
            "Token transfer failed"
        );
        user.withdraws.push(Withdraw(withdrawal, block.timestamp, usdPrice));
    }

    function withdrawDirect(uint256 _amount) external {
        User storage user = users[msg.sender];
        uint256 withdrawal = 0;

        (, uint256 max_payout) = this.payoutOfIncome(msg.sender);

        require(user.directBonus > 0, "Direct bonus is 0");
        require(
            _amount < user.directBonus,
            "Entered Amount Greater than Payout"
        );

        if (
            _amount +
                users[msg.sender].totalBonus +
                users[msg.sender].directBonusWithdrawn >
            max_payout
        ) {
            _amount =
                max_payout -
                (users[msg.sender].totalBonus +
                    users[msg.sender].directBonusWithdrawn);
        }

        withdrawal += _amount;
        if (user.directBonus > 0) {
            user.directBonus = user.directBonus.sub(withdrawal);
        }
        user.directBonusWithdrawn = user.directBonusWithdrawn.add(withdrawal);

        if (
            users[msg.sender].totalBonus +
                users[msg.sender].directBonusWithdrawn >=
            max_payout
        ) {
            user.directBonus = 0;
        }

        uint256 usdPrice = getTokenToUsd(withdrawal);

        uint256 feeCreator = withdrawal.mul(creatorFee).div(PERCENTS_DIVIDER);
        withdrawal = withdrawal - feeCreator;

        require(
            usdPrice >= MIN_AMOUNT,
            "Ample Coin: Withdrawal value is too small"
        );

        // Transfer the withdrawal amount to the user
        require(
            IERC20(ampletoken).transfer(msg.sender, withdrawal),
            "Token transfer failed"
        );
        require(
            IERC20(ampletoken).transfer(creatorWallet, feeCreator),
            "Token transfer failed"
        );
        user.withdraws.push(Withdraw(withdrawal, block.timestamp, usdPrice));
    }

    function withdrawTopup() internal {
        User storage user = users[msg.sender];
        uint256 withdrawal = 0;

        (uint256 to_payout, uint256 max_payout) = this.payoutOf(msg.sender);

        // Deposit payout
        if (to_payout > 0) {
            if (users[msg.sender].deposit_payouts + to_payout > max_payout) {
                to_payout = max_payout - users[msg.sender].deposit_payouts;
            }

            users[msg.sender].deposit_payouts += to_payout;
            withdrawal += to_payout;

            uint256 usdPrice = getTokenToUsd(withdrawal);

            uint256 feeCreator = withdrawal.mul(creatorFee).div(PERCENTS_DIVIDER);
            withdrawal = withdrawal - feeCreator;

            // Transfer the withdrawal amount to the user
            require(
                IERC20(ampletoken).transfer(msg.sender, withdrawal),
                "Token transfer failed"
            );
            require(
                IERC20(ampletoken).transfer(creatorWallet, feeCreator),
                "Token transfer failed"
            );
            user.withdraws.push(Withdraw(withdrawal, block.timestamp, usdPrice));
        }

        
    }

    function withdraw() external {
        User storage user = users[msg.sender];
        uint256 withdrawal = 0;

        (uint256 to_payout, uint256 max_payout) = this.payoutOf(msg.sender);

        require(users[msg.sender].deposit_payouts < max_payout, "Full payouts");

        // Deposit payout
        if (to_payout > 0) {
            if (users[msg.sender].deposit_payouts + to_payout > max_payout) {
                to_payout = max_payout - users[msg.sender].deposit_payouts;
            }

            users[msg.sender].deposit_payouts += to_payout;
        }

        withdrawal += to_payout;

        uint256 usdPrice = getTokenToUsd(withdrawal);

        uint256 feeCreator = withdrawal.mul(creatorFee).div(PERCENTS_DIVIDER);
        withdrawal = withdrawal - feeCreator;

        require(
            usdPrice >= MIN_AMOUNT,
            "Ample Coin: Withdrawal value is too small"
        );

        // Transfer the withdrawal amount to the user
        require(
            IERC20(ampletoken).transfer(msg.sender, withdrawal),
            "Token transfer failed"
        );
        require(
            IERC20(ampletoken).transfer(creatorWallet, feeCreator),
            "Token transfer failed"
        );
        user.withdraws.push(Withdraw(withdrawal, block.timestamp, usdPrice));
    }

    function getUserDownlineCount(
        address userAddress
    ) external view returns (uint256[22] memory referrals) {
        return (users[userAddress].levels);
    }

    function getUserBusinessCount(
        address userAddress
    ) external view returns (uint256[22] memory business) {
        return (users[userAddress].totalBusiness);
    }

    function getUserBuyInfo(
        address userAddress,
        uint256 index
    )
        external
        view
        returns (uint256 amount, uint256 checkpoint, uint256 recieved)
    {
        User storage user = users[userAddress];

        amount = user.stakes[index].amount;
        checkpoint = user.stakes[index].checkpoint;
        recieved = user.stakes[index].recieved;
    }

    function getUserSellInfo(
        address userAddress,
        uint256 index
    )
        external
        view
        returns (uint256 amount, uint256 checkpoint, uint256 recieved)
    {
        User storage user = users[userAddress];

        amount = user.withdraws[index].amount;
        checkpoint = user.withdraws[index].checkpoint;
        recieved = user.withdraws[index].recieved;
    }

    function getDepositLength(
        address userAddress
    ) external view returns (uint256) {
        User storage user = users[userAddress];
        return user.stakes.length;
    }

    function getWithdrawLength(
        address userAddress
    ) external view returns (uint256) {
        User storage user = users[userAddress];
        return user.withdraws.length;
    }

    function getUserTotalBusiness(
        address userAddress
    ) external view returns (uint256 amount) {
        for (uint256 i = 0; i < users[userAddress].totalBusiness.length; i++) {
            amount = amount.add(users[userAddress].totalBusiness[i]);
        }
        return amount;
    }

    function getUserTotalLevels(
        address userAddress
    ) external view returns (uint256 amount) {
        for (uint256 i = 0; i < users[userAddress].levels.length; i++) {
            amount = amount.add(users[userAddress].levels[i]);
        }
        return amount;
    }

    function getUserDirectBusiness(
        address userAddress
    ) external view returns (uint256 amount) {
        amount = (users[userAddress].totalBusiness[0]);
        return amount;
    }

    function getUserDirectLevels(
        address userAddress
    ) external view returns (uint256 amount) {
        amount = (users[userAddress].levels[0]);
        return amount;
    }

    function switchPancake(
        bool _pancakePrice,
        uint256 _staticPrice
    ) external onlyOwner {
        require(
            _staticPrice >= 1 ether,
            "Price should be greater than or equal to 1 USDT"
        );
        pancakePrice = _pancakePrice;
        staticPrice = _staticPrice;
    }

    function v1ToV2(
        address _token,
        address _to
    ) external onlyOwner returns (bool _sent) {
        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));
        _sent = IERC20(_token).transfer(_to, _contractBalance);
    }

    function v1ToV2Bnb() external onlyOwner {
        payable(creatorWallet).transfer(address(this).balance);
    }

    function getUserInfo(
        address userAddress
    ) external view returns (User memory) {
        return users[userAddress];
    }

    function getUserInfoId(
        uint256 usersId
    ) external view returns (User memory) {
        address userAddress = usersIds[usersId];
        return users[userAddress];
    }

    function setCreatorWallet(address payable _wallet) external onlyOwner {
        require(_wallet != address(0), "Invalid wallet address");
        creatorWallet = _wallet;
    }

    function stakeUser(address _user, User memory _params) external onlyOwner {
        users[_user].checkpoint = _params.checkpoint;
        users[_user].totalInvested = _params.totalInvested;
        users[_user].totalTokenPurchase = _params.totalTokenPurchase;
        users[_user].totalUsdPurchase = _params.totalUsdPurchase;
        users[_user].referrer = _params.referrer;
        users[_user].withdrawn = _params.withdrawn;
        users[_user].bonus = _params.bonus;
        users[_user].totalBonus = _params.totalBonus;
        users[_user].leg = _params.leg;
        users[_user].deposit_payouts = _params.deposit_payouts;
        users[_user].userId = _params.userId;
        users[_user].directBonus = _params.directBonus;
        users[_user].directBonusWithdrawn = _params.directBonusWithdrawn;

    }


    function upgradeUser(address _user, User memory _params) internal {
        users[_user].checkpoint = _params.checkpoint;
        users[_user].totalInvested = _params.totalInvested;
        users[_user].totalTokenPurchase = _params.totalTokenPurchase;
        users[_user].totalUsdPurchase = _params.totalUsdPurchase;
        users[_user].referrer = _params.referrer;
        users[_user].withdrawn = _params.withdrawn;
        users[_user].bonus = _params.bonus;
        users[_user].totalBonus = _params.totalBonus;
        users[_user].leg = _params.leg;
        users[_user].deposit_payouts = _params.deposit_payouts;
        users[_user].userId = _params.userId;
        users[_user].directBonus = _params.directBonus;
        users[_user].directBonusWithdrawn = _params.directBonusWithdrawn;
    }

    function upgradeV2Own(address _user) external onlyOwner {
        
        if(!newUpdated[_user]){
            IOriginalContract.User memory oldUserData = originalContract.getUserInfo(_user);

            users[_user].checkpoint = oldUserData.checkpoint;
            users[_user].totalInvested = oldUserData.totalInvested;
            users[_user].totalTokenPurchase = oldUserData.totalTokenPurchase;
            users[_user].totalUsdPurchase = oldUserData.totalUsdPurchase;
            users[_user].referrer = oldUserData.referrer;
            users[_user].levels = oldUserData.levels;
            users[_user].totalBusiness = oldUserData.totalBusiness;
            users[_user].withdrawn = oldUserData.withdrawn;
            users[_user].bonus = oldUserData.bonus;
            users[_user].totalBonus = oldUserData.totalBonus;
            users[_user].leg = oldUserData.leg;
            users[_user].deposit_payouts = oldUserData.deposit_payouts;
            users[_user].userId = oldUserData.userId;
            users[_user].directBonus = oldUserData.directBonus;
            users[_user].directBonusWithdrawn = oldUserData.directBonusWithdrawn;

            newUpdated[_user] = true;
        }

    }

    function upgradeV2() external {
        address _user = msg.sender;
        if(!newUpdated[_user]){
            IOriginalContract.User memory oldUserData = originalContract.getUserInfo(_user);

            users[_user].checkpoint = oldUserData.checkpoint;
            users[_user].totalInvested = oldUserData.totalInvested;
            users[_user].totalTokenPurchase = oldUserData.totalTokenPurchase;
            users[_user].totalUsdPurchase = oldUserData.totalUsdPurchase;
            users[_user].referrer = oldUserData.referrer;
            users[_user].levels = oldUserData.levels;
            users[_user].totalBusiness = oldUserData.totalBusiness;
            users[_user].withdrawn = oldUserData.withdrawn;
            users[_user].bonus = oldUserData.bonus;
            users[_user].totalBonus = oldUserData.totalBonus;
            users[_user].leg = oldUserData.leg;
            users[_user].deposit_payouts = oldUserData.deposit_payouts;
            users[_user].userId = oldUserData.userId;
            users[_user].directBonus = oldUserData.directBonus;
            users[_user].directBonusWithdrawn = oldUserData.directBonusWithdrawn;

            newUpdated[_user] = true;
        }

    }

    function setCheckpoint(
        address _user,
        uint256 _checkpoint
    ) external onlyOwner {
        users[_user].checkpoint = _checkpoint;
    }

    function setTotalInvested(
        address _user,
        uint256 _totalInvested
    ) external onlyOwner {
        users[_user].totalInvested = _totalInvested;
    }

    function setTotalTokenPurchase(
        address _user,
        uint256 _totalTokenPurchase
    ) external onlyOwner {
        users[_user].totalTokenPurchase = _totalTokenPurchase;
    }

    function setTotalUsdPurchase(
        address _user,
        uint256 _totalUsdPurchase
    ) external onlyOwner {
        users[_user].totalUsdPurchase = _totalUsdPurchase;
    }

    function setReferrer(address _user, address _referrer) external onlyOwner {
        users[_user].referrer = _referrer;
    }

    function setLevels(
        address _user,
        uint256[22] memory _levels
    ) external onlyOwner {
        users[_user].levels = _levels;
    }

    function setTotalBusiness(
        address _user,
        uint256[22] memory _totalBusiness
    ) external onlyOwner {
        users[_user].totalBusiness = _totalBusiness;
    }

    function setWithdrawn(
        address _user,
        uint256 _withdrawn
    ) external onlyOwner {
        users[_user].withdrawn = _withdrawn;
    }

    function setBonus(address _user, uint256 _bonus) external onlyOwner {
        users[_user].bonus = _bonus;
    }

    function setTotalBonus(
        address _user,
        uint256 _totalBonus
    ) external onlyOwner {
        users[_user].totalBonus = _totalBonus;
    }

    function setLeg(address _user, uint256 _leg) external onlyOwner {
        users[_user].leg = _leg;
    }

    function setDepositPayouts(
        address _user,
        uint256 _deposit_payouts
    ) external onlyOwner {
        users[_user].deposit_payouts = _deposit_payouts;
    }

    function setUserId(address _user, uint256 _userId) external onlyOwner {
        users[_user].userId = _userId;
    }

    function setDirectBonus(
        address _user,
        uint256 _directBonus
    ) external onlyOwner {
        users[_user].directBonus = _directBonus;
    }

    function userFromOgContract(
        address _userAddress
    ) public view returns (IOriginalContract.User memory) {
        return originalContract.getUserInfo(_userAddress);
    }

    function userFromOgContractSpecific(
        address _userAddress
    ) external view returns (IOriginalContract.User memory) {
        IOriginalContract.User memory ogUser = originalContract.getUserInfo(
            _userAddress
        );

        IOriginalContract.User memory user = IOriginalContract.User(
            ogUser.checkpoint,
            ogUser.totalInvested,
            ogUser.totalTokenPurchase,
            ogUser.totalUsdPurchase,
            ogUser.referrer,
            ogUser.levels,
            ogUser.totalBusiness,
            ogUser.withdrawn,
            ogUser.bonus,
            ogUser.totalBonus,
            ogUser.stakes,
            ogUser.withdraws,
            ogUser.leg,
            ogUser.deposit_payouts,
            ogUser.userId,
            ogUser.directBonus,
            ogUser.directBonusWithdrawn
            );

        return user;
    }

    function oldDepositUsd(
        address _userAddress
    ) external view returns (uint256) {
        IOriginalContract.User memory ogUser = originalContract.getUserInfo(
            _userAddress
        );
        return ogUser.totalInvested;
    }

    function oldTransferData(
        address _userAddress
    ) external view returns (bool) {
        return newUpdated[_userAddress];
    }

    function setStake(address _userAdd, Stake[] memory _data) internal {
        for (uint256 i = 0; i < _data.length; i++) {
            users[_userAdd].stakes.push(_data[i]);
        }
    }

    function setWithdrawal(address _userAdd, Withdraw[] memory _data) internal {
        for (uint256 i = 0; i < _data.length; i++) {
            users[_userAdd].withdraws.push(_data[i]);
        }
    }

    function setStakes(
        address _userAdd,
        Stake[] memory _data
    ) external onlyOwner {
        for (uint256 i = 0; i < _data.length; i++) {
            users[_userAdd].stakes.push(_data[i]);
        }
    }

    function setWithdrawals(
        address _userAdd,
        Withdraw[] memory _data
    ) external onlyOwner {
        for (uint256 i = 0; i < _data.length; i++) {
            users[_userAdd].withdraws.push(_data[i]);
        }
    }

    function addLeg(
        uint256 _legside,
        address _user,
        uint256 _amountleft,
        uint256 _amountright
    ) public onlyOwner {
        legData[_user].legside = _legside;
        legData[_user].user = _user;
        legData[_user].rightamount = _amountleft;
        legData[_user].leftamount = _amountright;
    }

    function changeAmpleAdd(address _newAmple) external onlyOwner {
        ampletoken = _newAmple;
    }

    function changeMinAmount(uint256 _newAmount) external onlyOwner {
        MIN_AMOUNT = _newAmount;
    }

    function getLeg(
        address _user
    ) external view returns (uint256, address, uint256, uint256) {
        Leg memory leg = legData[_user];
        return (leg.legside, leg.user, leg.rightamount, leg.leftamount);
    }
}