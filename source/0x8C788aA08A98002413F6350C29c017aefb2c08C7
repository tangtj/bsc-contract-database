{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"AssetRegistry.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport { Address } from \u0027./Address.sol\u0027;\n\nimport { IERC20, Structs } from \u0027./Interfaces.sol\u0027;\n\n\n/**\n * @notice Library helper functions for managing a registry of asset descriptors indexed by address and symbol\n */\nlibrary AssetRegistry {\n  struct Storage {\n    mapping(address =\u003e Structs.Asset) assetsByAddress;\n    // Mapping value is array since the same symbol can be re-used for a different address\n    // (usually as a result of a token swap or upgrade)\n    mapping(string =\u003e Structs.Asset[]) assetsBySymbol;\n  }\n\n  function registerToken(\n    Storage storage self,\n    IERC20 tokenAddress,\n    string memory symbol,\n    uint8 decimals\n  ) internal {\n    require(decimals \u003c= 32, \u0027Token cannot have more than 32 decimals\u0027);\n    require(\n      tokenAddress != IERC20(0x0) \u0026\u0026 Address.isContract(address(tokenAddress)),\n      \u0027Invalid token address\u0027\n    );\n    // The string type does not have a length property so cast to bytes to check for empty string\n    require(bytes(symbol).length \u003e 0, \u0027Invalid token symbol\u0027);\n    require(\n      !self.assetsByAddress[address(tokenAddress)].isConfirmed,\n      \u0027Token already finalized\u0027\n    );\n\n    self.assetsByAddress[address(tokenAddress)] = Structs.Asset({\n      exists: true,\n      assetAddress: address(tokenAddress),\n      symbol: symbol,\n      decimals: decimals,\n      isConfirmed: false,\n      confirmedTimestampInMs: 0\n    });\n  }\n\n  function confirmTokenRegistration(\n    Storage storage self,\n    IERC20 tokenAddress,\n    string memory symbol,\n    uint8 decimals\n  ) internal {\n    Structs.Asset memory asset = self.assetsByAddress[address(tokenAddress)];\n    require(asset.exists, \u0027Unknown token\u0027);\n    require(!asset.isConfirmed, \u0027Token already finalized\u0027);\n    require(isStringEqual(asset.symbol, symbol), \u0027Symbols do not match\u0027);\n    require(asset.decimals == decimals, \u0027Decimals do not match\u0027);\n\n    asset.isConfirmed = true;\n    asset.confirmedTimestampInMs = uint64(block.timestamp * 1000); // Block timestamp is in seconds, store ms\n    self.assetsByAddress[address(tokenAddress)] = asset;\n    self.assetsBySymbol[symbol].push(asset);\n  }\n\n  function addTokenSymbol(\n    Storage storage self,\n    IERC20 tokenAddress,\n    string memory symbol\n  ) internal {\n    Structs.Asset memory asset = self.assetsByAddress[address(tokenAddress)];\n    require(\n      asset.exists \u0026\u0026 asset.isConfirmed,\n      \u0027Registration of token not finalized\u0027\n    );\n    require(!isStringEqual(symbol, \u0027BNB\u0027), \u0027BNB symbol reserved\u0027);\n\n    // This will prevent swapping assets for previously existing orders\n    uint64 msInOneSecond = 1000;\n    asset.confirmedTimestampInMs = uint64(block.timestamp * msInOneSecond);\n\n    self.assetsBySymbol[symbol].push(asset);\n  }\n\n  /**\n   * @dev Resolves an asset address into corresponding Asset struct\n   *\n   * @param assetAddress Ethereum address of asset\n   */\n  function loadAssetByAddress(Storage storage self, address assetAddress)\n    internal\n    view\n    returns (Structs.Asset memory)\n  {\n    if (assetAddress == address(0x0)) {\n      return getBnbAsset();\n    }\n\n    Structs.Asset memory asset = self.assetsByAddress[assetAddress];\n    require(\n      asset.exists \u0026\u0026 asset.isConfirmed,\n      \u0027No confirmed asset found for address\u0027\n    );\n\n    return asset;\n  }\n\n  /**\n   * @dev Resolves a asset symbol into corresponding Asset struct\n   *\n   * @param symbol Asset symbol, e.g. \u0027IDEX\u0027\n   * @param timestampInMs Milliseconds since Unix epoch, usually parsed from a UUID v1 order nonce.\n   * Constrains symbol resolution to the asset most recently confirmed prior to timestampInMs. Reverts\n   * if no such asset exists\n   */\n  function loadAssetBySymbol(\n    Storage storage self,\n    string memory symbol,\n    uint64 timestampInMs\n  ) internal view returns (Structs.Asset memory) {\n    if (isStringEqual(\u0027BNB\u0027, symbol)) {\n      return getBnbAsset();\n    }\n\n    Structs.Asset memory asset;\n    if (self.assetsBySymbol[symbol].length \u003e 0) {\n      for (uint8 i = 0; i \u003c self.assetsBySymbol[symbol].length; i++) {\n        if (\n          self.assetsBySymbol[symbol][i].confirmedTimestampInMs \u003c= timestampInMs\n        ) {\n          asset = self.assetsBySymbol[symbol][i];\n        }\n      }\n    }\n    require(\n      asset.exists \u0026\u0026 asset.isConfirmed,\n      \u0027No confirmed asset found for symbol\u0027\n    );\n\n    return asset;\n  }\n\n  /**\n   * @dev BNB is modeled as an always-confirmed Asset struct for programmatic consistency\n   */\n  function getBnbAsset() private pure returns (Structs.Asset memory) {\n    return Structs.Asset(true, address(0x0), \u0027BNB\u0027, 18, true, 0);\n  }\n\n  // See https://solidity.readthedocs.io/en/latest/types.html#bytes-and-strings-as-arrays\n  function isStringEqual(string memory a, string memory b)\n    private\n    pure\n    returns (bool)\n  {\n    return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n  }\n}\n"},"AssetTransfers.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport {\n  SafeMath as SafeMath256\n} from \u0027./SafeMath.sol\u0027;\n\nimport { IERC20 } from \u0027./Interfaces.sol\u0027;\n\n\n/**\n * @notice This library provides helper utilities for transfering assets in and out of contracts.\n * It further validates ERC-20 compliant balance updates in the case of token assets\n */\nlibrary AssetTransfers {\n  using SafeMath256 for uint256;\n\n  /**\n   * @dev Transfers tokens from a wallet into a contract during deposits. `wallet` must already\n   * have called `approve` on the token contract for at least `tokenQuantity`. Note this only\n   * applies to tokens since BNB is sent in the deposit transaction via `msg.value`\n   */\n  function transferFrom(\n    address wallet,\n    IERC20 tokenAddress,\n    uint256 quantityInAssetUnits\n  ) internal {\n    uint256 balanceBefore = tokenAddress.balanceOf(address(this));\n\n    // Because we check for the expected balance change we can safely ignore the return value of transferFrom\n    tokenAddress.transferFrom(wallet, address(this), quantityInAssetUnits);\n\n    uint256 balanceAfter = tokenAddress.balanceOf(address(this));\n    require(\n      balanceAfter.sub(balanceBefore) == quantityInAssetUnits,\n      \u0027Token contract returned transferFrom success without expected balance change\u0027\n    );\n  }\n\n  /**\n   * @dev Transfers BNB or token assets from a contract to 1) another contract, when `Exchange`\n   * forwards funds to `Custodian` during deposit or 2) a wallet, when withdrawing\n   */\n  function transferTo(\n    address payable walletOrContract,\n    address asset,\n    uint256 quantityInAssetUnits\n  ) internal {\n    if (asset == address(0x0)) {\n      require(\n        walletOrContract.send(quantityInAssetUnits),\n        \u0027BNB transfer failed\u0027\n      );\n    } else {\n      uint256 balanceBefore = IERC20(asset).balanceOf(walletOrContract);\n\n      // Because we check for the expected balance change we can safely ignore the return value of transfer\n      IERC20(asset).transfer(walletOrContract, quantityInAssetUnits);\n\n      uint256 balanceAfter = IERC20(asset).balanceOf(walletOrContract);\n      require(\n        balanceAfter.sub(balanceBefore) == quantityInAssetUnits,\n        \u0027Token contract returned transfer success without expected balance change\u0027\n      );\n    }\n  }\n}\n"},"AssetUnitConversions.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport {\n  SafeMath as SafeMath256\n} from \u0027./SafeMath.sol\u0027;\n\n\n/**\n * @notice Library helpers for converting asset quantities between asset units and pips\n */\nlibrary AssetUnitConversions {\n  using SafeMath256 for uint256;\n\n  function pipsToAssetUnits(uint64 quantityInPips, uint8 assetDecimals)\n    internal\n    pure\n    returns (uint256)\n  {\n    require(assetDecimals \u003c= 32, \u0027Asset cannot have more than 32 decimals\u0027);\n\n    // Exponents cannot be negative, so divide or multiply based on exponent signedness\n    if (assetDecimals \u003e 8) {\n      return uint256(quantityInPips).mul(uint256(10)**(assetDecimals - 8));\n    }\n    return uint256(quantityInPips).div(uint256(10)**(8 - assetDecimals));\n  }\n\n  function assetUnitsToPips(uint256 quantityInAssetUnits, uint8 assetDecimals)\n    internal\n    pure\n    returns (uint64)\n  {\n    require(assetDecimals \u003c= 32, \u0027Asset cannot have more than 32 decimals\u0027);\n\n    uint256 quantityInPips;\n    // Exponents cannot be negative, so divide or multiply based on exponent signedness\n    if (assetDecimals \u003e 8) {\n      quantityInPips = quantityInAssetUnits.div(\n        uint256(10)**(assetDecimals - 8)\n      );\n    } else {\n      quantityInPips = quantityInAssetUnits.mul(\n        uint256(10)**(8 - assetDecimals)\n      );\n    }\n    require(quantityInPips \u003c 2**64, \u0027Pip quantity overflows uint64\u0027);\n\n    return uint64(quantityInPips);\n  }\n}\n"},"ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature \u0027s\u0027 value\");\n        }\n\n        if (v != 27 \u0026\u0026 v != 28) {\n            revert(\"ECDSA: invalid signature \u0027v\u0027 value\");\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"},"Exchange.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport { Address } from \u0027./Address.sol\u0027;\nimport { ECDSA } from \u0027./ECDSA.sol\u0027;\nimport {\n  SafeMath as SafeMath256\n} from \u0027./SafeMath.sol\u0027;\n\nimport { AssetRegistry } from \u0027./AssetRegistry.sol\u0027;\nimport { AssetTransfers } from \u0027./AssetTransfers.sol\u0027;\nimport { AssetUnitConversions } from \u0027./AssetUnitConversions.sol\u0027;\nimport { Owned } from \u0027./Owned.sol\u0027;\nimport { SafeMath64 } from \u0027./SafeMath64.sol\u0027;\nimport { Signatures } from \u0027./Signatures.sol\u0027;\nimport {\n  Enums,\n  ICustodian,\n  IERC20,\n  IExchange,\n  Structs\n} from \u0027./Interfaces.sol\u0027;\nimport { UUID } from \u0027./UUID.sol\u0027;\n\n\n/**\n * @notice The Exchange contract. Implements all deposit, trade, and withdrawal logic and associated balance tracking\n *\n * @dev The term `asset` refers collectively to BNB and ERC-20 tokens, the term `token` refers only to the latter\n * @dev Events with indexed string parameters (Deposited and TradeExecuted) only log the hash values for those\n * parameters, from which the original raw string values cannot be retrieved. For convenience these events contain\n * the un-indexed string parameter values in addition to the indexed values\n */\ncontract Exchange is IExchange, Owned {\n  using SafeMath64 for uint64;\n  using SafeMath256 for uint256;\n  using AssetRegistry for AssetRegistry.Storage;\n\n  // Events //\n\n  /**\n   * @notice Emitted when an admin changes the Chain Propagation Period tunable parameter with `setChainPropagationPeriod`\n   */\n  event ChainPropagationPeriodChanged(uint256 previousValue, uint256 newValue);\n  /**\n   * @notice Emitted when a user deposits BNB with `depositEther` or a token with `depositAsset` or `depositAssetBySymbol`\n   */\n  event Deposited(\n    uint64 index,\n    address indexed wallet,\n    address indexed assetAddress,\n    string indexed assetSymbolIndex,\n    string assetSymbol,\n    uint64 quantityInPips,\n    uint64 newExchangeBalanceInPips,\n    uint256 newExchangeBalanceInAssetUnits\n  );\n  /**\n   * @notice Emitted when an admin changes the Dispatch Wallet tunable parameter with `setDispatcher`\n   */\n  event DispatcherChanged(address previousValue, address newValue);\n\n  /**\n   * @notice Emitted when an admin changes the Fee Wallet tunable parameter with `setFeeWallet`\n   */\n  event FeeWalletChanged(address previousValue, address newValue);\n\n  /**\n   * @notice Emitted when a user invalidates an order nonce with `invalidateOrderNonce`\n   */\n  event OrderNonceInvalidated(\n    address indexed wallet,\n    uint128 nonce,\n    uint128 timestampInMs,\n    uint256 effectiveBlockNumber\n  );\n  /**\n   * @notice Emitted when an admin initiates the token registration process with `registerToken`\n   */\n  event TokenRegistered(\n    IERC20 indexed assetAddress,\n    string assetSymbol,\n    uint8 decimals\n  );\n  /**\n   * @notice Emitted when an admin finalizes the token registration process with `confirmAssetRegistration`, after\n   * which it can be deposited, traded, or withdrawn\n   */\n  event TokenRegistrationConfirmed(\n    IERC20 indexed assetAddress,\n    string assetSymbol,\n    uint8 decimals\n  );\n  /**\n   * @notice Emitted when an admin adds a symbol to a previously registered and confirmed token\n   * via `addTokenSymbol`\n   */\n  event TokenSymbolAdded(IERC20 indexed assetAddress, string assetSymbol);\n  /**\n   * @notice Emitted when the Dispatcher Wallet submits a trade for execution with `executeTrade`\n   */\n  event TradeExecuted(\n    address buyWallet,\n    address sellWallet,\n    string indexed baseAssetSymbolIndex,\n    string indexed quoteAssetSymbolIndex,\n    string baseAssetSymbol,\n    string quoteAssetSymbol,\n    uint64 baseQuantityInPips,\n    uint64 quoteQuantityInPips,\n    uint64 tradePriceInPips,\n    bytes32 buyOrderHash,\n    bytes32 sellOrderHash\n  );\n  /**\n   * @notice Emitted when a user invokes the Exit Wallet mechanism with `exitWallet`\n   */\n  event WalletExited(address indexed wallet, uint256 effectiveBlockNumber);\n  /**\n   * @notice Emitted when a user withdraws an asset balance through the Exit Wallet mechanism with `withdrawExit`\n   */\n  event WalletExitWithdrawn(\n    address indexed wallet,\n    address indexed assetAddress,\n    string assetSymbol,\n    uint64 quantityInPips,\n    uint64 newExchangeBalanceInPips,\n    uint256 newExchangeBalanceInAssetUnits\n  );\n  /**\n   * @notice Emitted when a user clears the exited status of a wallet previously exited with `exitWallet`\n   */\n  event WalletExitCleared(address indexed wallet);\n  /**\n   * @notice Emitted when the Dispatcher Wallet submits a withdrawal with `withdraw`\n   */\n  event Withdrawn(\n    address indexed wallet,\n    address indexed assetAddress,\n    string assetSymbol,\n    uint64 quantityInPips,\n    uint64 newExchangeBalanceInPips,\n    uint256 newExchangeBalanceInAssetUnits\n  );\n\n  // Internally used structs //\n\n  struct NonceInvalidation {\n    bool exists;\n    uint64 timestampInMs;\n    uint256 effectiveBlockNumber;\n  }\n  struct WalletExit {\n    bool exists;\n    uint256 effectiveBlockNumber;\n  }\n\n  // Storage //\n\n  // Asset registry data\n  AssetRegistry.Storage _assetRegistry;\n  // Mapping of order wallet hash =\u003e isComplete\n  mapping(bytes32 =\u003e bool) _completedOrderHashes;\n  // Mapping of withdrawal wallet hash =\u003e isComplete\n  mapping(bytes32 =\u003e bool) _completedWithdrawalHashes;\n  address payable _custodian;\n  uint64 _depositIndex;\n  // Mapping of wallet =\u003e asset =\u003e balance\n  mapping(address =\u003e mapping(address =\u003e uint64)) _balancesInPips;\n  // Mapping of wallet =\u003e last invalidated timestampInMs\n  mapping(address =\u003e NonceInvalidation) _nonceInvalidations;\n  // Mapping of order hash =\u003e filled quantity in pips\n  mapping(bytes32 =\u003e uint64) _partiallyFilledOrderQuantitiesInPips;\n  mapping(address =\u003e WalletExit) _walletExits;\n  // Tunable parameters\n  uint256 _chainPropagationPeriod;\n  address _dispatcherWallet;\n  address _feeWallet;\n\n  // Constant values //\n\n  uint256 constant _maxChainPropagationPeriod = (7 * 24 * 60 * 60) / 15; // 1 week at 15s/block\n  uint64 constant _maxTradeFeeBasisPoints = 20 * 100; // 20%;\n  uint64 constant _maxWithdrawalFeeBasisPoints = 20 * 100; // 20%;\n\n  /**\n   * @notice Instantiate a new `Exchange` contract\n   *\n   * @dev Sets `_owner` and `_admin` to `msg.sender` */\n  constructor() public Owned() {}\n\n  /**\n   * @notice Sets the address of the `Custodian` contract\n   *\n   * @dev The `Custodian` accepts `Exchange` and `Governance` addresses in its constructor, after\n   * which they can only be changed by the `Governance` contract itself. Therefore the `Custodian`\n   * must be deployed last and its address set here on an existing `Exchange` contract. This value\n   * is immutable once set and cannot be changed again\n   *\n   * @param newCustodian The address of the `Custodian` contract deployed against this `Exchange`\n   * contract\u0027s address\n   */\n  function setCustodian(address payable newCustodian) external onlyAdmin {\n    require(_custodian == address(0x0), \u0027Custodian can only be set once\u0027);\n    require(Address.isContract(newCustodian), \u0027Invalid address\u0027);\n\n    _custodian = newCustodian;\n  }\n\n  /*** Tunable parameters ***/\n\n  /**\n   * @notice Sets a new Chain Propagation Period - the block delay after which order nonce invalidations\n   * are respected by `executeTrade` and wallet exits are respected by `executeTrade` and `withdraw`\n   *\n   * @param newChainPropagationPeriod The new Chain Propagation Period expressed as a number of blocks. Must\n   * be less than `_maxChainPropagationPeriod`\n   */\n  function setChainPropagationPeriod(uint256 newChainPropagationPeriod)\n    external\n    onlyAdmin\n  {\n    require(\n      newChainPropagationPeriod \u003c _maxChainPropagationPeriod,\n      \u0027Must be less than 1 week\u0027\n    );\n\n    uint256 oldChainPropagationPeriod = _chainPropagationPeriod;\n    _chainPropagationPeriod = newChainPropagationPeriod;\n\n    emit ChainPropagationPeriodChanged(\n      oldChainPropagationPeriod,\n      newChainPropagationPeriod\n    );\n  }\n\n  /**\n   * @notice Sets the address of the Fee wallet\n   *\n   * @dev Trade and Withdraw fees will accrue in the `_balancesInPips` mappings for this wallet\n   *\n   * @param newFeeWallet The new Fee wallet. Must be different from the current one\n   */\n  function setFeeWallet(address newFeeWallet) external onlyAdmin {\n    require(newFeeWallet != address(0x0), \u0027Invalid wallet address\u0027);\n    require(newFeeWallet != _feeWallet, \u0027Must be different from current\u0027);\n\n    address oldFeeWallet = _feeWallet;\n    _feeWallet = newFeeWallet;\n\n    emit FeeWalletChanged(oldFeeWallet, newFeeWallet);\n  }\n\n  // Accessors //\n\n  /**\n   * @notice Load a wallet\u0027s balance by asset address, in asset units\n   *\n   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`\n   * @param assetAddress The asset address to load the wallet\u0027s balance for\n   *\n   * @return The quantity denominated in asset units of asset at `assetAddress` currently\n   * deposited by `wallet`\n   */\n  function loadBalanceInAssetUnitsByAddress(\n    address wallet,\n    address assetAddress\n  ) external view returns (uint256) {\n    require(wallet != address(0x0), \u0027Invalid wallet address\u0027);\n\n    Structs.Asset memory asset = _assetRegistry.loadAssetByAddress(\n      assetAddress\n    );\n    return\n      AssetUnitConversions.pipsToAssetUnits(\n        _balancesInPips[wallet][assetAddress],\n        asset.decimals\n      );\n  }\n\n  /**\n   * @notice Load a wallet\u0027s balance by asset address, in asset units\n   *\n   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`\n   * @param assetSymbol The asset symbol to load the wallet\u0027s balance for\n   *\n   * @return The quantity denominated in asset units of asset `assetSymbol` currently deposited\n   * by `wallet`\n   */\n  function loadBalanceInAssetUnitsBySymbol(\n    address wallet,\n    string calldata assetSymbol\n  ) external view returns (uint256) {\n    require(wallet != address(0x0), \u0027Invalid wallet address\u0027);\n\n    Structs.Asset memory asset = _assetRegistry.loadAssetBySymbol(\n      assetSymbol,\n      getCurrentTimestampInMs()\n    );\n    return\n      AssetUnitConversions.pipsToAssetUnits(\n        _balancesInPips[wallet][asset.assetAddress],\n        asset.decimals\n      );\n  }\n\n  /**\n   * @notice Load a wallet\u0027s balance by asset address, in pips\n   *\n   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`\n   * @param assetAddress The asset address to load the wallet\u0027s balance for\n   *\n   * @return The quantity denominated in pips of asset at `assetAddress` currently deposited by `wallet`\n   */\n  function loadBalanceInPipsByAddress(address wallet, address assetAddress)\n    external\n    view\n    returns (uint64)\n  {\n    require(wallet != address(0x0), \u0027Invalid wallet address\u0027);\n\n    return _balancesInPips[wallet][assetAddress];\n  }\n\n  /**\n   * @notice Load a wallet\u0027s balance by asset symbol, in pips\n   *\n   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`\n   * @param assetSymbol The asset symbol to load the wallet\u0027s balance for\n   *\n   * @return The quantity denominated in pips of asset with `assetSymbol` currently deposited by `wallet`\n   */\n  function loadBalanceInPipsBySymbol(\n    address wallet,\n    string calldata assetSymbol\n  ) external view returns (uint64) {\n    require(wallet != address(0x0), \u0027Invalid wallet address\u0027);\n\n    address assetAddress = _assetRegistry\n      .loadAssetBySymbol(assetSymbol, getCurrentTimestampInMs())\n      .assetAddress;\n    return _balancesInPips[wallet][assetAddress];\n  }\n\n  /**\n   * @notice Load the address of the Fee wallet\n   *\n   * @return The address of the Fee wallet\n   */\n  function loadFeeWallet() external view returns (address) {\n    return _feeWallet;\n  }\n\n  /**\n   * @notice Load the quantity filled so far for a partially filled orders\n\n   * @dev Invalidating an order nonce will not clear partial fill quantities for earlier orders because\n   * the gas cost would potentially be unbound\n   *\n   * @param orderHash The order hash as originally signed by placing wallet that uniquely identifies an order\n   *\n   * @return For partially filled orders, the amount filled so far in pips. For orders in all other states, 0\n   */\n  function loadPartiallyFilledOrderQuantityInPips(bytes32 orderHash)\n    external\n    view\n    returns (uint64)\n  {\n    return _partiallyFilledOrderQuantitiesInPips[orderHash];\n  }\n\n  // Depositing //\n\n  /**\n   * @notice Deposit BNB\n   */\n  function depositEther() external payable {\n    deposit(msg.sender, address(0x0), msg.value);\n  }\n\n  /**\n   * @notice Deposit `IERC20` compliant tokens\n   *\n   * @param tokenAddress The token contract address\n   * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on\n   * the token contract for at least this quantity first\n   */\n  function depositTokenByAddress(\n    IERC20 tokenAddress,\n    uint256 quantityInAssetUnits\n  ) external {\n    require(address(tokenAddress) != address(0x0), \u0027Use depositEther for BNB\u0027);\n    deposit(msg.sender, address(tokenAddress), quantityInAssetUnits);\n  }\n\n  /**\n   * @notice Deposit `IERC20` compliant tokens\n   *\n   * @param assetSymbol The case-sensitive symbol string for the token\n   * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on\n   * the token contract for at least this quantity first\n   */\n  function depositTokenBySymbol(\n    string calldata assetSymbol,\n    uint256 quantityInAssetUnits\n  ) external {\n    IERC20 tokenAddress = IERC20(\n      _assetRegistry\n        .loadAssetBySymbol(assetSymbol, getCurrentTimestampInMs())\n        .assetAddress\n    );\n    require(address(tokenAddress) != address(0x0), \u0027Use depositEther for BNB\u0027);\n\n    deposit(msg.sender, address(tokenAddress), quantityInAssetUnits);\n  }\n\n  function deposit(\n    address payable wallet,\n    address assetAddress,\n    uint256 quantityInAssetUnits\n  ) private {\n    // Calling exitWallet disables deposits immediately on mining, in contrast to withdrawals and\n    // trades which respect the Chain Propagation Period given by `effectiveBlockNumber` via\n    // `isWalletExitFinalized`\n    require(!_walletExits[wallet].exists, \u0027Wallet exited\u0027);\n\n    Structs.Asset memory asset = _assetRegistry.loadAssetByAddress(\n      assetAddress\n    );\n    uint64 quantityInPips = AssetUnitConversions.assetUnitsToPips(\n      quantityInAssetUnits,\n      asset.decimals\n    );\n    require(quantityInPips \u003e 0, \u0027Quantity is too low\u0027);\n\n    // Convert from pips back into asset units to remove any fractional amount that is too small\n    // to express in pips. If the asset is BNB, this leftover fractional amount accumulates as dust\n    // in the `Exchange` contract. If the asset is a token the `Exchange` will call `transferFrom`\n    // without this fractional amount and there will be no dust\n    uint256 quantityInAssetUnitsWithoutFractionalPips = AssetUnitConversions\n      .pipsToAssetUnits(quantityInPips, asset.decimals);\n\n    // If the asset is BNB then the funds were already assigned to this contract via msg.value. If\n    // the asset is a token, additionally call the transferFrom function on the token contract for\n    // the pre-approved asset quantity\n    if (assetAddress != address(0x0)) {\n      AssetTransfers.transferFrom(\n        wallet,\n        IERC20(assetAddress),\n        quantityInAssetUnitsWithoutFractionalPips\n      );\n    }\n    // Forward the funds to the `Custodian`\n    AssetTransfers.transferTo(\n      _custodian,\n      assetAddress,\n      quantityInAssetUnitsWithoutFractionalPips\n    );\n\n    uint64 newExchangeBalanceInPips = _balancesInPips[wallet][assetAddress].add(\n      quantityInPips\n    );\n    uint256 newExchangeBalanceInAssetUnits = AssetUnitConversions\n      .pipsToAssetUnits(newExchangeBalanceInPips, asset.decimals);\n\n    // Update balance with actual transferred quantity\n    _balancesInPips[wallet][assetAddress] = newExchangeBalanceInPips;\n    _depositIndex++;\n\n    emit Deposited(\n      _depositIndex,\n      wallet,\n      assetAddress,\n      asset.symbol,\n      asset.symbol,\n      quantityInPips,\n      newExchangeBalanceInPips,\n      newExchangeBalanceInAssetUnits\n    );\n  }\n\n  // Invalidation //\n\n  /**\n   * @notice Invalidate all order nonces with a timestampInMs lower than the one provided\n   *\n   * @param nonce A Version 1 UUID. After calling and once the Chain Propagation Period has elapsed,\n   * `executeTrade` will reject order nonces from this wallet with a timestampInMs component lower than\n   * the one provided\n   */\n  function invalidateOrderNonce(uint128 nonce) external {\n    uint64 timestampInMs = UUID.getTimestampInMsFromUuidV1(nonce);\n    // Enforce a maximum skew for invalidating nonce timestamps in the future so the user doesn\u0027t\n    // lock their wallet from trades indefinitely\n    require(\n      timestampInMs \u003c getOneDayFromNowInMs(),\n      \u0027Nonce timestamp too far in future\u0027\n    );\n\n    if (_nonceInvalidations[msg.sender].exists) {\n      require(\n        _nonceInvalidations[msg.sender].timestampInMs \u003c timestampInMs,\n        \u0027Nonce timestamp already invalidated\u0027\n      );\n      require(\n        _nonceInvalidations[msg.sender].effectiveBlockNumber \u003c= block.number,\n        \u0027Previous invalidation awaiting chain propagation\u0027\n      );\n    }\n\n    // Changing the Chain Propagation Period will not affect the effectiveBlockNumber for this invalidation\n    uint256 effectiveBlockNumber = block.number + _chainPropagationPeriod;\n    _nonceInvalidations[msg.sender] = NonceInvalidation(\n      true,\n      timestampInMs,\n      effectiveBlockNumber\n    );\n\n    emit OrderNonceInvalidated(\n      msg.sender,\n      nonce,\n      timestampInMs,\n      effectiveBlockNumber\n    );\n  }\n\n  // Withdrawing //\n\n  /**\n   * @notice Settles a user withdrawal submitted off-chain. Calls restricted to currently whitelisted Dispatcher wallet\n   *\n   * @param withdrawal A `Structs.Withdrawal` struct encoding the parameters of the withdrawal\n   */\n  function withdraw(Structs.Withdrawal memory withdrawal)\n    public\n    override\n    onlyDispatcher\n  {\n    // Validations\n    require(!isWalletExitFinalized(withdrawal.walletAddress), \u0027Wallet exited\u0027);\n    require(\n      getFeeBasisPoints(withdrawal.gasFeeInPips, withdrawal.quantityInPips) \u003c=\n        _maxWithdrawalFeeBasisPoints,\n      \u0027Excessive withdrawal fee\u0027\n    );\n    bytes32 withdrawalHash = validateWithdrawalSignature(withdrawal);\n    require(\n      !_completedWithdrawalHashes[withdrawalHash],\n      \u0027Hash already withdrawn\u0027\n    );\n\n    // If withdrawal is by asset symbol (most common) then resolve to asset address\n    Structs.Asset memory asset = withdrawal.withdrawalType ==\n      Enums.WithdrawalType.BySymbol\n      ? _assetRegistry.loadAssetBySymbol(\n        withdrawal.assetSymbol,\n        UUID.getTimestampInMsFromUuidV1(withdrawal.nonce)\n      )\n      : _assetRegistry.loadAssetByAddress(withdrawal.assetAddress);\n\n    // SafeMath reverts if balance is overdrawn\n    uint64 netAssetQuantityInPips = withdrawal.quantityInPips.sub(\n      withdrawal.gasFeeInPips\n    );\n    uint256 netAssetQuantityInAssetUnits = AssetUnitConversions\n      .pipsToAssetUnits(netAssetQuantityInPips, asset.decimals);\n    uint64 newExchangeBalanceInPips = _balancesInPips[withdrawal\n      .walletAddress][asset.assetAddress]\n      .sub(withdrawal.quantityInPips);\n    uint256 newExchangeBalanceInAssetUnits = AssetUnitConversions\n      .pipsToAssetUnits(newExchangeBalanceInPips, asset.decimals);\n\n    _balancesInPips[withdrawal.walletAddress][asset\n      .assetAddress] = newExchangeBalanceInPips;\n    _balancesInPips[_feeWallet][asset\n      .assetAddress] = _balancesInPips[_feeWallet][asset.assetAddress].add(\n      withdrawal.gasFeeInPips\n    );\n\n    ICustodian(_custodian).withdraw(\n      withdrawal.walletAddress,\n      asset.assetAddress,\n      netAssetQuantityInAssetUnits\n    );\n\n    _completedWithdrawalHashes[withdrawalHash] = true;\n\n    emit Withdrawn(\n      withdrawal.walletAddress,\n      asset.assetAddress,\n      asset.symbol,\n      withdrawal.quantityInPips,\n      newExchangeBalanceInPips,\n      newExchangeBalanceInAssetUnits\n    );\n  }\n\n  // Wallet exits //\n\n  /**\n   * @notice Flags the sending wallet as exited, immediately disabling deposits upon mining.\n   * After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet,\n   * and assets may then be withdrawn one at a time via `withdrawExit`\n   */\n  function exitWallet() external {\n    require(!_walletExits[msg.sender].exists, \u0027Wallet already exited\u0027);\n\n    _walletExits[msg.sender] = WalletExit(\n      true,\n      block.number + _chainPropagationPeriod\n    );\n\n    emit WalletExited(msg.sender, block.number + _chainPropagationPeriod);\n  }\n\n  /**\n   * @notice Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must\n   * have already passed since calling `exitWallet` on `assetAddress`\n   *\n   * @param assetAddress The address of the asset to withdraw\n   */\n  function withdrawExit(address assetAddress) external {\n    require(isWalletExitFinalized(msg.sender), \u0027Wallet exit not finalized\u0027);\n\n    Structs.Asset memory asset = _assetRegistry.loadAssetByAddress(\n      assetAddress\n    );\n    uint64 balanceInPips = _balancesInPips[msg.sender][assetAddress];\n    uint256 balanceInAssetUnits = AssetUnitConversions.pipsToAssetUnits(\n      balanceInPips,\n      asset.decimals\n    );\n\n    require(balanceInAssetUnits \u003e 0, \u0027No balance for asset\u0027);\n    _balancesInPips[msg.sender][assetAddress] = 0;\n    ICustodian(_custodian).withdraw(\n      msg.sender,\n      assetAddress,\n      balanceInAssetUnits\n    );\n\n    emit WalletExitWithdrawn(\n      msg.sender,\n      assetAddress,\n      asset.symbol,\n      balanceInPips,\n      0,\n      0\n    );\n  }\n\n  /**\n   * @notice Clears exited status of sending wallet. Upon mining immediately enables\n   * deposits, trades, and withdrawals by sending wallet\n   */\n  function clearWalletExit() external {\n    require(_walletExits[msg.sender].exists, \u0027Wallet not exited\u0027);\n\n    delete _walletExits[msg.sender];\n\n    emit WalletExitCleared(msg.sender);\n  }\n\n  function isWalletExitFinalized(address wallet) internal view returns (bool) {\n    WalletExit storage exit = _walletExits[wallet];\n    return exit.exists \u0026\u0026 exit.effectiveBlockNumber \u003c= block.number;\n  }\n\n  // Trades //\n\n  /**\n   * @notice Settles a trade between two orders submitted and matched off-chain\n   *\n   * @dev As a gas optimization, base and quote symbols are passed in separately and combined to verify\n   * the wallet hash, since this is cheaper than splitting the market symbol into its two constituent asset symbols\n   * @dev Stack level too deep if declared external\n   *\n   * @param buy A `Structs.Order` struct encoding the parameters of the buy-side order (receiving base, giving quote)\n   * @param sell A `Structs.Order` struct encoding the parameters of the sell-side order (giving base, receiving quote)\n   * @param trade A `Structs.Trade` struct encoding the parameters of this trade execution of the counterparty orders\n   */\n  function executeTrade(\n    Structs.Order memory buy,\n    Structs.Order memory sell,\n    Structs.Trade memory trade\n  ) public override onlyDispatcher {\n    require(\n      !isWalletExitFinalized(buy.walletAddress),\n      \u0027Buy wallet exit finalized\u0027\n    );\n    require(\n      !isWalletExitFinalized(sell.walletAddress),\n      \u0027Sell wallet exit finalized\u0027\n    );\n    require(\n      buy.walletAddress != sell.walletAddress,\n      \u0027Self-trading not allowed\u0027\n    );\n\n    validateAssetPair(buy, sell, trade);\n    validateLimitPrices(buy, sell, trade);\n    validateOrderNonces(buy, sell);\n    (bytes32 buyHash, bytes32 sellHash) = validateOrderSignatures(\n      buy,\n      sell,\n      trade\n    );\n    validateTradeFees(trade);\n\n    updateOrderFilledQuantities(buy, buyHash, sell, sellHash, trade);\n    updateBalancesForTrade(buy, sell, trade);\n\n    emit TradeExecuted(\n      buy.walletAddress,\n      sell.walletAddress,\n      trade.baseAssetSymbol,\n      trade.quoteAssetSymbol,\n      trade.baseAssetSymbol,\n      trade.quoteAssetSymbol,\n      trade.grossBaseQuantityInPips,\n      trade.grossQuoteQuantityInPips,\n      trade.priceInPips,\n      buyHash,\n      sellHash\n    );\n  }\n\n  // Updates buyer, seller, and fee wallet balances for both assets in trade pair according to trade parameters\n  function updateBalancesForTrade(\n    Structs.Order memory buy,\n    Structs.Order memory sell,\n    Structs.Trade memory trade\n  ) private {\n    // Seller gives base asset including fees\n    _balancesInPips[sell.walletAddress][trade\n      .baseAssetAddress] = _balancesInPips[sell.walletAddress][trade\n      .baseAssetAddress]\n      .sub(trade.grossBaseQuantityInPips);\n    // Buyer receives base asset minus fees\n    _balancesInPips[buy.walletAddress][trade\n      .baseAssetAddress] = _balancesInPips[buy.walletAddress][trade\n      .baseAssetAddress]\n      .add(trade.netBaseQuantityInPips);\n\n    // Buyer gives quote asset including fees\n    _balancesInPips[buy.walletAddress][trade\n      .quoteAssetAddress] = _balancesInPips[buy.walletAddress][trade\n      .quoteAssetAddress]\n      .sub(trade.grossQuoteQuantityInPips);\n    // Seller receives quote asset minus fees\n    _balancesInPips[sell.walletAddress][trade\n      .quoteAssetAddress] = _balancesInPips[sell.walletAddress][trade\n      .quoteAssetAddress]\n      .add(trade.netQuoteQuantityInPips);\n\n    // Maker and taker fees to fee wallet\n    _balancesInPips[_feeWallet][trade\n      .makerFeeAssetAddress] = _balancesInPips[_feeWallet][trade\n      .makerFeeAssetAddress]\n      .add(trade.makerFeeQuantityInPips);\n    _balancesInPips[_feeWallet][trade\n      .takerFeeAssetAddress] = _balancesInPips[_feeWallet][trade\n      .takerFeeAssetAddress]\n      .add(trade.takerFeeQuantityInPips);\n  }\n\n  function updateOrderFilledQuantities(\n    Structs.Order memory buyOrder,\n    bytes32 buyOrderHash,\n    Structs.Order memory sellOrder,\n    bytes32 sellOrderHash,\n    Structs.Trade memory trade\n  ) private {\n    updateOrderFilledQuantity(buyOrder, buyOrderHash, trade);\n    updateOrderFilledQuantity(sellOrder, sellOrderHash, trade);\n  }\n\n  // Update filled quantities tracking for order to prevent over- or double-filling orders\n  function updateOrderFilledQuantity(\n    Structs.Order memory order,\n    bytes32 orderHash,\n    Structs.Trade memory trade\n  ) private {\n    require(!_completedOrderHashes[orderHash], \u0027Order double filled\u0027);\n\n    // Total quantity of above filled as a result of all trade executions, including this one\n    uint64 newFilledQuantityInPips;\n\n    // Market orders can express quantity in quote terms, and can be partially filled by multiple\n    // limit maker orders necessitating tracking partially filled amounts in quote terms to\n    // determine completion\n    if (order.isQuantityInQuote) {\n      require(\n        isMarketOrderType(order.orderType),\n        \u0027Order quote quantity only valid for market orders\u0027\n      );\n      newFilledQuantityInPips = trade.grossQuoteQuantityInPips.add(\n        _partiallyFilledOrderQuantitiesInPips[orderHash]\n      );\n    } else {\n      // All other orders track partially filled quantities in base terms\n      newFilledQuantityInPips = trade.grossBaseQuantityInPips.add(\n        _partiallyFilledOrderQuantitiesInPips[orderHash]\n      );\n    }\n\n    require(\n      newFilledQuantityInPips \u003c= order.quantityInPips,\n      \u0027Order overfilled\u0027\n    );\n\n    if (newFilledQuantityInPips \u003c order.quantityInPips) {\n      // If the order was partially filled, track the new filled quantity\n      _partiallyFilledOrderQuantitiesInPips[orderHash] = newFilledQuantityInPips;\n    } else {\n      // If the order was completed, delete any partial fill tracking and instead track its completion\n      // to prevent future double fills\n      delete _partiallyFilledOrderQuantitiesInPips[orderHash];\n      _completedOrderHashes[orderHash] = true;\n    }\n  }\n\n  // Validations //\n\n  function validateAssetPair(\n    Structs.Order memory buy,\n    Structs.Order memory sell,\n    Structs.Trade memory trade\n  ) private view {\n    require(\n      trade.baseAssetAddress != trade.quoteAssetAddress,\n      \u0027Base and quote assets must be different\u0027\n    );\n\n    // Buy order market pair\n    Structs.Asset memory buyBaseAsset = _assetRegistry.loadAssetBySymbol(\n      trade.baseAssetSymbol,\n      UUID.getTimestampInMsFromUuidV1(buy.nonce)\n    );\n    Structs.Asset memory buyQuoteAsset = _assetRegistry.loadAssetBySymbol(\n      trade.quoteAssetSymbol,\n      UUID.getTimestampInMsFromUuidV1(buy.nonce)\n    );\n    require(\n      buyBaseAsset.assetAddress == trade.baseAssetAddress \u0026\u0026\n        buyQuoteAsset.assetAddress == trade.quoteAssetAddress,\n      \u0027Buy order market symbol address resolution mismatch\u0027\n    );\n\n    // Sell order market pair\n    Structs.Asset memory sellBaseAsset = _assetRegistry.loadAssetBySymbol(\n      trade.baseAssetSymbol,\n      UUID.getTimestampInMsFromUuidV1(sell.nonce)\n    );\n    Structs.Asset memory sellQuoteAsset = _assetRegistry.loadAssetBySymbol(\n      trade.quoteAssetSymbol,\n      UUID.getTimestampInMsFromUuidV1(sell.nonce)\n    );\n    require(\n      sellBaseAsset.assetAddress == trade.baseAssetAddress \u0026\u0026\n        sellQuoteAsset.assetAddress == trade.quoteAssetAddress,\n      \u0027Sell order market symbol address resolution mismatch\u0027\n    );\n\n    // Fee asset validation\n    require(\n      trade.makerFeeAssetAddress == trade.baseAssetAddress ||\n        trade.makerFeeAssetAddress == trade.quoteAssetAddress,\n      \u0027Maker fee asset is not in trade pair\u0027\n    );\n    require(\n      trade.takerFeeAssetAddress == trade.baseAssetAddress ||\n        trade.takerFeeAssetAddress == trade.quoteAssetAddress,\n      \u0027Taker fee asset is not in trade pair\u0027\n    );\n    require(\n      trade.makerFeeAssetAddress != trade.takerFeeAssetAddress,\n      \u0027Maker and taker fee assets must be different\u0027\n    );\n  }\n\n  function validateLimitPrices(\n    Structs.Order memory buy,\n    Structs.Order memory sell,\n    Structs.Trade memory trade\n  ) private pure {\n    require(\n      trade.grossBaseQuantityInPips \u003e 0,\n      \u0027Base quantity must be greater than zero\u0027\n    );\n    require(\n      trade.grossQuoteQuantityInPips \u003e 0,\n      \u0027Quote quantity must be greater than zero\u0027\n    );\n\n    if (isLimitOrderType(buy.orderType)) {\n      require(\n        getImpliedQuoteQuantityInPips(\n          trade.grossBaseQuantityInPips,\n          buy.limitPriceInPips\n        ) \u003e= trade.grossQuoteQuantityInPips,\n        \u0027Buy order limit price exceeded\u0027\n      );\n    }\n\n    if (isLimitOrderType(sell.orderType)) {\n      require(\n        getImpliedQuoteQuantityInPips(\n          trade.grossBaseQuantityInPips,\n          sell.limitPriceInPips\n        ) \u003c= trade.grossQuoteQuantityInPips,\n        \u0027Sell order limit price exceeded\u0027\n      );\n    }\n  }\n\n  function validateTradeFees(Structs.Trade memory trade) private pure {\n    uint64 makerTotalQuantityInPips = trade.makerFeeAssetAddress ==\n      trade.baseAssetAddress\n      ? trade.grossBaseQuantityInPips\n      : trade.grossQuoteQuantityInPips;\n    require(\n      getFeeBasisPoints(\n        trade.makerFeeQuantityInPips,\n        makerTotalQuantityInPips\n      ) \u003c= _maxTradeFeeBasisPoints,\n      \u0027Excessive maker fee\u0027\n    );\n\n    uint64 takerTotalQuantityInPips = trade.takerFeeAssetAddress ==\n      trade.baseAssetAddress\n      ? trade.grossBaseQuantityInPips\n      : trade.grossQuoteQuantityInPips;\n    require(\n      getFeeBasisPoints(\n        trade.takerFeeQuantityInPips,\n        takerTotalQuantityInPips\n      ) \u003c= _maxTradeFeeBasisPoints,\n      \u0027Excessive taker fee\u0027\n    );\n\n    require(\n      trade.netBaseQuantityInPips.add(\n        trade.makerFeeAssetAddress == trade.baseAssetAddress\n          ? trade.makerFeeQuantityInPips\n          : trade.takerFeeQuantityInPips\n      ) == trade.grossBaseQuantityInPips,\n      \u0027Net base plus fee is not equal to gross\u0027\n    );\n    require(\n      trade.netQuoteQuantityInPips.add(\n        trade.makerFeeAssetAddress == trade.quoteAssetAddress\n          ? trade.makerFeeQuantityInPips\n          : trade.takerFeeQuantityInPips\n      ) == trade.grossQuoteQuantityInPips,\n      \u0027Net quote plus fee is not equal to gross\u0027\n    );\n  }\n\n  function validateOrderSignatures(\n    Structs.Order memory buy,\n    Structs.Order memory sell,\n    Structs.Trade memory trade\n  ) private pure returns (bytes32, bytes32) {\n    bytes32 buyOrderHash = validateOrderSignature(buy, trade);\n    bytes32 sellOrderHash = validateOrderSignature(sell, trade);\n\n    return (buyOrderHash, sellOrderHash);\n  }\n\n  function validateOrderSignature(\n    Structs.Order memory order,\n    Structs.Trade memory trade\n  ) private pure returns (bytes32) {\n    bytes32 orderHash = Signatures.getOrderWalletHash(\n      order,\n      trade.baseAssetSymbol,\n      trade.quoteAssetSymbol\n    );\n\n    require(\n      Signatures.isSignatureValid(\n        orderHash,\n        order.walletSignature,\n        order.walletAddress\n      ),\n      order.side == Enums.OrderSide.Buy\n        ? \u0027Invalid wallet signature for buy order\u0027\n        : \u0027Invalid wallet signature for sell order\u0027\n    );\n\n    return orderHash;\n  }\n\n  function validateOrderNonces(\n    Structs.Order memory buy,\n    Structs.Order memory sell\n  ) private view {\n    require(\n      UUID.getTimestampInMsFromUuidV1(buy.nonce) \u003e\n        getLastInvalidatedTimestamp(buy.walletAddress),\n      \u0027Buy order nonce timestamp too low\u0027\n    );\n    require(\n      UUID.getTimestampInMsFromUuidV1(sell.nonce) \u003e\n        getLastInvalidatedTimestamp(sell.walletAddress),\n      \u0027Sell order nonce timestamp too low\u0027\n    );\n  }\n\n  function validateWithdrawalSignature(Structs.Withdrawal memory withdrawal)\n    private\n    pure\n    returns (bytes32)\n  {\n    bytes32 withdrawalHash = Signatures.getWithdrawalWalletHash(withdrawal);\n\n    require(\n      Signatures.isSignatureValid(\n        withdrawalHash,\n        withdrawal.walletSignature,\n        withdrawal.walletAddress\n      ),\n      \u0027Invalid wallet signature\u0027\n    );\n\n    return withdrawalHash;\n  }\n\n  // Asset registry //\n\n  /**\n   * @notice Initiate registration process for a token asset. Only `IERC20` compliant tokens can be\n   * added - BNB is hardcoded in the registry\n   *\n   * @param tokenAddress The address of the `IERC20` compliant token contract to add\n   * @param symbol The symbol identifying the token asset\n   * @param decimals The decimal precision of the token\n   */\n  function registerToken(\n    IERC20 tokenAddress,\n    string calldata symbol,\n    uint8 decimals\n  ) external onlyAdmin {\n    _assetRegistry.registerToken(tokenAddress, symbol, decimals);\n    emit TokenRegistered(tokenAddress, symbol, decimals);\n  }\n\n  /**\n   * @notice Finalize registration process for a token asset. All parameters must exactly match a previous\n   * call to `registerToken`\n   *\n   * @param tokenAddress The address of the `IERC20` compliant token contract to add\n   * @param symbol The symbol identifying the token asset\n   * @param decimals The decimal precision of the token\n   */\n  function confirmTokenRegistration(\n    IERC20 tokenAddress,\n    string calldata symbol,\n    uint8 decimals\n  ) external onlyAdmin {\n    _assetRegistry.confirmTokenRegistration(tokenAddress, symbol, decimals);\n    emit TokenRegistrationConfirmed(tokenAddress, symbol, decimals);\n  }\n\n  /**\n   * @notice Add a symbol to a token that has already been registered and confirmed\n   *\n   * @param tokenAddress The address of the `IERC20` compliant token contract the symbol will identify\n   * @param symbol The symbol identifying the token asset\n   */\n  function addTokenSymbol(IERC20 tokenAddress, string calldata symbol)\n    external\n    onlyAdmin\n  {\n    _assetRegistry.addTokenSymbol(tokenAddress, symbol);\n    emit TokenSymbolAdded(tokenAddress, symbol);\n  }\n\n  /**\n   * @notice Loads an asset descriptor struct by its symbol and timestamp\n   *\n   * @dev Since multiple token addresses can potentially share the same symbol (in case of a token\n   * swap/contract upgrade) the provided `timestampInMs` is compared against each asset\u0027s\n   * `confirmedTimestampInMs` to uniquely determine the newest asset for the symbol at that point in time\n   *\n   * @param assetSymbol The asset\u0027s symbol\n   * @param timestampInMs Point in time used to disambiguate multiple tokens with same symbol\n   *\n   * @return A `Structs.Asset` record describing the asset\n   */\n  function loadAssetBySymbol(string calldata assetSymbol, uint64 timestampInMs)\n    external\n    view\n    returns (Structs.Asset memory)\n  {\n    return _assetRegistry.loadAssetBySymbol(assetSymbol, timestampInMs);\n  }\n\n  // Dispatcher whitelisting //\n\n  /**\n   * @notice Sets the wallet whitelisted to dispatch transactions calling the `executeTrade` and `withdraw` functions\n   *\n   * @param newDispatcherWallet The new whitelisted dispatcher wallet. Must be different from the current one\n   */\n  function setDispatcher(address newDispatcherWallet) external onlyAdmin {\n    require(newDispatcherWallet != address(0x0), \u0027Invalid wallet address\u0027);\n    require(\n      newDispatcherWallet != _dispatcherWallet,\n      \u0027Must be different from current\u0027\n    );\n    address oldDispatcherWallet = _dispatcherWallet;\n    _dispatcherWallet = newDispatcherWallet;\n\n    emit DispatcherChanged(oldDispatcherWallet, newDispatcherWallet);\n  }\n\n  /**\n   * @notice Clears the currently set whitelisted dispatcher wallet, effectively disabling calling the\n   * `executeTrade` and `withdraw` functions until a new wallet is set with `setDispatcher`\n   */\n  function removeDispatcher() external onlyAdmin {\n    emit DispatcherChanged(_dispatcherWallet, address(0x0));\n    _dispatcherWallet = address(0x0);\n  }\n\n  modifier onlyDispatcher() {\n    require(msg.sender == _dispatcherWallet, \u0027Caller is not dispatcher\u0027);\n    _;\n  }\n\n  // Utils //\n\n  function isLimitOrderType(Enums.OrderType orderType)\n    private\n    pure\n    returns (bool)\n  {\n    return\n      orderType == Enums.OrderType.Limit ||\n      orderType == Enums.OrderType.LimitMaker ||\n      orderType == Enums.OrderType.StopLossLimit ||\n      orderType == Enums.OrderType.TakeProfitLimit;\n  }\n\n  function isMarketOrderType(Enums.OrderType orderType)\n    private\n    pure\n    returns (bool)\n  {\n    return\n      orderType == Enums.OrderType.Market ||\n      orderType == Enums.OrderType.StopLoss ||\n      orderType == Enums.OrderType.TakeProfit;\n  }\n\n  function getCurrentTimestampInMs() private view returns (uint64) {\n    uint64 msInOneSecond = 1000;\n\n    return uint64(block.timestamp) * msInOneSecond;\n  }\n\n  function getFeeBasisPoints(uint64 fee, uint64 total)\n    private\n    pure\n    returns (uint64)\n  {\n    uint64 basisPointsInTotal = 100 * 100; // 100 basis points/percent * 100 percent/total\n    return fee.mul(basisPointsInTotal).div(total);\n  }\n\n  function getImpliedQuoteQuantityInPips(\n    uint64 baseQuantityInPips,\n    uint64 limitPriceInPips\n  ) private pure returns (uint64) {\n    // To convert a fractional price to integer pips, shift right by the pip precision of 8 decimals\n    uint256 pipsMultiplier = 10**8;\n\n    uint256 impliedQuoteQuantityInPips = uint256(baseQuantityInPips)\n      .mul(uint256(limitPriceInPips))\n      .div(pipsMultiplier);\n    require(\n      impliedQuoteQuantityInPips \u003c 2**64,\n      \u0027Implied quote pip quantity overflows uint64\u0027\n    );\n\n    return uint64(impliedQuoteQuantityInPips);\n  }\n\n  function getLastInvalidatedTimestamp(address walletAddress)\n    private\n    view\n    returns (uint64)\n  {\n    if (\n      _nonceInvalidations[walletAddress].exists \u0026\u0026\n      _nonceInvalidations[walletAddress].effectiveBlockNumber \u003c= block.number\n    ) {\n      return _nonceInvalidations[walletAddress].timestampInMs;\n    }\n\n    return 0;\n  }\n\n  function getOneDayFromNowInMs() private view returns (uint64) {\n    uint64 secondsInOneDay = 24 * 60 * 60; // 24 hours/day * 60 min/hour * 60 seconds/min\n    uint64 msInOneSecond = 1000;\n\n    return (uint64(block.timestamp) + secondsInOneDay) * msInOneSecond;\n  }\n}\n"},"Interfaces.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @notice Enums used in `Order` and `Withdrawal` structs\n */\ncontract Enums {\n  enum OrderSelfTradePrevention {\n    // Decrement and cancel\n    dc,\n    // Cancel oldest\n    co,\n    // Cancel newest\n    cn,\n    // Cancel both\n    cb\n  }\n  enum OrderSide { Buy, Sell }\n  enum OrderTimeInForce {\n    // Good until cancelled\n    gtc,\n    // Good until time\n    gtt,\n    // Immediate or cancel\n    ioc,\n    // Fill or kill\n    fok\n  }\n  enum OrderType {\n    Market,\n    Limit,\n    LimitMaker,\n    StopLoss,\n    StopLossLimit,\n    TakeProfit,\n    TakeProfitLimit\n  }\n  enum WithdrawalType { BySymbol, ByAddress }\n}\n\n\n/**\n * @notice Struct definitions\n */\ncontract Structs {\n  /**\n   * @notice Argument type for `Exchange.executeTrade` and `Signatures.getOrderWalletHash`\n   */\n  struct Order {\n    // Not currently used but reserved for future use. Must be 2\n    uint8 signatureHashVersion;\n    // UUIDv1 unique to wallet\n    uint128 nonce;\n    // Wallet address that placed order and signed hash\n    address walletAddress;\n    // Type of order\n    Enums.OrderType orderType;\n    // Order side wallet is on\n    Enums.OrderSide side;\n    // Order quantity in base or quote asset terms depending on isQuantityInQuote flag\n    uint64 quantityInPips;\n    // Is quantityInPips in quote terms\n    bool isQuantityInQuote;\n    // For limit orders, price in decimal pips * 10^8 in quote terms\n    uint64 limitPriceInPips;\n    // For stop orders, stop loss or take profit price in decimal pips * 10^8 in quote terms\n    uint64 stopPriceInPips;\n    // Optional custom client order ID\n    string clientOrderId;\n    // TIF option specified by wallet for order\n    Enums.OrderTimeInForce timeInForce;\n    // STP behavior specified by wallet for order\n    Enums.OrderSelfTradePrevention selfTradePrevention;\n    // Cancellation time specified by wallet for GTT TIF order\n    uint64 cancelAfter;\n    // The ECDSA signature of the order hash as produced by Signatures.getOrderWalletHash\n    bytes walletSignature;\n  }\n\n  /**\n   * @notice Return type for `Exchange.loadAssetBySymbol`, and `Exchange.loadAssetByAddress`; also\n   * used internally by `AssetRegistry`\n   */\n  struct Asset {\n    // Flag to distinguish from empty struct\n    bool exists;\n    // The asset\u0027s address\n    address assetAddress;\n    // The asset\u0027s symbol\n    string symbol;\n    // The asset\u0027s decimal precision\n    uint8 decimals;\n    // Flag set when asset registration confirmed. Asset deposits, trades, or withdrawals only allowed if true\n    bool isConfirmed;\n    // Timestamp as ms since Unix epoch when isConfirmed was asserted\n    uint64 confirmedTimestampInMs;\n  }\n\n  /**\n   * @notice Argument type for `Exchange.executeTrade` specifying execution parameters for matching orders\n   */\n  struct Trade {\n    // Base asset symbol\n    string baseAssetSymbol;\n    // Quote asset symbol\n    string quoteAssetSymbol;\n    // Base asset address\n    address baseAssetAddress;\n    // Quote asset address\n    address quoteAssetAddress;\n    // Gross amount including fees of base asset executed\n    uint64 grossBaseQuantityInPips;\n    // Gross amount including fees of quote asset executed\n    uint64 grossQuoteQuantityInPips;\n    // Net amount of base asset received by buy side wallet after fees\n    uint64 netBaseQuantityInPips;\n    // Net amount of quote asset received by sell side wallet after fees\n    uint64 netQuoteQuantityInPips;\n    // Asset address for liquidity maker\u0027s fee\n    address makerFeeAssetAddress;\n    // Asset address for liquidity taker\u0027s fee\n    address takerFeeAssetAddress;\n    // Fee paid by liquidity maker\n    uint64 makerFeeQuantityInPips;\n    // Fee paid by liquidity taker\n    uint64 takerFeeQuantityInPips;\n    // Execution price of trade in decimal pips * 10^8 in quote terms\n    uint64 priceInPips;\n    // Which side of the order (buy or sell) the liquidity maker was on\n    Enums.OrderSide makerSide;\n  }\n\n  /**\n   * @notice Argument type for `Exchange.withdraw` and `Signatures.getWithdrawalWalletHash`\n   */\n  struct Withdrawal {\n    // Distinguishes between withdrawals by asset symbol or address\n    Enums.WithdrawalType withdrawalType;\n    // UUIDv1 unique to wallet\n    uint128 nonce;\n    // Address of wallet to which funds will be returned\n    address payable walletAddress;\n    // Asset symbol\n    string assetSymbol;\n    // Asset address\n    address assetAddress; // Used when assetSymbol not specified\n    // Withdrawal quantity\n    uint64 quantityInPips;\n    // Gas fee deducted from withdrawn quantity to cover dispatcher tx costs\n    uint64 gasFeeInPips;\n    // Not currently used but reserved for future use. Must be true\n    bool autoDispatchEnabled;\n    // The ECDSA signature of the withdrawal hash as produced by Signatures.getWithdrawalWalletHash\n    bytes walletSignature;\n  }\n}\n\n\n/**\n * @notice Interface of the ERC20 standard as defined in the EIP, but with no return values for\n * transfer and transferFrom. By asserting expected balance changes when calling these two methods\n * we can safely ignore their return values. This allows support of non-compliant tokens that do not\n * return a boolean. See https://github.com/ethereum/solidity/issues/4116\n */\ninterface IERC20 {\n  /**\n   * @notice Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @notice Moves `amount` tokens from the caller\u0027s account to `recipient`.\n   *\n   * Most implementing contracts return a boolean value indicating whether the operation succeeded, but\n   * we ignore this and rely on asserting balance changes instead\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external;\n\n  /**\n   * @notice Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @notice Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender\u0027s allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @notice Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller\u0027s\n   * allowance.\n   *\n   * Most implementing contracts return a boolean value indicating whether the operation succeeded, but\n   * we ignore this and rely on asserting balance changes instead\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @notice Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @notice Interface to Custodian contract. Used by Exchange and Governance contracts for internal\n * delegate calls\n */\ninterface ICustodian {\n  /**\n   * @notice BNB can only be sent by the Exchange\n   */\n  receive() external payable;\n\n  /**\n   * @notice Withdraw any asset and amount to a target wallet\n   *\n   * @dev No balance checking performed\n   *\n   * @param wallet The wallet to which assets will be returned\n   * @param asset The address of the asset to withdraw (BNB or ERC-20 contract)\n   * @param quantityInAssetUnits The quantity in asset units to withdraw\n   */\n  function withdraw(\n    address payable wallet,\n    address asset,\n    uint256 quantityInAssetUnits\n  ) external;\n\n  /**\n   * @notice Load address of the currently whitelisted Exchange contract\n   *\n   * @return The address of the currently whitelisted Exchange contract\n   */\n  function loadExchange() external view returns (address);\n\n  /**\n   * @notice Sets a new Exchange contract address\n   *\n   * @param newExchange The address of the new whitelisted Exchange contract\n   */\n  function setExchange(address newExchange) external;\n\n  /**\n   * @notice Load address of the currently whitelisted Governance contract\n   *\n   * @return The address of the currently whitelisted Governance contract\n   */\n  function loadGovernance() external view returns (address);\n\n  /**\n   * @notice Sets a new Governance contract address\n   *\n   * @param newGovernance The address of the new whitelisted Governance contract\n   */\n  function setGovernance(address newGovernance) external;\n}\n\n\n/**\n * @notice Interface to Exchange contract. Provided only to document struct usage\n */\ninterface IExchange {\n  /**\n   * @notice Settles a trade between two orders submitted and matched off-chain\n   *\n   * @param buy A `Structs.Order` struct encoding the parameters of the buy-side order (receiving base, giving quote)\n   * @param sell A `Structs.Order` struct encoding the parameters of the sell-side order (giving base, receiving quote)\n   * @param trade A `Structs.Trade` struct encoding the parameters of this trade execution of the counterparty orders\n   */\n  function executeTrade(\n    Structs.Order calldata buy,\n    Structs.Order calldata sell,\n    Structs.Trade calldata trade\n  ) external;\n\n  /**\n   * @notice Settles a user withdrawal submitted off-chain. Calls restricted to currently whitelisted Dispatcher wallet\n   *\n   * @param withdrawal A `Structs.Withdrawal` struct encoding the parameters of the withdrawal\n   */\n  function withdraw(Structs.Withdrawal calldata withdrawal) external;\n}\n"},"Migrations.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\n// IGNORE This is generated by Truffle\n// https://www.trufflesuite.com/docs/truffle/getting-started/running-migrations#initial-migration\n\npragma solidity 0.6.8;\n\n\ncontract Migrations {\n  address public owner;\n  uint256 public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint256 completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n"},"Owned.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\npragma solidity 0.6.8;\n\n\n/**\n * @notice Mixin that provide separate owner and admin roles for RBAC\n */\nabstract contract Owned {\n  address immutable _owner;\n  address _admin;\n\n  modifier onlyOwner {\n    require(msg.sender == _owner, \u0027Caller must be owner\u0027);\n    _;\n  }\n  modifier onlyAdmin {\n    require(msg.sender == _admin, \u0027Caller must be admin\u0027);\n    _;\n  }\n\n  /**\n   * @notice Sets both the owner and admin roles to the contract creator\n   */\n  constructor() public {\n    _owner = msg.sender;\n    _admin = msg.sender;\n  }\n\n  /**\n   * @notice Sets a new whitelisted admin wallet\n   *\n   * @param newAdmin The new whitelisted admin wallet. Must be different from the current one\n   */\n  function setAdmin(address newAdmin) external onlyOwner {\n    require(newAdmin != address(0x0), \u0027Invalid wallet address\u0027);\n    require(newAdmin != _admin, \u0027Must be different from current admin\u0027);\n\n    _admin = newAdmin;\n  }\n\n  /**\n   * @notice Clears the currently whitelisted admin wallet, effectively disabling any functions requiring\n   * the admin role\n   */\n  function removeAdmin() external onlyOwner {\n    _admin = address(0x0);\n  }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"SafeMath64.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\npragma solidity 0.6.8;\n\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath64 {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(uint64 a, uint64 b) internal pure returns (uint64) {\n    uint64 c = a + b;\n    require(c \u003e= a, \u0027SafeMath: addition overflow\u0027);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n    return sub(a, b, \u0027SafeMath: subtraction overflow\u0027);\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   *\n   * _Available since v2.4.0._\n   */\n  function sub(\n    uint64 a,\n    uint64 b,\n    string memory errorMessage\n  ) internal pure returns (uint64) {\n    require(b \u003c= a, errorMessage);\n    uint64 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n    // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n    // benefit is lost if \u0027b\u0027 is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint64 c = a * b;\n    require(c / a == b, \u0027SafeMath: multiplication overflow\u0027);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint64 a, uint64 b) internal pure returns (uint64) {\n    return div(a, b, \u0027SafeMath: division by zero\u0027);\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   *\n   * _Available since v2.4.0._\n   */\n  function div(\n    uint64 a,\n    uint64 b,\n    string memory errorMessage\n  ) internal pure returns (uint64) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b \u003e 0, errorMessage);\n    uint64 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n    return c;\n  }\n}\n"},"Signatures.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport { ECDSA } from \u0027./ECDSA.sol\u0027;\n\nimport { Enums, Structs } from \u0027./Interfaces.sol\u0027;\n\n\n/**\n * Library helpers for building hashes and verifying wallet signatures on `Order` and `Withdrawal` structs\n */\nlibrary Signatures {\n  function isSignatureValid(\n    bytes32 hash,\n    bytes memory signature,\n    address signer\n  ) internal pure returns (bool) {\n    return\n      ECDSA.recover(ECDSA.toEthSignedMessageHash(hash), signature) == signer;\n  }\n\n  function getOrderWalletHash(\n    Structs.Order memory order,\n    string memory baseSymbol,\n    string memory quoteSymbol\n  ) internal pure returns (bytes32) {\n    require(\n      order.signatureHashVersion == 2,\n      \u0027Signature hash version must be 2\u0027\n    );\n    return\n      keccak256(\n        // Placing all the fields in a single `abi.encodePacked` call causes a `stack too deep` error\n        abi.encodePacked(\n          abi.encodePacked(\n            order.signatureHashVersion,\n            order.nonce,\n            order.walletAddress,\n            getMarketSymbol(baseSymbol, quoteSymbol),\n            uint8(order.orderType),\n            uint8(order.side),\n            // Ledger qtys and prices are in pip, but order was signed by wallet owner with decimal values\n            pipToDecimal(order.quantityInPips)\n          ),\n          abi.encodePacked(\n            order.isQuantityInQuote,\n            order.limitPriceInPips \u003e 0\n              ? pipToDecimal(order.limitPriceInPips)\n              : \u0027\u0027,\n            order.stopPriceInPips \u003e 0\n              ? pipToDecimal(order.stopPriceInPips)\n              : \u0027\u0027,\n            order.clientOrderId,\n            uint8(order.timeInForce),\n            uint8(order.selfTradePrevention),\n            order.cancelAfter\n          )\n        )\n      );\n  }\n\n  function getWithdrawalWalletHash(Structs.Withdrawal memory withdrawal)\n    internal\n    pure\n    returns (bytes32)\n  {\n    return\n      keccak256(\n        abi.encodePacked(\n          withdrawal.nonce,\n          withdrawal.walletAddress,\n          // Ternary branches must resolve to the same type, so wrap in idempotent encodePacked\n          withdrawal.withdrawalType == Enums.WithdrawalType.BySymbol\n            ? abi.encodePacked(withdrawal.assetSymbol)\n            : abi.encodePacked(withdrawal.assetAddress),\n          pipToDecimal(withdrawal.quantityInPips),\n          withdrawal.autoDispatchEnabled\n        )\n      );\n  }\n\n  /**\n   * @dev Combines base and quote asset symbols into the market symbol originally signed by the\n   * wallet. For example if base is \u0027IDEX\u0027 and quote is \u0027BNB\u0027, the resulting market symbol is\n   * \u0027IDEX-BNB\u0027. This approach is used rather than passing in the market symbol and splitting it\n   * since the latter incurs a higher gas cost\n   */\n  function getMarketSymbol(string memory baseSymbol, string memory quoteSymbol)\n    private\n    pure\n    returns (string memory)\n  {\n    bytes memory baseSymbolBytes = bytes(baseSymbol);\n    bytes memory hyphenBytes = bytes(\u0027-\u0027);\n    bytes memory quoteSymbolBytes = bytes(quoteSymbol);\n\n    bytes memory marketSymbolBytes = bytes(\n      new string(\n        baseSymbolBytes.length + quoteSymbolBytes.length + hyphenBytes.length\n      )\n    );\n\n    uint256 i;\n    uint256 j;\n\n    for (i = 0; i \u003c baseSymbolBytes.length; i++) {\n      marketSymbolBytes[j++] = baseSymbolBytes[i];\n    }\n\n    // Hyphen is one byte\n    marketSymbolBytes[j++] = hyphenBytes[0];\n\n    for (i = 0; i \u003c quoteSymbolBytes.length; i++) {\n      marketSymbolBytes[j++] = quoteSymbolBytes[i];\n    }\n\n    return string(marketSymbolBytes);\n  }\n\n  /**\n   * @dev Converts an integer pip quantity back into the fixed-precision decimal pip string\n   * originally signed by the wallet. For example, 1234567890 becomes \u002712.34567890\u0027\n   */\n  function pipToDecimal(uint256 pips) private pure returns (string memory) {\n    // Inspired by https://github.com/provable-things/ethereum-api/blob/831f4123816f7a3e57ebea171a3cdcf3b528e475/oraclizeAPI_0.5.sol#L1045-L1062\n    uint256 copy = pips;\n    uint256 length;\n    while (copy != 0) {\n      length++;\n      copy /= 10;\n    }\n    if (length \u003c 9) {\n      length = 9; // a zero before the decimal point plus 8 decimals\n    }\n    length++; // for the decimal point\n\n    bytes memory decimal = new bytes(length);\n    for (uint256 i = length; i \u003e 0; i--) {\n      if (length - i == 8) {\n        decimal[i - 1] = bytes1(uint8(46)); // period\n      } else {\n        decimal[i - 1] = bytes1(uint8(48 + (pips % 10)));\n        pips /= 10;\n      }\n    }\n    return string(decimal);\n  }\n}\n"},"UUID.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\npragma solidity 0.6.8;\n\nimport { SafeMath64 } from \u0027./SafeMath64.sol\u0027;\n\n\n/**\n * Library helper for extracting timestamp component of Version 1 UUIDs\n */\nlibrary UUID {\n  using SafeMath64 for uint64;\n\n  /**\n   * Extracts the timestamp component of a Version 1 UUID. Used to make time-based assertions\n   * against a wallet-privided nonce\n   */\n  function getTimestampInMsFromUuidV1(uint128 uuid)\n    internal\n    pure\n    returns (uint64 msSinceUnixEpoch)\n  {\n    // https://tools.ietf.org/html/rfc4122#section-4.1.2\n    uint128 version = (uuid \u003e\u003e 76) \u0026 0x0000000000000000000000000000000F;\n    require(version == 1, \u0027Must be v1 UUID\u0027);\n\n    // Time components are in reverse order so shift+mask each to reassemble\n    uint128 timeHigh = (uuid \u003e\u003e 16) \u0026 0x00000000000000000FFF000000000000;\n    uint128 timeMid = (uuid \u003e\u003e 48) \u0026 0x00000000000000000000FFFF00000000;\n    uint128 timeLow = (uuid \u003e\u003e 96) \u0026 0x000000000000000000000000FFFFFFFF;\n    uint128 nsSinceGregorianEpoch = (timeHigh | timeMid | timeLow);\n    // Gregorian offset given in seconds by https://www.wolframalpha.com/input/?i=convert+1582-10-15+UTC+to+unix+time\n    msSinceUnixEpoch = uint64(nsSinceGregorianEpoch / 10000).sub(\n      12219292800000\n    );\n\n    return msSinceUnixEpoch;\n  }\n}\n"}}