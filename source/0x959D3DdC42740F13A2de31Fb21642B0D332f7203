{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"Holdefi.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\nimport \"./HoldefiPausableOwnable.sol\";\r\nimport \"./HoldefiCollaterals.sol\";\r\n\r\n\r\n/// @notice File: contracts/HoldefiPrices.sol\r\ninterface HoldefiPricesInterface {\r\n\tfunction getAssetValueFromAmount(address asset, uint256 amount) external view returns(uint256 value);\r\n\tfunction getAssetAmountFromValue(address asset, uint256 value) external view returns(uint256 amount);\t\r\n}\r\n\r\n/// @notice File: contracts/HoldefiSettings.sol\r\ninterface HoldefiSettingsInterface {\r\n\r\n\t/// @notice Markets Features\r\n\tstruct MarketSettings {\r\n\t\tbool isExist;\r\n\t\tbool isActive;      \r\n\r\n\t\tuint256 borrowRate;\r\n\t\tuint256 borrowRateUpdateTime;\r\n\r\n\t\tuint256 suppliersShareRate;\r\n\t\tuint256 suppliersShareRateUpdateTime;\r\n\r\n\t\tuint256 promotionRate;\r\n\t}\r\n\r\n\t/// @notice Collateral Features\r\n\tstruct CollateralSettings {\r\n\t\tbool isExist;\r\n\t\tbool isActive;    \r\n\r\n\t\tuint256 valueToLoanRate; \r\n\t\tuint256 VTLUpdateTime;\r\n\r\n\t\tuint256 penaltyRate;\r\n\t\tuint256 penaltyUpdateTime;\r\n\r\n\t\tuint256 bonusRate;\r\n\t}\r\n\r\n\tfunction getInterests(address market)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256 borrowRate, uint256 supplyRateBase, uint256 promotionRate);\r\n\tfunction resetPromotionRate (address market) external;\r\n\tfunction getMarketsList() external view returns(address[] memory marketsList);\r\n\tfunction marketAssets(address market) external view returns(MarketSettings memory);\r\n\tfunction collateralAssets(address collateral) external view returns(CollateralSettings memory);\r\n}\r\n\r\n/// @title Main Holdefi contract\r\n/// @author Holdefi Team\r\n/// @dev The address of ETH considered as 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n/// @dev All indexes are scaled by (secondsPerYear * rateDecimals)\r\n/// @dev All values are based ETH price considered 1 and all values decimals considered 30\r\n/// @dev Error codes description: \r\n/// \tE01: Asset should not be ETH\r\n/// \tE02: Market is not active\r\n/// \tE03: Collateral is not active\r\n/// \tE04: Account should not be the `msg.sender`\r\n/// \tE05: User borrow balance is zero\r\n/// \tE06: User should be under collateral or should have ativity in the past year\r\n/// \tE07: Amount should be less than Max\r\n/// \tE08: Cannot transfer\r\n/// \tE09: Total balance should not be zero\r\n/// \tE10: Borrow power should not be zero\r\n/// \tE11: Requested amount is not available\r\n/// \tE12: Borrow power should be more than the value of the requested amount to borrow\r\n/// \tE13: Promotion debt should be less than the promotion reserve\r\n///\t\tE14: Transfer amount exceeds allowance\r\n///\t\tE15: Sender should be Holdefi Settings contract\r\n///\t\tE16: There is not enough collateral\r\n///\t\tE17: Amount should be less than the market debt\r\ncontract Holdefi is HoldefiPausableOwnable, ReentrancyGuard {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\tusing SafeERC20 for IERC20;\r\n\r\n\t/// @notice Markets are assets can be supplied and borrowed\r\n\tstruct Market {\r\n\t\tuint256 totalSupply;\r\n\r\n\t\tuint256 supplyIndex;      \t\t\t\t// Scaled by: secondsPerYear * rateDecimals\r\n\t\tuint256 supplyIndexUpdateTime;\r\n\r\n\t\tuint256 totalBorrow;\r\n\r\n\t\tuint256 borrowIndex;      \t\t\t\t// Scaled by: secondsPerYear * rateDecimals\r\n\t\tuint256 borrowIndexUpdateTime;\r\n\r\n\t\tuint256 promotionReserveScaled;      \t// Scaled by: secondsPerYear * rateDecimals\r\n\t\tuint256 promotionReserveLastUpdateTime;\r\n\r\n\t\tuint256 promotionDebtScaled;      \t\t// Scaled by: secondsPerYear * rateDecimals\r\n\t\tuint256 promotionDebtLastUpdateTime;\r\n\t}\r\n\r\n\t/// @notice Collaterals are assets can be used only as collateral for borrowing with no interest\r\n\tstruct Collateral {\r\n\t\tuint256 totalCollateral;\r\n\t\tuint256 totalLiquidatedCollateral;\r\n\t}\r\n\r\n\t/// @notice Users profile for each market\r\n\tstruct MarketAccount {\r\n\t\tmapping (address =\u003e uint) allowance;\r\n\t\tuint256 balance;\r\n\t\tuint256 accumulatedInterest;\r\n\r\n\t\tuint256 lastInterestIndex;      \t\t// Scaled by: secondsPerYear * rateDecimals\r\n\t}\r\n\r\n\t/// @notice Users profile for each collateral\r\n\tstruct CollateralAccount {\r\n\t\tmapping (address =\u003e uint) allowance;\r\n\t\tuint256 balance;\r\n\t\tuint256 lastUpdateTime;\r\n\t}\r\n\r\n\tstruct MarketData {\r\n\t\tuint256 balance;\r\n\t\tuint256 interest;\r\n\t\tuint256 currentIndex; \r\n\t}\r\n\r\n\taddress constant private ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n\t/// @dev All rates in this contract are scaled by rateDecimals\r\n\tuint256 constant private rateDecimals = 10 ** 4;\r\n\r\n\tuint256 constant private secondsPerYear = 31536000;\r\n\r\n\t/// @dev For round up borrow interests\r\n\tuint256 constant private oneUnit = 1;\r\n\r\n\t/// @dev Used for calculating liquidation threshold \r\n\t/// @dev There is 5% gap between value to loan rate and liquidation rate\r\n\tuint256 constant private fivePercentLiquidationGap = 500;\r\n\r\n\t/// @notice Contract for getting protocol settings\r\n\tHoldefiSettingsInterface public holdefiSettings;\r\n\r\n\t/// @notice Contract for getting asset prices\r\n\tHoldefiPricesInterface public holdefiPrices;\r\n\r\n\t/// @notice Contract for holding collaterals\r\n\tHoldefiCollaterals public holdefiCollaterals;\r\n\r\n\t/// @dev Markets: marketAddress =\u003e marketDetails\r\n\tmapping (address =\u003e Market) public marketAssets;\r\n\r\n\t/// @dev Collaterals: collateralAddress =\u003e collateralDetails\r\n\tmapping (address =\u003e Collateral) public collateralAssets;\r\n\r\n\t/// @dev Markets Debt after liquidation: collateralAddress =\u003e marketAddress =\u003e marketDebtBalance\r\n\tmapping (address =\u003e mapping (address =\u003e uint256)) public marketDebt;\r\n\r\n\t/// @dev Users Supplies: userAddress =\u003e marketAddress =\u003e supplyDetails\r\n\tmapping (address =\u003e mapping (address =\u003e MarketAccount)) private supplies;\r\n\r\n\t/// @dev Users Borrows: userAddress =\u003e collateralAddress =\u003e marketAddress =\u003e borrowDetails\r\n\tmapping (address =\u003e mapping (address =\u003e mapping (address =\u003e MarketAccount))) private borrows;\r\n\r\n\t/// @dev Users Collaterals: userAddress =\u003e collateralAddress =\u003e collateralDetails\r\n\tmapping (address =\u003e mapping (address =\u003e CollateralAccount)) private collaterals;\r\n\t\r\n\t// ----------- Events -----------\r\n\r\n\t/// @notice Event emitted when a market asset is supplied\r\n\tevent Supply(\r\n\t\taddress sender,\r\n\t\taddress indexed supplier,\r\n\t\taddress indexed market,\r\n\t\tuint256 amount,\r\n\t\tuint256 balance,\r\n\t\tuint256 interest,\r\n\t\tuint256 index,\r\n\t\tuint16 referralCode\r\n\t);\r\n\r\n\t/// @notice Event emitted when a supply is withdrawn\r\n\tevent WithdrawSupply(\r\n\t\taddress sender,\r\n\t\taddress indexed supplier,\r\n\t\taddress indexed market,\r\n\t\tuint256 amount,\r\n\t\tuint256 balance,\r\n\t\tuint256 interest,\r\n\t\tuint256 index\r\n\t);\r\n\r\n\t/// @notice Event emitted when the collateral asset is deposited\r\n\tevent Collateralize(\r\n\t\taddress sender,\r\n\t\taddress indexed collateralizer,\r\n\t\taddress indexed collateral,\r\n\t\tuint256 amount,\r\n\t\tuint256 balance\r\n\t);\r\n\r\n\t/// @notice Event emitted when the collateral is withdrawn\r\n\tevent WithdrawCollateral(\r\n\t\taddress sender,\r\n\t\taddress indexed collateralizer,\r\n\t\taddress indexed collateral,\r\n\t\tuint256 amount,\r\n\t\tuint256 balance\r\n\t);\r\n\r\n\t/// @notice Event emitted when a market asset is borrowed\r\n\tevent Borrow(\r\n\t\taddress sender,\r\n\t\taddress indexed borrower,\r\n\t\taddress indexed market,\r\n\t\taddress indexed collateral,\r\n\t\tuint256 amount,\r\n\t\tuint256 balance,\r\n\t\tuint256 interest,\r\n\t\tuint256 index,\r\n\t\tuint16 referralCode\r\n\t);\r\n\r\n\t/// @notice Event emitted when a borrow is repaid\r\n\tevent RepayBorrow(\r\n\t\taddress sender,\r\n\t\taddress indexed borrower,\r\n\t\taddress indexed market,\r\n\t\taddress indexed collateral,\r\n\t\tuint256 amount,\r\n\t\tuint256 balance,\r\n\t\tuint256 interest,\r\n\t\tuint256 index\r\n\t);\r\n\r\n\t/// @notice Event emitted when the supply index is updated for a market asset\r\n\tevent UpdateSupplyIndex(address indexed market, uint256 newSupplyIndex, uint256 supplyRate);\r\n\r\n\t/// @notice Event emitted when the borrow index is updated for a market asset\r\n\tevent UpdateBorrowIndex(address indexed market, uint256 newBorrowIndex, uint256 borrowRate);\r\n\r\n\t/// @notice Event emitted when the collateral is liquidated\r\n\tevent CollateralLiquidated(\r\n\t\taddress indexed borrower,\r\n\t\taddress indexed market,\r\n\t\taddress indexed collateral,\r\n\t\tuint256 marketDebt,\r\n\t\tuint256 liquidatedCollateral\r\n\t);\r\n\r\n\t/// @notice Event emitted when a liquidated collateral is purchased in exchange for the specified market\r\n\tevent BuyLiquidatedCollateral(\r\n\t\taddress indexed market,\r\n\t\taddress indexed collateral,\r\n\t\tuint256 marketAmount,\r\n\t\tuint256 collateralAmount\r\n\t);\r\n\r\n\t/// @notice Event emitted when HoldefiPrices contract is changed\r\n\tevent HoldefiPricesContractChanged(address newAddress, address oldAddress);\r\n\r\n\t/// @notice Event emitted when a liquidation reserve is withdrawn by the owner\r\n\tevent LiquidationReserveWithdrawn(address indexed collateral, uint256 amount);\r\n\r\n\t/// @notice Event emitted when a liquidation reserve is deposited\r\n\tevent LiquidationReserveDeposited(address indexed collateral, uint256 amount);\r\n\r\n\t/// @notice Event emitted when a promotion reserve is withdrawn by the owner\r\n\tevent PromotionReserveWithdrawn(address indexed market, uint256 amount, uint256 newPromotionReserve);\r\n\r\n\t/// @notice Event emitted when a promotion reserve is deposited\r\n\tevent PromotionReserveDeposited(address indexed market, uint256 amount, uint256 newPromotionReserve);\r\n\r\n\t/// @notice Event emitted when a promotion reserve is updated\r\n\tevent PromotionReserveUpdated(address indexed market, uint256 promotionReserve);\r\n\r\n\t/// @notice Event emitted when a promotion debt is updated\r\n\tevent PromotionDebtUpdated(address indexed market, uint256 promotionDebt);\r\n\r\n\t/// @notice Initializes the Holdefi contract\r\n    /// @param holdefiSettingsAddress Holdefi settings contract address\r\n    /// @param holdefiPricesAddress Holdefi prices contract address\r\n\tconstructor(\r\n\t\tHoldefiSettingsInterface holdefiSettingsAddress,\r\n\t\tHoldefiPricesInterface holdefiPricesAddress\r\n\t)\r\n\t\tpublic\r\n\t{\r\n\t\tholdefiSettings = holdefiSettingsAddress;\r\n\t\tholdefiPrices = holdefiPricesAddress;\r\n\t\tholdefiCollaterals = new HoldefiCollaterals();\r\n\t}\r\n\r\n\r\n\t/// @dev Modifier to check if the asset is ETH or not\r\n\t/// @param asset Address of the given asset\r\n    modifier isNotETHAddress(address asset) {\r\n        require (asset != ethAddress, \"E01\");\r\n        _;\r\n    }\r\n\r\n\t/// @dev Modifier to check if the market is active or not\r\n\t/// @param market Address of the given market\r\n    modifier marketIsActive(address market) {\r\n\t\trequire (holdefiSettings.marketAssets(market).isActive, \"E02\");\r\n        _;\r\n    }\r\n\r\n\t/// @dev Modifier to check if the collateral is active or not\r\n\t/// @param collateral Address of the given collateral\r\n    modifier collateralIsActive(address collateral) {\r\n\t\trequire (holdefiSettings.collateralAssets(collateral).isActive, \"E03\");\r\n        _;\r\n    }\r\n\r\n\t/// @dev Modifier to check if the account address is equal to the msg.sender or not\r\n    /// @param account The given account address\r\n    modifier accountIsValid(address account) {\r\n\t\trequire (msg.sender != account, \"E04\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n\r\n\t/// @notice Returns balance and interest of an account for a given market\r\n    /// @dev supplyInterest = accumulatedInterest + (balance * (marketSupplyIndex - userLastSupplyInterestIndex))\r\n    /// @param account Supplier address to get supply information\r\n    /// @param market Address of the given market\r\n    /// @return balance Supplied amount on the specified market\r\n    /// @return interest Profit earned\r\n    /// @return currentSupplyIndex Supply index for the given market at current time\r\n\tfunction getAccountSupply(address account, address market)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256 balance, uint256 interest, uint256 currentSupplyIndex)\r\n\t{\r\n\t\tbalance = supplies[account][market].balance;\r\n\r\n\t\t(currentSupplyIndex,) = getCurrentSupplyIndex(market);\r\n\r\n\t\tuint256 deltaInterestIndex = currentSupplyIndex.sub(supplies[account][market].lastInterestIndex);\r\n\t\tuint256 deltaInterestScaled = deltaInterestIndex.mul(balance);\r\n\t\tuint256 deltaInterest = deltaInterestScaled.div(secondsPerYear).div(rateDecimals);\r\n\t\t\r\n\t\tinterest = supplies[account][market].accumulatedInterest.add(deltaInterest);\r\n\t}\r\n\r\n\t/// @notice Returns balance and interest of an account for a given market on a given collateral\r\n    /// @dev borrowInterest = accumulatedInterest + (balance * (marketBorrowIndex - userLastBorrowInterestIndex))\r\n    /// @param account Borrower address to get Borrow information\r\n    /// @param market Address of the given market\r\n    /// @param collateral Address of the given collateral\r\n    /// @return balance Borrowed amount on the specified market\r\n    /// @return interest The amount of interest the borrower should pay\r\n    /// @return currentBorrowIndex Borrow index for the given market at current time\r\n\tfunction getAccountBorrow(address account, address market, address collateral)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256 balance, uint256 interest, uint256 currentBorrowIndex)\r\n\t{\r\n\t\tbalance = borrows[account][collateral][market].balance;\r\n\r\n\t\t(currentBorrowIndex,) = getCurrentBorrowIndex(market);\r\n\r\n\t\tuint256 deltaInterestIndex =\r\n\t\t\tcurrentBorrowIndex.sub(borrows[account][collateral][market].lastInterestIndex);\r\n\r\n\t\tuint256 deltaInterestScaled = deltaInterestIndex.mul(balance);\r\n\t\tuint256 deltaInterest = deltaInterestScaled.div(secondsPerYear).div(rateDecimals);\r\n\t\tif (balance \u003e 0) {\r\n\t\t\tdeltaInterest = deltaInterest.add(oneUnit);\r\n\t\t}\r\n\r\n\t\tinterest = borrows[account][collateral][market].accumulatedInterest.add(deltaInterest);\r\n\t}\r\n\r\n\r\n\t/// @notice Returns collateral balance, time since last activity, borrow power, total borrow value, and liquidation status for a given collateral\r\n    /// @dev borrowPower = (collateralValue / collateralValueToLoanRate) - totalBorrowValue\r\n    /// @dev liquidationThreshold = collateralValueToLoanRate - 5%\r\n    /// @dev User will be in liquidation state if (collateralValue / totalBorrowValue) \u003c liquidationThreshold\r\n    /// @param account Account address to get collateral information\r\n    /// @param collateral Address of the given collateral\r\n    /// @return balance Amount of the specified collateral\r\n    /// @return timeSinceLastActivity Time since last activity performed by the account\r\n    /// @return borrowPowerValue The borrowing power for the account of the given collateral\r\n    /// @return totalBorrowValue Accumulative borrowed values on the given collateral\r\n    /// @return underCollateral A boolean value indicates whether the user is in the liquidation state or not\r\n\tfunction getAccountCollateral(address account, address collateral)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint256 balance,\r\n\t\t\tuint256 timeSinceLastActivity,\r\n\t\t\tuint256 borrowPowerValue,\r\n\t\t\tuint256 totalBorrowValue,\r\n\t\t\tbool underCollateral\r\n\t\t)\r\n\t{\r\n\t\tuint256 valueToLoanRate = holdefiSettings.collateralAssets(collateral).valueToLoanRate;\r\n\t\tif (valueToLoanRate == 0) {\r\n\t\t\treturn (0, 0, 0, 0, false);\r\n\t\t}\r\n\r\n\t\tbalance = collaterals[account][collateral].balance;\r\n\r\n\t\tuint256 collateralValue = holdefiPrices.getAssetValueFromAmount(collateral, balance);\r\n\t\tuint256 liquidationThresholdRate = valueToLoanRate.sub(fivePercentLiquidationGap);\r\n\r\n\t\tuint256 totalBorrowPowerValue = collateralValue.mul(rateDecimals).div(valueToLoanRate);\r\n\t\tuint256 liquidationThresholdValue = collateralValue.mul(rateDecimals).div(liquidationThresholdRate);\r\n\r\n\t\ttotalBorrowValue = getAccountTotalBorrowValue(account, collateral);\r\n\t\tif (totalBorrowValue \u003e 0) {\r\n\t\t\ttimeSinceLastActivity = block.timestamp.sub(collaterals[account][collateral].lastUpdateTime);\r\n\t\t}\r\n\r\n\t\tborrowPowerValue = 0;\r\n\t\tif (totalBorrowValue \u003c totalBorrowPowerValue) {\r\n\t\t\tborrowPowerValue = totalBorrowPowerValue.sub(totalBorrowValue);\r\n\t\t}\r\n\r\n\t\tunderCollateral = false;\t\r\n\t\tif (totalBorrowValue \u003e liquidationThresholdValue) {\r\n\t\t\tunderCollateral = true;\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Returns total borrow value of an account based on a given collateral \r\n\t/// @param account Account address\r\n    /// @param collateral Address of the given collateral\r\n    /// @return totalBorrowValue Accumulative borrowed values on the given collateral\r\n\tfunction getAccountTotalBorrowValue (address account, address collateral)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256 totalBorrowValue)\r\n\t{\r\n\t\tMarketData memory borrowData;\r\n\t\taddress market;\r\n\t\tuint256 totalDebt;\r\n\t\tuint256 assetValue;\r\n\t\t\r\n\t\ttotalBorrowValue = 0;\r\n\t\taddress[] memory marketsList = holdefiSettings.getMarketsList();\r\n\t\tfor (uint256 i = 0 ; i \u003c marketsList.length ; i++) {\r\n\t\t\tmarket = marketsList[i];\r\n\t\t\t\r\n\t\t\t(borrowData.balance, borrowData.interest,) = getAccountBorrow(account, market, collateral);\r\n\t\t\ttotalDebt = borrowData.balance.add(borrowData.interest);\r\n\r\n\t\t\tassetValue = holdefiPrices.getAssetValueFromAmount(market, totalDebt);\r\n\t\t\ttotalBorrowValue = totalBorrowValue.add(assetValue);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice The collateral reserve amount for buying liquidated collateral\r\n    /// @param collateral Address of the given collateral\r\n    /// @return reserve Liquidation reserves for the given collateral\r\n\tfunction getLiquidationReserve (address collateral) public view returns(uint256 reserve) {\r\n\t\taddress market;\r\n\t\tuint256 assetValue;\r\n\t\tuint256 totalDebtValue = 0;\r\n\r\n\t\taddress[] memory marketsList = holdefiSettings.getMarketsList();\r\n\t\tfor (uint256 i = 0 ; i \u003c marketsList.length ; i++) {\r\n\t\t\tmarket = marketsList[i];\r\n\t\t\tassetValue = holdefiPrices.getAssetValueFromAmount(market, marketDebt[collateral][market]);\r\n\t\t\ttotalDebtValue = totalDebtValue.add(assetValue); \r\n\t\t}\r\n\r\n\t\tuint256 bonusRate = holdefiSettings.collateralAssets(collateral).bonusRate;\r\n\t\tuint256 totalDebtCollateralValue = totalDebtValue.mul(bonusRate).div(rateDecimals);\r\n\t\tuint256 liquidatedCollateralNeeded = holdefiPrices.getAssetAmountFromValue(\r\n\t\t\tcollateral,\r\n\t\t\ttotalDebtCollateralValue\r\n\t\t);\r\n\t\t\r\n\t\treserve = 0;\r\n\t\tuint256 totalLiquidatedCollateral = collateralAssets[collateral].totalLiquidatedCollateral;\r\n\t\tif (totalLiquidatedCollateral \u003e liquidatedCollateralNeeded) {\r\n\t\t\treserve = totalLiquidatedCollateral.sub(liquidatedCollateralNeeded);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Returns the amount of discounted collateral can be bought in exchange for the amount of a given market\r\n    /// @param market Address of the given market\r\n    /// @param collateral Address of the given collateral\r\n    /// @param marketAmount The amount of market should be paid\r\n    /// @return collateralAmountWithDiscount Amount of discounted collateral can be bought\r\n\tfunction getDiscountedCollateralAmount (address market, address collateral, uint256 marketAmount)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256 collateralAmountWithDiscount)\r\n\t{\r\n\t\tuint256 marketValue = holdefiPrices.getAssetValueFromAmount(market, marketAmount);\r\n\t\tuint256 bonusRate = holdefiSettings.collateralAssets(collateral).bonusRate;\r\n\t\tuint256 collateralValue = marketValue.mul(bonusRate).div(rateDecimals);\r\n\r\n\t\tcollateralAmountWithDiscount = holdefiPrices.getAssetAmountFromValue(collateral, collateralValue);\r\n\t}\r\n\r\n\t/// @notice Returns supply index and supply rate for a given market at current time\r\n\t/// @dev newSupplyIndex = oldSupplyIndex + (deltaTime * supplyRate)\r\n    /// @param market Address of the given market\r\n    /// @return supplyIndex Supply index of the given market\r\n    /// @return supplyRate Supply rate of the given market\r\n\tfunction getCurrentSupplyIndex (address market)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint256 supplyIndex,\r\n\t\t\tuint256 supplyRate\r\n\t\t)\r\n\t{\r\n\t\t(, uint256 supplyRateBase, uint256 promotionRate) = holdefiSettings.getInterests(market);\r\n\t\tuint256 deltaTimeSupply = block.timestamp.sub(marketAssets[market].supplyIndexUpdateTime);\r\n\r\n\t\tsupplyRate = supplyRateBase.add(promotionRate);\r\n\t\tuint256 deltaTimeInterest = deltaTimeSupply.mul(supplyRate);\r\n\t\tsupplyIndex = marketAssets[market].supplyIndex.add(deltaTimeInterest);\r\n\t}\r\n\r\n\t/// @notice Returns borrow index and borrow rate for the given market at current time\r\n\t/// @dev newBorrowIndex = oldBorrowIndex + (deltaTime * borrowRate)\r\n    /// @param market Address of the given market\r\n    /// @return borrowIndex Borrow index of the given market\r\n    /// @return borrowRate Borrow rate of the given market\r\n\tfunction getCurrentBorrowIndex (address market)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint256 borrowIndex,\r\n\t\t\tuint256 borrowRate\r\n\t\t)\r\n\t{\r\n\t\tborrowRate = holdefiSettings.marketAssets(market).borrowRate;\r\n\t\tuint256 deltaTimeBorrow = block.timestamp.sub(marketAssets[market].borrowIndexUpdateTime);\r\n\r\n\t\tuint256 deltaTimeInterest = deltaTimeBorrow.mul(borrowRate);\r\n\t\tborrowIndex = marketAssets[market].borrowIndex.add(deltaTimeInterest);\r\n\t}\r\n\r\n\t/// @notice Returns promotion reserve for a given market at current time\r\n\t/// @dev promotionReserveScaled is scaled by (secondsPerYear * rateDecimals)\r\n\t/// @param market Address of the given market\r\n    /// @return promotionReserveScaled Promotion reserve of the given market\r\n\tfunction getPromotionReserve (address market)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256 promotionReserveScaled)\r\n\t{\r\n\t\t(uint256 borrowRate, uint256 supplyRateBase,) = holdefiSettings.getInterests(market);\r\n\t\r\n\t\tuint256 allSupplyInterest = marketAssets[market].totalSupply.mul(supplyRateBase);\r\n\t\tuint256 allBorrowInterest = marketAssets[market].totalBorrow.mul(borrowRate);\r\n\r\n\t\tuint256 deltaTime = block.timestamp.sub(marketAssets[market].promotionReserveLastUpdateTime);\r\n\t\tuint256 currentInterest = allBorrowInterest.sub(allSupplyInterest);\r\n\t\tuint256 deltaTimeInterest = currentInterest.mul(deltaTime);\r\n\t\tpromotionReserveScaled = marketAssets[market].promotionReserveScaled.add(deltaTimeInterest);\r\n\t}\r\n\r\n\t/// @notice Returns promotion debt for a given market at current time\r\n\t/// @dev promotionDebtScaled is scaled by secondsPerYear * rateDecimals\r\n\t/// @param market Address of the given market\r\n    /// @return promotionDebtScaled Promotion debt of the given market\r\n\tfunction getPromotionDebt (address market)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256 promotionDebtScaled)\r\n\t{\r\n\t\tuint256 promotionRate = holdefiSettings.marketAssets(market).promotionRate;\r\n\t\tpromotionDebtScaled = marketAssets[market].promotionDebtScaled;\r\n\r\n\t\tif (promotionRate != 0) {\r\n\t\t\tuint256 deltaTime = block.timestamp.sub(marketAssets[market].promotionDebtLastUpdateTime);\r\n\t\t\tuint256 currentInterest = marketAssets[market].totalSupply.mul(promotionRate);\r\n\t\t\tuint256 deltaTimeInterest = currentInterest.mul(deltaTime);\r\n\t\t\tpromotionDebtScaled = promotionDebtScaled.add(deltaTimeInterest);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Update a market supply index, promotion reserve, and promotion debt\r\n\t/// @param market Address of the given market\r\n\tfunction beforeChangeSupplyRate (address market) public {\r\n\t\tupdateSupplyIndex(market);\r\n\t\t\r\n\t\tuint256 reserveScaled = getPromotionReserve(market);\r\n\t\tuint256 debtScaled = getPromotionDebt(market);\r\n\r\n    \tif (marketAssets[market].promotionDebtScaled != debtScaled) {\r\n    \t\tif (debtScaled \u003e= reserveScaled) {\r\n\t      \t\tholdefiSettings.resetPromotionRate(market);\r\n\t      \t}\r\n\r\n\t      \tmarketAssets[market].promotionDebtScaled = debtScaled;\r\n\t      \tmarketAssets[market].promotionDebtLastUpdateTime = block.timestamp;\r\n\t      \temit PromotionDebtUpdated(market, debtScaled);\r\n    \t}\r\n\r\n\t\tmarketAssets[market].promotionReserveScaled = reserveScaled;\r\n    \tmarketAssets[market].promotionReserveLastUpdateTime = block.timestamp;\r\n\t\temit PromotionReserveUpdated(market, reserveScaled);\r\n\t}\r\n\r\n\t/// @notice Update a market borrow index, supply index, promotion reserve, and promotion debt \r\n\t/// @param market Address of the given market\r\n\tfunction beforeChangeBorrowRate (address market) external {\r\n\t\tupdateBorrowIndex(market);\r\n\t\tbeforeChangeSupplyRate(market);\r\n\t}\r\n\r\n\t/// @notice Returns maximum amount spender can withdraw from account supplies on a given market\r\n\t/// @param account Supplier address\r\n\t/// @param spender Spender address\r\n\t/// @param market Address of the given market\r\n\t/// @return res Maximum amount spender can withdraw from account supplies on a given market\r\n\tfunction getAccountWithdrawSupplyAllowance (address account, address spender, address market)\r\n\t\texternal \r\n\t\tview\r\n\t\treturns (uint256 res)\r\n\t{\r\n\t\tres = supplies[account][market].allowance[spender];\r\n\t}\r\n\r\n\t/// @notice Returns maximum amount spender can withdraw from account balance on a given collateral\r\n\t/// @param account Account address\r\n\t/// @param spender Spender address\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @return res Maximum amount spender can withdraw from account balance on a given collateral\r\n\tfunction getAccountWithdrawCollateralAllowance (\r\n\t\taddress account, \r\n\t\taddress spender, \r\n\t\taddress collateral\r\n\t)\r\n\t\texternal \r\n\t\tview\r\n\t\treturns (uint256 res)\r\n\t{\r\n\t\tres = collaterals[account][collateral].allowance[spender];\r\n\t}\r\n\r\n\t/// @notice Returns maximum amount spender can withdraw from account borrows on a given market based on a given collteral\r\n\t/// @param account Borrower address\r\n\t/// @param spender Spender address\r\n\t/// @param market Address of the given market\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @return res Maximum amount spender can withdraw from account borrows on a given market based on a given collteral\r\n\tfunction getAccountBorrowAllowance (\r\n\t\taddress account, \r\n\t\taddress spender, \r\n\t\taddress market, \r\n\t\taddress collateral\r\n\t)\r\n\t\texternal \r\n\t\tview\r\n\t\treturns (uint256 res)\r\n\t{\r\n\t\tres = borrows[account][collateral][market].allowance[spender];\r\n\t}\r\n\r\n\t/// @notice Deposit ERC20 asset for supplying\r\n\t/// @param market Address of the given market\r\n\t/// @param amount The amount of asset supplier supplies\r\n\t/// @param referralCode A unique code used as an identifier of the referrer\r\n\tfunction supply(address market, uint256 amount, uint16 referralCode)\r\n\t\texternal\r\n\t\tisNotETHAddress(market)\r\n\t{\r\n\t\tsupplyInternal(msg.sender, market, amount, referralCode);\r\n\t}\r\n\r\n\t/// @notice Deposit ETH for supplying\r\n\t/// @notice msg.value The amount of asset supplier supplies\r\n\t/// @param referralCode A unique code used as an identifier of the referrer\r\n\tfunction supply(uint16 referralCode) external payable {\t\t\r\n\t\tsupplyInternal(msg.sender, ethAddress, msg.value, referralCode);\r\n\t}\r\n\r\n\t/// @notice Sender supplies ERC20 asset belonging to the supplier\r\n\t/// @param account Address of the supplier\r\n\t/// @param market Address of the given market\r\n\t/// @param amount The amount of asset sender deposits\r\n\t/// @param referralCode A unique code used as an identifier of the referrer\r\n\tfunction supplyBehalf(address account, address market, uint256 amount, uint16 referralCode)\r\n\t\texternal\r\n\t\tisNotETHAddress(market)\r\n\t{\r\n\t\tsupplyInternal(account, market, amount, referralCode);\r\n\t}\r\n\r\n\t/// @notice Sender supplies ETH belonging to the supplier\r\n\t/// @notice msg.value The amount of ETH sender deposits\r\n\t/// @param account Address of the supplier\r\n\t/// @param referralCode A unique code used as an identifier of the referrer\r\n\tfunction supplyBehalf(address account, uint16 referralCode) \r\n\t\texternal\r\n\t\tpayable\r\n\t{\r\n\t\tsupplyInternal(account, ethAddress, msg.value, referralCode);\r\n\t}\r\n\r\n\t/// @notice Sender approves the account to withdraw supply\r\n\t/// @param account Address of the spender\r\n\t/// @param market Address of the given market\r\n\t/// @param amount The amount is allowed to be withdrawn\r\n\tfunction approveWithdrawSupply(address account, address market, uint256 amount)\r\n\t\texternal\r\n\t\taccountIsValid(account)\r\n\t\tmarketIsActive(market)\r\n\t{\r\n\t\tsupplies[msg.sender][market].allowance[account] = amount;\r\n\t}\r\n\r\n\t/// @notice Withdraw supply of a given market\r\n\t/// @param market Address of the given market\r\n\t/// @param amount The amount will be withdrawn from the market\r\n\tfunction withdrawSupply(address market, uint256 amount)\r\n\t\texternal\r\n\t{\r\n\t\twithdrawSupplyInternal(msg.sender, market, amount);\r\n\t}\r\n\r\n\t/// @notice Sender withdraws supply belonging to the supplier\r\n\t/// @param account Address of the supplier\r\n\t/// @param market Address of the given market\r\n\t/// @param amount The amount will be withdrawn from the market\r\n\tfunction withdrawSupplyBehalf(address account, address market, uint256 amount) external {\r\n\t\tsupplies[account][market].allowance[msg.sender] = supplies[account][market].allowance[msg.sender].sub(amount, \u0027E14\u0027);\r\n\t\twithdrawSupplyInternal(account, market, amount);\r\n\t}\r\n\r\n\t/// @notice Deposit ERC20 asset as collateral\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount will be collateralized\r\n\tfunction collateralize (address collateral, uint256 amount)\r\n\t\texternal\r\n\t\tisNotETHAddress(collateral)\r\n\t{\r\n\t\tcollateralizeInternal(msg.sender, collateral, amount);\r\n\t}\r\n\r\n\t/// @notice Deposit ETH as collateral\r\n\t/// @notice msg.value The amount of ETH will be collateralized\r\n\tfunction collateralize () external payable {\r\n\t\tcollateralizeInternal(msg.sender, ethAddress, msg.value);\r\n\t}\r\n\r\n\t/// @notice Sender deposits ERC20 asset as collateral belonging to another user\r\n\t/// @param account Address of the user\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount of asset sender deposits\r\n\tfunction collateralizeBehalf (address account, address collateral, uint256 amount)\r\n\t\texternal\r\n\t\tisNotETHAddress(collateral)\r\n\t{\r\n\t\tcollateralizeInternal(account, collateral, amount);\r\n\t}\r\n\r\n\t/// @notice Sender deposits ETH as collateral belonging to another user\r\n\t/// @notice msg.value The amount of ETH sender deposits\r\n\t/// @param account Address of the user\r\n\tfunction collateralizeBehalf (address account) external payable {\r\n\t\tcollateralizeInternal(account, ethAddress, msg.value);\r\n\t}\r\n\r\n\t/// @notice Sender approves the account to withdraw the collateral\r\n\t/// @param account Address of the spender\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount is allowed to be withdrawn\r\n\tfunction approveWithdrawCollateral (address account, address collateral, uint256 amount)\r\n\t\texternal\r\n\t\taccountIsValid(account)\r\n\t\tcollateralIsActive(collateral)\r\n\t{\r\n\t\tcollaterals[msg.sender][collateral].allowance[account] = amount;\r\n\t}\r\n\r\n\t/// @notice Withdraw the collateral\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount will be withdrawn from the collateral\r\n\tfunction withdrawCollateral (address collateral, uint256 amount)\r\n\t\texternal\r\n\t{\r\n\t\twithdrawCollateralInternal(msg.sender, collateral, amount);\r\n\t}\r\n\r\n\t/// @notice Sender withdraws the collateral belonging to another user\r\n\t/// @param account Address of the user\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount will be withdrawn from the collateral\r\n\tfunction withdrawCollateralBehalf (address account, address collateral, uint256 amount)\r\n\t\texternal\r\n\t{\r\n\t\tcollaterals[account][collateral].allowance[msg.sender] = \r\n\t\t\tcollaterals[account][collateral].allowance[msg.sender].sub(amount, \u0027E14\u0027);\r\n\t\twithdrawCollateralInternal(account, collateral, amount);\r\n\t}\r\n\r\n\t/// @notice Sender approves the account to borrow a given market based on given collateral\r\n\t/// @param account Address of the spender\r\n\t/// @param market Address of the given market\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount is allowed to be withdrawn\r\n\tfunction approveBorrow (address account, address market, address collateral, uint256 amount)\r\n\t\texternal\r\n\t\taccountIsValid(account)\r\n\t\tmarketIsActive(market)\r\n\t{\r\n\t\tborrows[msg.sender][collateral][market].allowance[account] = amount;\r\n\t}\r\n\r\n\t/// @notice Borrow an asset\r\n\t/// @param market Address of the given market\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount of the given market will be borrowed\r\n\t/// @param referralCode A unique code used as an identifier of the referrer\r\n\tfunction borrow (address market, address collateral, uint256 amount, uint16 referralCode)\r\n\t\texternal\r\n\t{\r\n\t\tborrowInternal(msg.sender, market, collateral, amount, referralCode);\r\n\t}\r\n\r\n\t/// @notice Sender borrows an asset belonging to the borrower\r\n\t/// @param account Address of the borrower\r\n\t/// @param market Address of the given market\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount will be borrowed\r\n\t/// @param referralCode A unique code used as an identifier of the referrer\r\n\tfunction borrowBehalf (address account, address market, address collateral, uint256 amount, uint16 referralCode)\r\n\t\texternal\r\n\t{\r\n\t\tborrows[account][collateral][market].allowance[msg.sender] = \r\n\t\t\tborrows[account][collateral][market].allowance[msg.sender].sub(amount, \u0027E14\u0027);\r\n\t\tborrowInternal(account, market, collateral, amount, referralCode);\r\n\t}\r\n\r\n\t/// @notice Repay an ERC20 asset based on a given collateral\r\n\t/// @param market Address of the given market\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount of the market will be Repaid\r\n\tfunction repayBorrow (address market, address collateral, uint256 amount)\r\n\t\texternal\r\n\t\tisNotETHAddress(market)\r\n\t{\r\n\t\trepayBorrowInternal(msg.sender, market, collateral, amount);\r\n\t}\r\n\r\n\t/// @notice Repay an ETH based on a given collateral\r\n\t/// @notice msg.value The amount of ETH will be repaid\r\n\t/// @param collateral Address of the given collateral\r\n\tfunction repayBorrow (address collateral) external payable {\t\t\r\n\t\trepayBorrowInternal(msg.sender, ethAddress, collateral, msg.value);\r\n\t}\r\n\r\n\t/// @notice Sender repays an ERC20 asset based on a given collateral belonging to the borrower\r\n\t/// @param account Address of the borrower\r\n\t/// @param market Address of the given market\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount of the market will be repaid\r\n\tfunction repayBorrowBehalf (address account, address market, address collateral, uint256 amount)\r\n\t\texternal\r\n\t\tisNotETHAddress(market)\r\n\t{\r\n\t\trepayBorrowInternal(account, market, collateral, amount);\r\n\t}\r\n\r\n\t/// @notice Sender repays an ETH based on a given collateral belonging to the borrower\r\n\t/// @notice msg.value The amount of ETH sender repays\r\n\t/// @param account Address of the borrower\r\n\t/// @param collateral Address of the given collateral\r\n\tfunction repayBorrowBehalf (address account, address collateral)\r\n\t\texternal\r\n\t\tpayable\r\n\t{\t\t\r\n\t\trepayBorrowInternal(account, ethAddress, collateral, msg.value);\r\n\t}\r\n\r\n\t/// @notice Liquidate borrower\u0027s collateral\r\n\t/// @param borrower Address of the borrower who should be liquidated\r\n\t/// @param market Address of the given market\r\n\t/// @param collateral Address of the given collateral\r\n\tfunction liquidateBorrowerCollateral (address borrower, address market, address collateral)\r\n\t\texternal\r\n\t\twhenNotPaused(\"liquidateBorrowerCollateral\")\r\n\t{\r\n\t\tMarketData memory borrowData;\r\n\t\t(borrowData.balance, borrowData.interest,) = getAccountBorrow(borrower, market, collateral);\r\n\t\trequire(borrowData.balance \u003e 0, \"E05\");\r\n\r\n\t\t(uint256 collateralBalance, uint256 timeSinceLastActivity,,, bool underCollateral) = \r\n\t\t\tgetAccountCollateral(borrower, collateral);\r\n\t\trequire (underCollateral || (timeSinceLastActivity \u003e secondsPerYear),\r\n\t\t\t\"E06\"\r\n\t\t);\r\n\r\n\t\tuint256 totalBorrowedBalance = borrowData.balance.add(borrowData.interest);\r\n\t\tuint256 totalBorrowedBalanceValue = holdefiPrices.getAssetValueFromAmount(market, totalBorrowedBalance);\r\n\t\t\r\n\t\tuint256 liquidatedCollateralValue = totalBorrowedBalanceValue\r\n\t\t\t.mul(holdefiSettings.collateralAssets(collateral).penaltyRate)\r\n\t\t\t.div(rateDecimals);\r\n\r\n\t\tuint256 liquidatedCollateral =\r\n\t\t\tholdefiPrices.getAssetAmountFromValue(collateral, liquidatedCollateralValue);\r\n\r\n\t\tif (liquidatedCollateral \u003e collateralBalance) {\r\n\t\t\tliquidatedCollateral = collateralBalance;\r\n\t\t}\r\n\r\n\t\tcollaterals[borrower][collateral].balance = collateralBalance.sub(liquidatedCollateral);\r\n\t\tcollateralAssets[collateral].totalCollateral =\r\n\t\t\tcollateralAssets[collateral].totalCollateral.sub(liquidatedCollateral);\r\n\t\tcollateralAssets[collateral].totalLiquidatedCollateral =\r\n\t\t\tcollateralAssets[collateral].totalLiquidatedCollateral.add(liquidatedCollateral);\r\n\r\n\t\tdelete borrows[borrower][collateral][market];\r\n\t\tbeforeChangeSupplyRate(market);\r\n\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.sub(borrowData.balance);\r\n\t\tmarketDebt[collateral][market] = marketDebt[collateral][market].add(totalBorrowedBalance);\r\n\r\n\t\temit CollateralLiquidated(borrower, market, collateral, totalBorrowedBalance, liquidatedCollateral);\t\r\n\t}\r\n\r\n\t/// @notice Buy collateral in exchange for ERC20 asset\r\n\t/// @param market Address of the market asset should be paid to buy collateral\r\n\t/// @param collateral Address of the liquidated collateral\r\n\t/// @param marketAmount The amount of the given market will be paid\r\n\tfunction buyLiquidatedCollateral (address market, address collateral, uint256 marketAmount)\r\n\t\texternal\r\n\t\tisNotETHAddress(market)\r\n\t{\r\n\t\tbuyLiquidatedCollateralInternal(market, collateral, marketAmount);\r\n\t}\r\n\r\n\t/// @notice Buy collateral in exchange for ETH\r\n\t/// @notice msg.value The amount of the given market that will be paid\r\n\t/// @param collateral Address of the liquidated collateral\r\n\tfunction buyLiquidatedCollateral (address collateral) external payable {\r\n\t\tbuyLiquidatedCollateralInternal(ethAddress, collateral, msg.value);\r\n\t}\r\n\r\n\t/// @notice Deposit ERC20 asset as liquidation reserve\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount that will be deposited\r\n\tfunction depositLiquidationReserve(address collateral, uint256 amount)\r\n\t\texternal\r\n\t\tisNotETHAddress(collateral)\r\n\t{\r\n\t\tdepositLiquidationReserveInternal(collateral, amount);\r\n\t}\r\n\r\n\t/// @notice Deposit ETH asset as liquidation reserve\r\n\t/// @notice msg.value The amount of ETH that will be deposited\r\n\tfunction depositLiquidationReserve() external payable {\r\n\t\tdepositLiquidationReserveInternal(ethAddress, msg.value);\r\n\t}\r\n\r\n\t/// @notice Withdraw liquidation reserve only by the owner\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param amount The amount that will be withdrawn\r\n\tfunction withdrawLiquidationReserve (address collateral, uint256 amount) external onlyOwner {\r\n\t\tuint256 maxWithdraw = getLiquidationReserve(collateral);\r\n\t\tuint256 transferAmount = amount;\r\n\t\t\r\n\t\tif (transferAmount \u003e maxWithdraw){\r\n\t\t\ttransferAmount = maxWithdraw;\r\n\t\t}\r\n\r\n\t\tcollateralAssets[collateral].totalLiquidatedCollateral =\r\n\t\t\tcollateralAssets[collateral].totalLiquidatedCollateral.sub(transferAmount);\r\n\t\tholdefiCollaterals.withdraw(collateral, msg.sender, transferAmount);\r\n\r\n\t\temit LiquidationReserveWithdrawn(collateral, transferAmount);\r\n\t}\r\n\r\n\t/// @notice Deposit ERC20 asset as promotion reserve\r\n\t/// @param market Address of the given market\r\n\t/// @param amount The amount that will be deposited\r\n\tfunction depositPromotionReserve (address market, uint256 amount)\r\n\t\texternal\r\n\t\tisNotETHAddress(market)\r\n\t{\r\n\t\tdepositPromotionReserveInternal(market, amount);\r\n\t}\r\n\r\n\t/// @notice Deposit ETH as promotion reserve\r\n\t/// @notice msg.value The amount of ETH that will be deposited\r\n\tfunction depositPromotionReserve () external payable {\r\n\t\tdepositPromotionReserveInternal(ethAddress, msg.value);\r\n\t}\r\n\r\n\t/// @notice Withdraw promotion reserve only by the owner\r\n\t/// @param market Address of the given market\r\n\t/// @param amount The amount that will be withdrawn\r\n\tfunction withdrawPromotionReserve (address market, uint256 amount) external onlyOwner {\r\n\t    uint256 reserveScaled = getPromotionReserve(market);\r\n\t    uint256 debtScaled = getPromotionDebt(market);\r\n\r\n\t    uint256 amountScaled = amount.mul(secondsPerYear).mul(rateDecimals);\r\n\t    require (reserveScaled \u003e amountScaled.add(debtScaled), \"E07\");\r\n\r\n\t    marketAssets[market].promotionReserveScaled = reserveScaled.sub(amountScaled);\r\n\t    marketAssets[market].promotionReserveLastUpdateTime = block.timestamp;\r\n\r\n\t    transferFromHoldefi(msg.sender, market, amount);\r\n\r\n\t    emit PromotionReserveWithdrawn(market, amount, marketAssets[market].promotionReserveScaled);\r\n\t }\r\n\r\n\r\n\t/// @notice Set Holdefi prices contract only by the owner\r\n\t/// @param newHoldefiPrices Address of the new Holdefi prices contract\r\n\tfunction setHoldefiPricesContract (HoldefiPricesInterface newHoldefiPrices) external onlyOwner {\r\n\t\temit HoldefiPricesContractChanged(address(newHoldefiPrices), address(holdefiPrices));\r\n\t\tholdefiPrices = newHoldefiPrices;\r\n\t}\r\n\r\n\t/// @notice Promotion reserve and debt settlement\r\n\t/// @param market Address of the given market\r\n\tfunction reserveSettlement (address market) external {\r\n\t\trequire(msg.sender == address(holdefiSettings), \"E15\");\r\n\r\n\t\tupdateSupplyIndex(market);\r\n\t\tuint256 reserveScaled = getPromotionReserve(market);\r\n\t\tuint256 debtScaled = getPromotionDebt(market);\r\n\r\n\t\tmarketAssets[market].promotionReserveScaled = reserveScaled.sub(debtScaled, \"E13\");\r\n\t\tmarketAssets[market].promotionDebtScaled = 0;\r\n\r\n\t\tmarketAssets[market].promotionReserveLastUpdateTime = block.timestamp;\r\n\t\tmarketAssets[market].promotionDebtLastUpdateTime = block.timestamp;\r\n\r\n\t\temit PromotionReserveUpdated(market, marketAssets[market].promotionReserveScaled);\r\n\t\temit PromotionDebtUpdated(market, 0);\r\n\t}\r\n\r\n\t/// @notice Update supply index of a market\r\n\t/// @param market Address of the given market\r\n\tfunction updateSupplyIndex (address market) internal {\r\n\t\t(uint256 currentSupplyIndex, uint256 supplyRate) = getCurrentSupplyIndex(market);\r\n\r\n\t\tmarketAssets[market].supplyIndex = currentSupplyIndex;\r\n\t\tmarketAssets[market].supplyIndexUpdateTime = block.timestamp;\r\n\r\n\t\temit UpdateSupplyIndex(market, currentSupplyIndex, supplyRate);\r\n\t}\r\n\r\n\t/// @notice Update borrow index of a market\r\n\t/// @param market Address of the given market\r\n\tfunction updateBorrowIndex (address market) internal {\r\n\t\t(uint256 currentBorrowIndex, uint256 borrowRate) = getCurrentBorrowIndex(market);\r\n\r\n\t\tmarketAssets[market].borrowIndex = currentBorrowIndex;\r\n\t\tmarketAssets[market].borrowIndexUpdateTime = block.timestamp;\r\n\r\n\t\temit UpdateBorrowIndex(market, currentBorrowIndex, borrowRate);\r\n\t}\r\n\r\n\t/// @notice Transfer ETH or ERC20 asset from this contract\r\n\tfunction transferFromHoldefi(address receiver, address asset, uint256 amount) internal {\r\n\t\tif (asset == ethAddress){\r\n\t\t\t(bool success, ) = receiver.call{value:amount}(\"\");\r\n\t\t\trequire (success, \"E08\");\r\n\t\t}\r\n\t\telse {\r\n\t\t\tIERC20 token = IERC20(asset);\r\n\t\t\ttoken.safeTransfer(receiver, amount);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Transfer ERC20 asset from msg.sender\r\n\tfunction transferFromSender(address receiver, address asset, uint256 amount) internal returns(uint256 transferAmount) {\r\n\t\ttransferAmount = amount;\r\n\t\tif (asset != ethAddress) {\r\n\t\t\tIERC20 token = IERC20(asset);\r\n\t\t\tuint256 oldBalance = token.balanceOf(receiver);\r\n\t\t\ttoken.safeTransferFrom(msg.sender, receiver, amount);\r\n\t\t\ttransferAmount = token.balanceOf(receiver).sub(oldBalance);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Perform supply operation\r\n\tfunction supplyInternal(address account, address market, uint256 amount, uint16 referralCode)\r\n\t\tinternal\r\n\t\tnonReentrant\r\n\t\twhenNotPaused(\"supply\")\r\n\t\tmarketIsActive(market)\r\n\t{\r\n\t\tuint256 transferAmount = transferFromSender(address(this), market, amount);\r\n\r\n\t\tMarketData memory supplyData;\r\n\t\t(supplyData.balance, supplyData.interest, supplyData.currentIndex) = getAccountSupply(account, market);\r\n\t\t\r\n\t\tsupplyData.balance = supplyData.balance.add(transferAmount);\r\n\t\tsupplies[account][market].balance = supplyData.balance;\r\n\t\tsupplies[account][market].accumulatedInterest = supplyData.interest;\r\n\t\tsupplies[account][market].lastInterestIndex = supplyData.currentIndex;\r\n\r\n\t\tbeforeChangeSupplyRate(market);\r\n\t\tmarketAssets[market].totalSupply = marketAssets[market].totalSupply.add(transferAmount);\r\n\r\n\t\temit Supply(\r\n\t\t\tmsg.sender,\r\n\t\t\taccount,\r\n\t\t\tmarket,\r\n\t\t\ttransferAmount,\r\n\t\t\tsupplyData.balance,\r\n\t\t\tsupplyData.interest,\r\n\t\t\tsupplyData.currentIndex,\r\n\t\t\treferralCode\r\n\t\t);\r\n\t}\r\n\r\n\t/// @notice Perform withdraw supply operation\r\n\tfunction withdrawSupplyInternal (address account, address market, uint256 amount) \r\n\t\tinternal\r\n\t\tnonReentrant\r\n\t\twhenNotPaused(\"withdrawSupply\")\r\n\t{\r\n\t\tMarketData memory supplyData;\r\n\t\t(supplyData.balance, supplyData.interest, supplyData.currentIndex) = getAccountSupply(account, market);\r\n\t\tuint256 totalSuppliedBalance = supplyData.balance.add(supplyData.interest);\r\n\t\trequire (totalSuppliedBalance != 0, \"E09\");\r\n\r\n\t\tuint256 transferAmount = amount;\r\n\t\tif (transferAmount \u003e totalSuppliedBalance){\r\n\t\t\ttransferAmount = totalSuppliedBalance;\r\n\t\t}\r\n\r\n\t\tif (transferAmount \u003c= supplyData.interest) {\r\n\t\t\tsupplyData.interest = supplyData.interest.sub(transferAmount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint256 remaining = transferAmount.sub(supplyData.interest);\r\n\t\t\tsupplyData.interest = 0;\r\n\t\t\tsupplyData.balance = supplyData.balance.sub(remaining);\r\n\r\n\t\t\tbeforeChangeSupplyRate(market);\r\n\t\t\tmarketAssets[market].totalSupply = marketAssets[market].totalSupply.sub(remaining);\t\r\n\t\t}\r\n\r\n\t\tsupplies[account][market].balance = supplyData.balance;\r\n\t\tsupplies[account][market].accumulatedInterest = supplyData.interest;\r\n\t\tsupplies[account][market].lastInterestIndex = supplyData.currentIndex;\r\n\r\n\t\ttransferFromHoldefi(msg.sender, market, transferAmount);\r\n\t\r\n\t\temit WithdrawSupply(\r\n\t\t\tmsg.sender,\r\n\t\t\taccount,\r\n\t\t\tmarket,\r\n\t\t\ttransferAmount,\r\n\t\t\tsupplyData.balance,\r\n\t\t\tsupplyData.interest,\r\n\t\t\tsupplyData.currentIndex\r\n\t\t);\r\n\t}\r\n\r\n\t/// @notice Perform collateralize operation\r\n\tfunction collateralizeInternal (address account, address collateral, uint256 amount)\r\n\t\tinternal\r\n\t\tnonReentrant\r\n\t\twhenNotPaused(\"collateralize\")\r\n\t\tcollateralIsActive(collateral)\r\n\t{\r\n\t\tuint256 transferAmount = transferFromSender(address(holdefiCollaterals), collateral, amount);\r\n\t\tif (collateral == ethAddress) {\r\n\t\t\ttransferFromHoldefi(address(holdefiCollaterals), collateral, amount);\r\n\t\t}\r\n\r\n\t\tuint256 balance = collaterals[account][collateral].balance.add(transferAmount);\r\n\t\tcollaterals[account][collateral].balance = balance;\r\n\t\tcollaterals[account][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tcollateralAssets[collateral].totalCollateral = collateralAssets[collateral].totalCollateral.add(transferAmount);\t\r\n\t\t\r\n\t\temit Collateralize(msg.sender, account, collateral, transferAmount, balance);\r\n\t}\r\n\r\n\t/// @notice Perform withdraw collateral operation\r\n\tfunction withdrawCollateralInternal (address account, address collateral, uint256 amount) \r\n\t\tinternal\r\n\t\tnonReentrant\r\n\t\twhenNotPaused(\"withdrawCollateral\")\r\n\t{\r\n\t\t(uint256 balance,, uint256 borrowPowerValue, uint256 totalBorrowValue,) =\r\n\t\t\tgetAccountCollateral(account, collateral);\r\n\r\n\t\trequire (borrowPowerValue != 0, \"E10\");\r\n\r\n\t\tuint256 collateralNedeed = 0;\r\n\t\tif (totalBorrowValue != 0) {\r\n\t\t\tuint256 valueToLoanRate = holdefiSettings.collateralAssets(collateral).valueToLoanRate;\r\n\t\t\tuint256 totalCollateralValue = totalBorrowValue.mul(valueToLoanRate).div(rateDecimals);\r\n\t\t\tcollateralNedeed = holdefiPrices.getAssetAmountFromValue(collateral, totalCollateralValue);\r\n\t\t}\r\n\r\n\t\tuint256 maxWithdraw = balance.sub(collateralNedeed);\r\n\t\tuint256 transferAmount = amount;\r\n\t\tif (transferAmount \u003e maxWithdraw){\r\n\t\t\ttransferAmount = maxWithdraw;\r\n\t\t}\r\n\t\tbalance = balance.sub(transferAmount);\r\n\t\tcollaterals[account][collateral].balance = balance;\r\n\t\tcollaterals[account][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tcollateralAssets[collateral].totalCollateral =\r\n\t\t\tcollateralAssets[collateral].totalCollateral.sub(transferAmount);\r\n\r\n\t\tholdefiCollaterals.withdraw(collateral, msg.sender, transferAmount);\r\n\r\n\t\temit WithdrawCollateral(msg.sender, account, collateral, transferAmount, balance);\r\n\t}\r\n\r\n\t/// @notice Perform borrow operation\r\n\tfunction borrowInternal (address account, address market, address collateral, uint256 amount, uint16 referralCode)\r\n\t\tinternal\r\n\t\tnonReentrant\r\n\t\twhenNotPaused(\"borrow\")\r\n\t\tmarketIsActive(market)\r\n\t\tcollateralIsActive(collateral)\r\n\t{\r\n\t\trequire (amount \u003c= (marketAssets[market].totalSupply.sub(marketAssets[market].totalBorrow)), \"E11\");\r\n\r\n\t\t(,, uint256 borrowPowerValue,,) = getAccountCollateral(account, collateral);\r\n\t\tuint256 assetToBorrowValue = holdefiPrices.getAssetValueFromAmount(market, amount);\r\n\t\trequire (borrowPowerValue \u003e= assetToBorrowValue, \"E12\");\r\n\r\n\t\tMarketData memory borrowData;\r\n\t\t(borrowData.balance, borrowData.interest, borrowData.currentIndex) = getAccountBorrow(account, market, collateral);\r\n\t\t\r\n\t\tborrowData.balance = borrowData.balance.add(amount);\r\n\t\tborrows[account][collateral][market].balance = borrowData.balance;\r\n\t\tborrows[account][collateral][market].accumulatedInterest = borrowData.interest;\r\n\t\tborrows[account][collateral][market].lastInterestIndex = borrowData.currentIndex;\r\n\t\tcollaterals[account][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tbeforeChangeSupplyRate(market);\r\n\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.add(amount);\r\n\r\n\t\ttransferFromHoldefi(msg.sender, market, amount);\r\n\r\n\t\temit Borrow(\r\n\t\t\tmsg.sender, \r\n\t\t\taccount,\r\n\t\t\tmarket,\r\n\t\t\tcollateral,\r\n\t\t\tamount,\r\n\t\t\tborrowData.balance,\r\n\t\t\tborrowData.interest,\r\n\t\t\tborrowData.currentIndex,\r\n\t\t\treferralCode\r\n\t\t);\r\n\t}\r\n\r\n\t/// @notice Perform repay borrow operation\r\n\tfunction repayBorrowInternal (address account, address market, address collateral, uint256 amount)\r\n\t\tinternal\r\n\t\tnonReentrant\r\n\t\twhenNotPaused(\"repayBorrow\")\r\n\t{\r\n\t\tMarketData memory borrowData;\r\n\t\t(borrowData.balance, borrowData.interest, borrowData.currentIndex) =\r\n\t\t\tgetAccountBorrow(account, market, collateral);\r\n\r\n\t\tuint256 totalBorrowedBalance = borrowData.balance.add(borrowData.interest);\r\n\t\trequire (totalBorrowedBalance != 0, \"E09\");\r\n\r\n\t\tuint256 transferAmount = transferFromSender(address(this), market, amount);\r\n\t\tuint256 extra = 0;\r\n\t\tif (transferAmount \u003e totalBorrowedBalance) {\r\n\t\t\textra = transferAmount.sub(totalBorrowedBalance);\r\n\t\t\ttransferAmount = totalBorrowedBalance;\r\n\t\t}\r\n\r\n\t\tif (transferAmount \u003c= borrowData.interest) {\r\n\t\t\tborrowData.interest = borrowData.interest.sub(transferAmount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint256 remaining = transferAmount.sub(borrowData.interest);\r\n\t\t\tborrowData.interest = 0;\r\n\t\t\tborrowData.balance = borrowData.balance.sub(remaining);\r\n\r\n\t\t\tbeforeChangeSupplyRate(market);\r\n\t\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.sub(remaining);\t\r\n\t\t}\r\n\t\tborrows[account][collateral][market].balance = borrowData.balance;\r\n\t\tborrows[account][collateral][market].accumulatedInterest = borrowData.interest;\r\n\t\tborrows[account][collateral][market].lastInterestIndex = borrowData.currentIndex;\r\n\t\tcollaterals[account][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tif (extra \u003e 0) {\r\n\t\t\ttransferFromHoldefi(msg.sender, market, extra);\r\n\t\t}\r\n\t\t\r\n\t\temit RepayBorrow (\r\n\t\t\tmsg.sender,\r\n\t\t\taccount,\r\n\t\t\tmarket,\r\n\t\t\tcollateral,\r\n\t\t\ttransferAmount,\r\n\t\t\tborrowData.balance,\r\n\t\t\tborrowData.interest,\r\n\t\t\tborrowData.currentIndex\r\n\t\t);\r\n\t}\r\n\r\n\t/// @notice Perform buy liquidated collateral operation\r\n\tfunction buyLiquidatedCollateralInternal (address market, address collateral, uint256 marketAmount)\r\n\t\tinternal\r\n\t\tnonReentrant\r\n\t\twhenNotPaused(\"buyLiquidatedCollateral\")\r\n\t{\r\n\t\tuint256 transferAmount = transferFromSender(address(this), market, marketAmount);\r\n\t\tmarketDebt[collateral][market] = marketDebt[collateral][market].sub(transferAmount, \u0027E17\u0027);\r\n\r\n\t\tuint256 collateralAmountWithDiscount =\r\n\t\t\tgetDiscountedCollateralAmount(market, collateral, transferAmount);\t\t\r\n\t\tcollateralAssets[collateral].totalLiquidatedCollateral = \r\n\t\t\tcollateralAssets[collateral].totalLiquidatedCollateral.sub(collateralAmountWithDiscount, \u0027E16\u0027);\r\n\t\t\r\n\t\tholdefiCollaterals.withdraw(collateral, msg.sender, collateralAmountWithDiscount);\r\n\r\n\t\temit BuyLiquidatedCollateral(market, collateral, transferAmount, collateralAmountWithDiscount);\r\n\t}\r\n\r\n\t/// @notice Perform deposit promotion reserve operation\r\n\tfunction depositPromotionReserveInternal (address market, uint256 amount)\r\n\t\tinternal\r\n\t\tnonReentrant\r\n\t\twhenNotPaused(\"depositPromotionReserve\")\r\n\t\tmarketIsActive(market)\r\n\t{\r\n\t\tuint256 transferAmount = transferFromSender(address(this), market, amount);\r\n\r\n\t\tuint256 amountScaled = transferAmount.mul(secondsPerYear).mul(rateDecimals);\r\n\r\n\t\tmarketAssets[market].promotionReserveScaled = \r\n\t\t\tmarketAssets[market].promotionReserveScaled.add(amountScaled);\r\n\r\n\t\temit PromotionReserveDeposited(market, transferAmount, marketAssets[market].promotionReserveScaled);\r\n\t}\r\n\r\n\t/// @notice Perform deposit liquidation reserve operation\r\n\tfunction depositLiquidationReserveInternal (address collateral, uint256 amount)\r\n\t\tinternal\r\n\t\tnonReentrant\r\n\t\twhenNotPaused(\"depositLiquidationReserve\")\r\n\t\tcollateralIsActive(collateral)\r\n\t{\r\n\t\tuint256 transferAmount = transferFromSender(address(holdefiCollaterals), collateral, amount);\r\n\t\tif (collateral == ethAddress) {\r\n\t\t\ttransferFromHoldefi(address(holdefiCollaterals), collateral, amount);\r\n\t\t}\r\n\r\n\t\tcollateralAssets[collateral].totalLiquidatedCollateral =\r\n\t\t\tcollateralAssets[collateral].totalLiquidatedCollateral.add(transferAmount);\r\n\t\t\r\n\t\temit LiquidationReserveDeposited(collateral, transferAmount);\r\n\t}\r\n}"},"HoldefiCollaterals.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"./SafeERC20.sol\";\n\n\n/// @title HoldefiCollaterals\n/// @author Holdefi Team\n/// @notice Collaterals is held by this contract\n/// @dev The address of ETH asset considered as 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n/// @dev Error codes description: \n/// \tCE01: Sender should be Holdefi contract\n/// \tCE02: Cannot transfer\ncontract HoldefiCollaterals {\n\n\tusing SafeERC20 for IERC20;\n\n\taddress constant private ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\taddress public holdefiContract;\n\n\t/// @dev Initializes the main Holdefi contract address\n\tconstructor() public {\n\t\tholdefiContract = msg.sender;\n\t}\n\n\t/// @notice Modifier to check that only Holdefi contract interacts with the function\n    modifier onlyHoldefiContract() {\n        require (msg.sender == holdefiContract, \"CE01\");\n        _;\n    }\n\n\t/// @notice Only Holdefi contract can send ETH to this contract\n    receive() external payable onlyHoldefiContract {\n\t}\n\n\t/// @notice Holdefi contract withdraws collateral from this contract to recipient account\n\t/// @param collateral Address of the given collateral\n\t/// @param recipient Address of the recipient\n\t/// @param amount Amount to be withdrawn\n\tfunction withdraw (address collateral, address recipient, uint256 amount)\n\t\texternal\n\t\tonlyHoldefiContract\n\t{\n\t\tif (collateral == ethAddress){\n\t\t\t(bool success, ) = recipient.call{value:amount}(\"\");\n\t\t\trequire (success, \"CE02\");\n\t\t}\n\t\telse {\n\t\t\tIERC20 token = IERC20(collateral);\n\t\t\ttoken.safeTransfer(recipient, amount);\n\t\t}\n\t}\n}"},"HoldefiOwnable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n/// @title HoldefiOwnable\n/// @author Holdefi Team\n/// @notice Taking ideas from Open Zeppelin\u0027s Ownable contract\n/// @dev Contract module which provides a basic access control mechanism, where\n/// there is an account (an owner) that can be granted exclusive access to\n/// specific functions.\n///\n/// By default, the owner account will be the one that deploys the contract. This\n/// can later be changed with {transferOwnership}.\n///\n/// This module is used through inheritance. It will make available the modifier\n/// `onlyOwner`, which can be applied to your functions to restrict their use to\n/// the owner.\n/// @dev Error codes description: \n///     OE01: Sender should be the owner\n///     OE02: New owner can not be zero address\n///     OE03: Pending owner is empty\n///     OE04: Pending owner is not same as the `msg.sender`\ncontract HoldefiOwnable {\n    address public owner;\n    address public pendingOwner;\n\n    /// @notice Event emitted when an ownership transfer request is recieved\n    event OwnershipTransferRequested(address newPendingOwner);\n\n    /// @notice Event emitted when an ownership transfer request is accepted by the pending owner\n    event OwnershipTransferred(address newOwner, address oldOwner);\n\n    /// @notice Initializes the contract owner\n    constructor () public {\n        owner = msg.sender;\n        emit OwnershipTransferred(owner, address(0));\n    }\n\n    /// @notice Throws if called by any account other than the owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"OE01\");\n        _;\n    }\n\n    /// @notice Transfers ownership of the contract to a new owner\n    /// @dev Can only be called by the current owner\n    /// @param newOwner Address of new owner\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"OE02\");\n        pendingOwner = newOwner;\n\n        emit OwnershipTransferRequested(newOwner);\n    }\n\n    /// @notice Pending owner accepts ownership of the contract\n    /// @dev Only Pending owner can call this function\n    function acceptTransferOwnership () external {\n        require (pendingOwner != address(0), \"OE03\");\n        require (pendingOwner == msg.sender, \"OE04\");\n        \n        emit OwnershipTransferred(pendingOwner, owner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}"},"HoldefiPausableOwnable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./HoldefiOwnable.sol\";\n\n/// @title HoldefiPausableOwnable\n/// @author Holdefi Team\n/// @notice Taking ideas from Open Zeppelin\u0027s Pausable contract\n/// @dev Base contract which allows children to implement an emergency stop mechanism.\n/// @dev Error codes description: \n///     POE01: Sender should be the owner or the pauser\n///     POE02: Operation is paused\n///     POE03: Operation is unpaused\n///     POE04: Operation is not valid\n///     POE05: Duration is not in the allowed range\n///     POE06: Lists are not equal in length\ncontract HoldefiPausableOwnable is HoldefiOwnable {\n\n    uint256 constant private maxPauseDuration = 2592000;     //seconds per month\n\n    struct Operation {\n        bool isValid;\n        uint256 pauseEndTime;\n    }\n\n    /// @notice Pauser can pause operations but can\u0027t unpause them\n    address public pauser;\n\n    mapping(string =\u003e Operation) public paused;\n\n    /// @notice Event emitted when the pauser is changed by the owner\n    event PauserChanged(address newPauser, address oldPauser);\n\n    /// @notice Event emitted when an operation is paused by the pauser\n    event OperationPaused(string operation, uint256 pauseDuration);\n\n    /// @notice Event emitted when an operation is unpaused by the owner\n    event OperationUnpaused(string operation);\n    \n    /// @notice Define valid operations that can be paused\n    constructor () public {\n        paused[\"supply\"].isValid = true;\n        paused[\"withdrawSupply\"].isValid = true;\n        paused[\"collateralize\"].isValid = true;\n        paused[\"withdrawCollateral\"].isValid = true;\n        paused[\"borrow\"].isValid = true;\n        paused[\"repayBorrow\"].isValid = true;\n        paused[\"liquidateBorrowerCollateral\"].isValid = true;\n        paused[\"buyLiquidatedCollateral\"].isValid = true;\n        paused[\"depositPromotionReserve\"].isValid = true;\n        paused[\"depositLiquidationReserve\"].isValid = true;\n    }\n\n    /// @dev Modifier to make a function callable only by owner or pauser\n    modifier onlyPausers() {\n        require(msg.sender == owner || msg.sender == pauser , \"POE01\");\n        _;\n    }\n    \n    /// @dev Modifier to make a function callable only when an operation is not paused\n    /// @param operation Name of the operation\n    modifier whenNotPaused(string memory operation) {\n        require(!isPaused(operation), \"POE02\");\n        _;\n    }\n\n    /// @dev Modifier to make a function callable only when an operation is paused\n    /// @param operation Name of the operation\n    modifier whenPaused(string memory operation) {\n        require(isPaused(operation), \"POE03\");\n        _;\n    }\n\n    /// @dev Modifier to make a function callable only when an operation is valid\n    /// @param operation Name of the operation\n    modifier operationIsValid(string memory operation) {\n        require(paused[operation].isValid ,\"POE04\");\n        _;\n    }\n\n    /// @notice Returns the pause status of a given operation\n    /// @param operation Name of the operation\n    /// @return res Pause status of a given operation\n    function isPaused(string memory operation) public view returns (bool res) {\n        res = block.timestamp \u003c= paused[operation].pauseEndTime;\n    }\n\n    /// @notice Called by pausers to pause an operation, triggers stopped state\n    /// @param operation Name of the operation\n    /// @param pauseDuration The length of time the operation must be paused\n    function pause(string memory operation, uint256 pauseDuration)\n        public\n        onlyPausers\n        operationIsValid(operation)\n        whenNotPaused(operation)\n    {\n        require (pauseDuration \u003c= maxPauseDuration, \"POE05\");\n        paused[operation].pauseEndTime = block.timestamp + pauseDuration;\n        emit OperationPaused(operation, pauseDuration);\n    }\n\n    /// @notice Called by owner to unpause an operation, returns to normal state\n    /// @param operation Name of the operation\n    function unpause(string memory operation)\n        public\n        onlyOwner\n        operationIsValid(operation)\n        whenPaused(operation)\n    {\n        paused[operation].pauseEndTime = 0;\n        emit OperationUnpaused(operation);\n    }\n\n    /// @notice Called by pausers to pause operations, triggers stopped state for selected operations\n    /// @param operations List of operation names\n    /// @param pauseDurations List of durations specifying the pause time of each operation\n    function batchPause(string[] memory operations, uint256[] memory pauseDurations) external {\n        require (operations.length == pauseDurations.length, \"POE06\");\n        for (uint256 i = 0 ; i \u003c operations.length ; i++) {\n            pause(operations[i], pauseDurations[i]);\n        }\n    }\n\n    /// @notice Called by pausers to unpause operations, returns to normal state for selected operations\n    /// @param operations List of operation names\n    function batchUnpause(string[] memory operations) external {\n        for (uint256 i = 0 ; i \u003c operations.length ; i++) {\n            unpause(operations[i]);\n        }\n    }\n\n    /// @notice Called by owner to set a new pauser\n    /// @param newPauser Address of new pauser\n    function setPauser(address newPauser) external onlyOwner {\n        emit PauserChanged(newPauser, pauser);\n        pauser = newPauser;\n    }\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c \u003c a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b \u003e a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a % b;\n    }\n}\n"}}