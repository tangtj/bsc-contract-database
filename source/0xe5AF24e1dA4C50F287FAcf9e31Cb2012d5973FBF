{"Defi2x.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport \"./IERC20.sol\";\r\n\r\ncontract Defi2x {\r\n    IERC20 public busdToken;\r\n    \r\n    uint256 public todayDeposits;\r\n    uint256 public todayRegistrations;\r\n    uint256 public lastResetTimestamp;\r\n\r\n    struct User {\r\n        address referrer;\r\n        address userAddress;\r\n        uint256 totalChilds;\r\n        uint256 balance;\r\n        uint256 totalWithdrawal;\r\n        uint256 noOfjoined;\r\n        bool isJoined;\r\n    }\r\n\r\n    mapping(address =\u003e User) public users;\r\n    address[] public Addresses;\r\n    address public adminAddress;\r\n\r\n    uint256 public registerAmount = 20; // Example registration amount in BUSD (assuming 8 decimals)\r\n    uint256 public doubleAmount = 40; // Example double amount in BUSD (assuming 8 decimals)\r\n    uint256 public adminAmount = 5;\r\n\r\n    event Registration(address indexed user, address indexed referrer);\r\n    event JoinUser(address indexed user, uint256 amount);\r\n    event Withdrawal(address indexed user, uint256 amount);\r\n    event AllowanceGranted(address indexed user, uint256 amount);\r\n\r\n    constructor(address busdTokenAddress) {\r\n        // Register the contract deployer as the first user\r\n        users[msg.sender] = User(address(0), msg.sender, 0, 0, 0, 1, true);\r\n        Addresses.push(msg.sender);\r\n        adminAddress = msg.sender;\r\n        lastResetTimestamp = block.timestamp;\r\n        todayRegistrations = 1;\r\n        todayDeposits = registerAmount;\r\n        busdToken = IERC20(busdTokenAddress);\r\n    }\r\n\r\n    function register(address referrer) external {\r\n       \r\n        uint256 userBalance = busdToken.balanceOf(msg.sender);\r\n        uint256 allowance = busdToken.allowance(msg.sender, address(this));\r\n\r\n        require(userBalance \u003e= registerAmount, \"Insufficient balance\");\r\n        require(allowance \u003e= registerAmount, \"Allowance not sufficient\");\r\n        User storage user = users[msg.sender];\r\n        \r\n        // Update registrations and deposits counts based on the date\r\n\r\n        if (isToday(lastResetTimestamp)) {\r\n            todayRegistrations++;\r\n            todayDeposits += registerAmount;\r\n        } else {\r\n            todayRegistrations = 1;\r\n            todayDeposits = registerAmount;\r\n            lastResetTimestamp = block.timestamp;\r\n        }\r\n\r\n        if (user.userAddress == address(0)) {\r\n            uint256 refTotalchilds = users[referrer].totalChilds + 1;\r\n            require(\r\n                users[referrer].userAddress != address(0) ||\r\n                    referrer == address(0),\r\n                \"Upline does not exist\"\r\n            );\r\n\r\n            busdTokenTransferFrom(msg.sender, address(this), registerAmount);\r\n            User memory newUser = User(referrer, msg.sender, 0, 0, 0, 1, true);\r\n\r\n            // referrer condition\r\n            if (referrer != address(0)) {\r\n                if (refTotalchilds % 2 == 0) {\r\n                    if (refTotalchilds / 2 == users[referrer].noOfjoined) {\r\n                        users[referrer].balance += doubleAmount;\r\n                        users[adminAddress].balance += adminAmount;\r\n                    }\r\n                }\r\n            }\r\n\r\n            users[msg.sender] = newUser;\r\n            users[referrer].totalChilds = refTotalchilds;\r\n            Addresses.push(msg.sender);\r\n            emit JoinUser(msg.sender, registerAmount);\r\n            emit Registration(msg.sender, referrer);\r\n        } else {\r\n            busdTokenTransferFrom(msg.sender, address(this), registerAmount);\r\n            uint256 Totalchilds = users[msg.sender].totalChilds;\r\n            uint256 noOfjoined = users[msg.sender].noOfjoined + 1;\r\n\r\n            if (Totalchilds % 2 == 0) {\r\n                if (Totalchilds / 2 == noOfjoined) {\r\n                    users[msg.sender].balance += doubleAmount;\r\n                    users[adminAddress].balance += adminAmount;\r\n                }\r\n            }\r\n\r\n            users[msg.sender].noOfjoined = noOfjoined;\r\n            emit JoinUser(msg.sender, registerAmount);\r\n        }\r\n    }\r\n\r\n    function busdTokenTransferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        return busdToken.transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function withdrawal() external {\r\n        require(users[msg.sender].balance \u003e 0, \"Invalid amount\");\r\n        uint256 busdAmount = users[msg.sender].balance;   \r\n        require(\r\n            busdToken.balanceOf(address(this)) \u003e= busdAmount,\r\n            \"Insufficient contract balance\"\r\n        );\r\n        users[msg.sender].balance = 0; // Reset the pending balance\r\n        users[msg.sender].totalWithdrawal += busdAmount;\r\n        require(busdToken.transfer(msg.sender, busdAmount), \"Transfer failed\");\r\n        emit Withdrawal(msg.sender, busdAmount);\r\n    }\r\n\r\n    function contractBalance() public view returns (uint256) {\r\n        \r\n        return busdToken.balanceOf(address(this));\r\n    }\r\n\r\n    function getAllUsers() public view returns (User[] memory) {\r\n        User[] memory allUsers = new User[](Addresses.length);\r\n        for (uint256 i = 0; i \u003c Addresses.length; i++) {\r\n            allUsers[i] = users[Addresses[i]];\r\n        }\r\n        return allUsers;\r\n    }\r\n\r\n    function isToday(uint256 timestamp) internal view returns (bool) {\r\n        uint256 today = block.timestamp / 86400; // 86400 seconds in a day\r\n        uint256 timestampDay = timestamp / 86400;\r\n\r\n        return today == timestampDay;\r\n    }\r\n\r\n    function getApproval() external {\r\n        busdToken.approve(address(this), registerAmount);\r\n        emit AllowanceGranted(msg.sender, registerAmount);\r\n    }\r\n}\r\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"}}