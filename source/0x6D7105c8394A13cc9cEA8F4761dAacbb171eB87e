{"BUSDLotto.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\nimport \"./IBEP20.sol\";\n\ncontract BUSDLotto is Ownable {\n    address private BUSDContract;\n    address private developerWallet;\n    uint256 public constant PRICE = 10 ether;\n\n    mapping(address =\u003e address) private referrals;\n    mapping(address =\u003e uint256) private referralsDiff;\n    mapping(address =\u003e uint256) private rewards;\n    mapping(address =\u003e uint256) private userIndex;\n    mapping(uint256 =\u003e address) private users;\n    mapping(uint256 =\u003e address) private tickets;\n    mapping(uint256 =\u003e uint256) public winners;\n    mapping(uint256 =\u003e uint256) public winnersTimestamp;\n\n    uint256 public _currentIndex;\n    uint256 private nonce;\n    uint256 private currentUserIndex = 100000;\n\n    address [] referralsArray;\n\n    constructor(address _contract, uint256 _nonce, address _developer) {\n        BUSDContract = _contract;\n        nonce = _nonce;\n        developerWallet = _developer;\n    }\n\n    function buyTicket(uint256 numberOfTickets, uint256 referral) external {\n        require(IBEP20(BUSDContract).balanceOf(msg.sender) \u003e= numberOfTickets * PRICE);\n        require(IBEP20(BUSDContract).allowance(msg.sender, address(this)) \u003e= numberOfTickets * PRICE);\n\n    unchecked {\n        if (userIndex[msg.sender] == 0) {\n            registerUser();\n        }\n\n        if (referral != 0 \u0026\u0026 referrals[msg.sender] == address(0)) {\n            if (msg.sender != users[referral]) {\n                referrals[msg.sender] = users[referral];\n                referralsDiff[msg.sender] = balanceTicketsOf(msg.sender);\n                referralsArray.push(msg.sender);\n            }\n        }\n\n        uint256 developerReward = 1 ether;\n\n        if (referrals[msg.sender] != address(0)) {\n            bool transferStatusRef = IBEP20(BUSDContract).transferFrom(msg.sender, referrals[msg.sender], numberOfTickets * 1 ether);\n            require(transferStatusRef, \"Lottery: Transfer BUSD error (ref)\");\n        } else {\n            developerReward += 1 ether;\n        }\n\n        bool transferStatusDev = IBEP20(BUSDContract).transferFrom(msg.sender, developerWallet, numberOfTickets * developerReward);\n        require(transferStatusDev, \"Lottery: Transfer BUSD error (dev)\");\n\n        bool transferStatus = IBEP20(BUSDContract).transferFrom(msg.sender, address(this), numberOfTickets * (PRICE - 2 ether));\n        require(transferStatus, \"Lottery: Transfer BUSD error (buy)\");\n\n        for(uint i = 0; i \u003c numberOfTickets; i++) {\n            nextTicket(msg.sender);\n        }\n    }\n    }\n\n    function registerUser() public {\n        require(userIndex[msg.sender] == 0);\n    unchecked {\n        currentUserIndex++;\n        userIndex[msg.sender] = currentUserIndex;\n        users[currentUserIndex] = msg.sender;\n    }\n    }\n\n    function userId(address user) public view returns(uint256) {\n        return userIndex[user];\n    }\n\n    function nextTicket(address buyer) private {\n    unchecked {\n        _currentIndex++;\n        tickets[_currentIndex] = buyer;\n\n        if (_currentIndex % 10 == 0) {\n            uint256 winner = random(_currentIndex - 9, _currentIndex);\n            winners[winner] = 40;\n            winnersTimestamp[winner] = block.timestamp;\n            rewards[tickets[winner]] += 40 ether;\n        }\n\n        if (_currentIndex % 100 == 0) {\n            uint256 winner = random(_currentIndex - 99, _currentIndex);\n            winners[winner] = 100;\n            winnersTimestamp[winner] = block.timestamp;\n            rewards[tickets[winner]] += 100 ether;\n        }\n\n        if (_currentIndex % 1000 == 0) {\n            uint256 winner = random(_currentIndex - 999, _currentIndex);\n            winners[winner] = 1000;\n            winnersTimestamp[winner] = block.timestamp;\n            rewards[tickets[winner]] += 1000 ether;\n        }\n\n        if (_currentIndex % 10000 == 0) {\n            uint256 winner = random(_currentIndex - 9999, _currentIndex);\n            winners[winner] = 10000;\n            winnersTimestamp[winner] = block.timestamp;\n            rewards[tickets[winner]] += 10000 ether;\n        }\n\n        if (_currentIndex % 100000 == 0) {\n            uint256 winner = random(_currentIndex - 99999, _currentIndex);\n            winners[winner] = 100000;\n            winnersTimestamp[winner] = block.timestamp;\n            rewards[tickets[winner]] += 100000 ether;\n        }\n    }\n    }\n\n    function claim() external {\n        require(rewards[msg.sender] \u003e 0);\n        require(IBEP20(BUSDContract).balanceOf(address(this)) \u003e= rewards[msg.sender]);\n\n    unchecked {\n        uint256 _reward = rewards[msg.sender];\n        rewards[msg.sender] -= _reward;\n        bool claimStatus = IBEP20(BUSDContract).transfer(msg.sender, _reward);\n        require(claimStatus, \"Lottery: Transfer claim BUSD error\");\n    }\n    }\n\n    function random(uint256 min, uint256 max) internal returns(uint256) {\n        uint256 rand = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, nonce)));\n        nonce++;\n        return min + rand % (max + 1 - min);\n    }\n\n    function rewardOf(address user) public view returns(uint256) {\n        return rewards[user];\n    }\n\n    function balanceTicketsOf(address user) public view returns(uint256) {\n        uint256 _ticketsCount;\n\n    unchecked {\n        for(uint256 i = 1; i \u003c= _currentIndex; i++) {\n            if (tickets[i] == user) {\n                _ticketsCount++;\n            }\n        }\n    }\n\n        return _ticketsCount;\n    }\n\n    function getWinners() public view returns (address[] memory, uint256[] memory, uint256[] memory) {\n        uint256 count = getCountWinners();\n        address[] memory _winners = new address[](count);\n        uint256[] memory _winnersSum = new uint256[](count);\n        uint256[] memory _winnersDate = new uint256[](count);\n        uint256 j;\n\n    unchecked {\n        for (uint256 i = 1; i \u003c= _currentIndex; i++) {\n            if(winners[i] \u003e 0) {\n                _winners[j] = tickets[i];\n                _winnersSum[j] = winners[i];\n                _winnersDate[j] = winnersTimestamp[i];\n                j++;\n            }\n        }\n    }\n\n        return (_winners, _winnersSum, _winnersDate);\n    }\n\n    function userReferrals(address user) public view returns (address[] memory, uint256[] memory) {\n        uint256 count = getCountReferrals(user);\n        address [] memory _referrals = new address[](count);\n        uint256 [] memory _referralsReward = new uint256[](count);\n        uint256 j;\n\n    unchecked {\n        for (uint256 i = 0; i \u003c referralsArray.length; i++) {\n            if (referrals[referralsArray[i]] == user) {\n                _referrals[j] = referralsArray[i];\n                _referralsReward[j] = balanceTicketsOf(referralsArray[i]) - referralsDiff[referralsArray[i]];\n                j++;\n            }\n        }\n    }\n\n        return (_referrals, _referralsReward);\n    }\n\n    function userWins(address user) public view returns (uint256[] memory) {\n        uint256 count = getCountWins(user);\n        uint256[] memory _wins = new uint256[](count);\n        uint256 j;\n\n    unchecked {\n        for (uint256 i = 1; i \u003c= _currentIndex; i++) {\n            if (tickets[i] == user \u0026\u0026 winners[i] \u003e 0) {\n                _wins[j] = winners[i];\n                j++;\n            }\n        }\n    }\n\n        return _wins;\n    }\n\n    function getCountReferrals(address user) internal view returns (uint256) {\n        uint256 count;\n\n    unchecked {\n        for (uint256 i = 0; i \u003c referralsArray.length; i++) {\n            if (referrals[referralsArray[i]] == user) {\n                count++;\n            }\n        }\n    }\n\n        return count;\n    }\n\n    function getCountWinners() internal view returns (uint256) {\n        uint256 count;\n\n    unchecked {\n        for (uint256 i = 1; i \u003c= _currentIndex; i++) {\n            if (winners[i] \u003e 0) {\n                count++;\n            }\n        }\n    }\n\n        return count;\n    }\n\n    function getCountWins(address user) internal view returns (uint256) {\n        uint256 count;\n\n    unchecked {\n        for (uint256 i = 1; i \u003c= _currentIndex; i++) {\n            if (tickets[i] == user \u0026\u0026 winners[i] \u003e 0) {\n                count++;\n            }\n        }\n    }\n\n        return count;\n    }\n\n    function withdraw() external onlyOwner {\n        uint256 balance = IBEP20(BUSDContract).balanceOf(address(this));\n        IBEP20(BUSDContract).transfer(msg.sender, balance);\n    }\n\n    function setDeveloperWallet(address developer) external onlyOwner {\n        require(developer != address(0));\n        developerWallet = developer;\n    }\n}"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IBEP20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n   */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the token decimals.\n   */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the token symbol.\n   */\n    function symbol() external view returns (string memory);\n\n    /**\n    * @dev Returns the token name.\n  */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the bep token owner.\n   */\n    function getOwner() external view returns (address);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n   */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n    function allowance(address _owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender\u0027s allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller\u0027s\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \u0027./Context.sol\u0027;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n  constructor() {\n    _setOwner(_msgSender());\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n     */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n     */\n  modifier onlyOwner() {\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n  function renounceOwnership() public virtual onlyOwner {\n    _setOwner(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _setOwner(newOwner);\n  }\n\n  function _setOwner(address newOwner) private {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n}\n"}}