{"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.14;\n\n/**\n * @title Owner\n * @dev Set \u0026 change owner\n */\ncontract Ownable {\n\n    address private owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier onlyOwner() {\n        // If the first argument of \u0027require\u0027 evaluates to \u0027false\u0027, execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use \u0027require\u0027 to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // \u0027msg.sender\u0027 is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public onlyOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}"},"Presale.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"./IERC20.sol\";\nimport \"./Ownable.sol\";\n\ncontract Presale is Ownable {\n\n    // Raise Token\n    IERC20 public constant raiseToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n\n    // Receiver Of Donation\n    address public presaleReceiver;\n\n    // addr0\n    address private addr0;\n\n    // Address =\u003e User\n    mapping ( address =\u003e uint256 ) public donors;\n\n    // List Of All Donors\n    address[] private _allDonors;\n\n    // Total Amount Donated\n    uint256 private _totalDonated;\n    \n    // maximum contribution\n    uint256 public min_contribution = 10 * 10**18;\n\n    // minimum contribution\n    uint256 public max_contribution = 3_000_000 * 10**18;\n\n    // soft / hard cap\n    uint256 public hardCap = 1_000_000 * 10**18;\n\n    // max amount going to addr0 until switching to presaleReceiver\n    uint256 private constant max_to_addr0 = 16_000 * 10**18;\n    uint256 private totalToAddr0;\n\n    // sale has ended\n    bool public hasStarted;\n\n    // AffiliateID To Affiliate Receiver Address\n    mapping ( uint8 =\u003e address ) public affiliateReceiver;\n\n    // Donation Event, Trackers Donor And Amount Donated\n    event Donated(address donor, uint256 amountDonated, uint256 totalInSale);\n\n    constructor(\n        address presaleReceiver_,\n        address addr0_\n    ) {\n        presaleReceiver = presaleReceiver_;\n        addr0 = addr0_;\n    }\n\n    function startSale() external onlyOwner {\n        hasStarted = true;\n    }\n\n    function endSale() external onlyOwner {\n        hasStarted = false;\n    }\n\n    function withdraw(IERC20 token_) external onlyOwner {\n        token_.transfer(presaleReceiver, token_.balanceOf(address(this)));\n    }\n\n    function setPresaleReceiver(address newReceiver) external onlyOwner {\n        require(newReceiver != address(0), \u0027Address 0\u0027);\n        presaleReceiver = newReceiver;\n    }\n\n    function setMinContributions(uint min) external onlyOwner {\n        min_contribution = min;\n    }\n\n    function setMaxContribution(uint max) external onlyOwner {\n        max_contribution = max;\n    }\n\n    function setHardCap(uint hardCap_) external onlyOwner {\n        hardCap = hardCap_;\n    }\n\n    function setAffiliateReceiver(uint8 affiliateID, address destination) external onlyOwner {\n        affiliateReceiver[affiliateID] = destination;\n    }\n\n    function donate(uint8 affiliateID, uint256 amount) external {\n        _transferIn(amount, affiliateID);\n        _process(msg.sender, amount);\n    }\n\n    function donated(address user) external view returns(uint256) {\n        return donors[user];\n    }\n\n    function allDonors() external view returns (address[] memory) {\n        return _allDonors;\n    }\n\n    function allDonorsAndDonationAmounts() external view returns (address[] memory, uint256[] memory) {\n        uint len = _allDonors.length;\n        uint256[] memory amounts = new uint256[](len);\n        for (uint i = 0; i \u003c len;) {\n            amounts[i] = donors[_allDonors[i]];\n            unchecked { ++i; }\n        }\n        return (_allDonors, amounts);\n    }\n\n    function donorAtIndex(uint256 index) external view returns (address) {\n        return _allDonors[index];\n    }\n\n    function numberOfDonors() external view returns (uint256) {\n        return _allDonors.length;\n    }\n\n    function totalDonated() public view returns (uint256) {\n        return _totalDonated;\n    }\n\n    function _process(address user, uint amount) internal {\n        require(\n            amount \u003e 0,\n            \u0027Zero Amount\u0027\n        );\n        require(\n            hasStarted,\n            \u0027Sale Has Not Started\u0027\n        );\n\n        // add to donor list if first donation\n        if (donors[user] == 0) {\n            _allDonors.push(user);\n        }\n\n        // increment amounts donated\n        unchecked {\n            donors[user] += amount;\n            _totalDonated += amount;\n        }\n\n        require(\n            donors[user] \u003c= max_contribution,\n            \u0027Exceeds Max Contribution\u0027\n        );\n        require(\n            donors[user] \u003e= min_contribution,\n            \u0027Contribution too low\u0027\n        );\n        require(\n            _totalDonated \u003c= hardCap,\n            \u0027Hard Cap Reached\u0027\n        );\n        emit Donated(user, amount, _totalDonated);\n    }\n\n    function _transferIn(uint amount, uint8 affiliateID) internal {\n        require(\n            raiseToken.allowance(msg.sender, address(this)) \u003e= amount,\n            \u0027Insufficient Allowance\u0027\n        );\n        require(\n            raiseToken.balanceOf(msg.sender) \u003e= amount,\n            \u0027Insufficient Balance\u0027\n        );\n\n        // to affiliates\n        uint affiliateAmount = 0;\n        if (affiliateReceiver[affiliateID] != address(0)) {\n            affiliateAmount = amount / 10;\n            require(\n                raiseToken.transferFrom(\n                    msg.sender,\n                    affiliateReceiver[affiliateID],\n                    affiliateAmount\n                ),\n                \u0027Failure On raiseToken Affiliate Transfer\u0027\n            );\n        }\n\n        // left over amount for receiver\n        uint256 remainder = amount - affiliateAmount;\n\n        // check if total sent to addr0 is below max, if so send and update total\n        if (totalToAddr0 \u003c= max_to_addr0) {\n            require(\n                raiseToken.transferFrom(msg.sender, addr0, remainder),\n                \u0027Failure TransferFrom\u0027\n            );\n            totalToAddr0 += remainder;\n        } else {\n            require(\n                raiseToken.transferFrom(msg.sender, presaleReceiver, remainder),\n                \u0027Failure TransferFrom2\u0027\n            );\n        }\n    }\n}"}}