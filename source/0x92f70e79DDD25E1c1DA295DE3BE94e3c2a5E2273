{"Manager.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n/*\r\n\r\n\r\n* @author Cesar Maia developer senior solidity, smart contracts, react, c#, \r\n* nosql, msssql, node.js\r\n* telegram: https://t.me/cesarmaia_dev\r\n*****************************************************************************\r\n* @notice using Manager Factory\r\n******************************************************************************\r\n* @dev PURPOSE\r\n*\r\n* @dev Luckynumber is the betting game of one player against another.\r\n*\r\n* @dev How it works:\r\n* @dev - Players approve the tokens and choose the desired numbers that are available in a raffle, \r\n* @dev when purchasing the number an NFT is minted and the money transferred to the raffle contract. \r\n* @dev The draw is made when the total number of numbers are sold or when the end date arrives. \r\n* @dev Only the winner can claim this prize.\r\n*\r\n* @dev The contract Manager.sol (VRFConsumerBase) uses a ChainLink VRF interface where a random number is provided, \r\n* @dev this number is extracted from a number that is drawn by the number of numbers sold. \r\n* @dev After receiving the number, the contract is closed.\r\n*\r\n* @dev The Manager.sol contract is a factory contract that creates the other Raffle contracts, \r\n* @dev which exist temporarily until the prize amount is withdrawn. \r\n* @dev Each raffle is created with the amount, token and end date.\r\n*\r\n* @dev The Raffle.sol contract (ERC721) is a contract created by Manager.sol \r\n* @dev only the MINT and CLAIM functions are used.\r\n*/\r\n\r\nimport \"./Raffle.sol\";\r\nimport \"./VRFCoordinatorV2Interface.sol\";\r\nimport \"./VRFConsumerBaseV2.sol\";\r\n\r\ninterface ICryptoFlip {\r\n   function getOperador() external view returns (address);\r\n}\r\n\r\ncontract Manager is VRFConsumerBaseV2 \r\n{\r\n  using SafeMath for uint256;\r\n\r\n  VRFCoordinatorV2Interface COORDINATOR;\r\n\r\n // Your subscription ID.\r\n  uint64 private _subscriptionid;\r\n  \r\n  // The gas lane to use, which specifies the maximum gas price to bump to.\r\n  // For a list of available gas lanes on each network,\r\n  // see https://docs.chain.link/docs/vrf-contracts/#configurations\r\n  bytes32 private _keyhash;\r\n\r\n  // Depends on the number of requested values that you want sent to the\r\n  // fulfillRandomWords() function. Storing each word costs about 20,000 gas,\r\n  // so 2500000 is a safe default for this example contract. Test and adjust\r\n  // this limit based on the network that you select, the size of the request,\r\n  // and the processing of the callback request in the fulfillRandomWords()\r\n  // function.\r\n  uint32 public gasLimit = 250000;\r\n\r\n  // The default is 3, but you can set this higher.\r\n  uint16 constant private REQUEST_CONFIRMATIONS = 3;\r\n\r\n  // For this example, retrieve 2 random values in one request.\r\n  // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.\r\n  uint32 constant private NUM_WORDS =  1;\r\n\r\n  address private _owner;\r\n  \r\n  uint public priceNumber = 100000000000000;\r\n\r\n  //Wallet office that receives the fee rates\r\n  address private _office = 0xC0ad39510aA162d0C10428b705172e331be8F498;\r\n    \r\n  //Value of fee tax div 20 = 5%\r\n  uint256 private _fee = 5; //5%\r\n  uint256 private _tax = 100000000000000000; //0.1\r\n\r\n  //id generated from the manufacture of the Rifa contract\r\n  uint public raffleId = 0; \r\n\r\n  //total active raffles\r\n  uint public eventCount = 0; \r\n\r\n  //total raffle created\r\n  uint public raffleTotal = 0; \r\n\r\n  //Mapping contract address with manufactured contract\r\n  mapping(address =\u003e Raffle) private raffleItems;\r\n\r\n  //Mapping request for the drawn number linked to the Raffle\u0027s address\r\n  mapping(uint256 =\u003e address) private requests;\r\n\r\n  //Mapping contract address with manufactured contract\r\n  mapping(address =\u003e bool) public randomNumbers;\r\n  mapping(address =\u003e bool) public isExcludedFromFees;\r\n  mapping(address =\u003e uint) public results;\r\n\r\n  /**\r\n  * @dev Emitted contractAddress address raffle contract\r\n  * @dev Emitted id raffle contract\r\n  * @dev Emitted eventName raffle contract\r\n  * @dev Emitted timestamp date now\r\n  */\r\n\r\n  event EventLog(address indexed contractAddress, uint id, string eventName, uint timestamp); \r\n    /**\r\n  * @dev Emitted raffle address raffle contract\r\n  * @dev Emitted id raffle contract\r\n  * @dev Emitted quant numbers purchased\r\n  * @dev Emitted requestId chainlink\r\n  * @dev Emitted randomWords chainlink\r\n  * @dev Emitted result request\r\n  * @dev Emitted timestamp date now\r\n  */\r\n\r\n   event EventRandomResult(address indexed raffle, uint id, uint quant, uint256 requestId, uint256 randomWord, uint256 result, uint256 timestamp); \r\n\r\n  /**\r\n  * @dev Emitted office \r\n  * @dev Emitted fee\r\n  */\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == _owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  3131\r\n  0x6a2aad07396b36fe02a22b33cf443582f682c82f coordinator\r\n  0xd4bb89654db74673a187bd804519e65e3f71a52bc55f11da7601a13dcf505314 keyhash\r\n  */\r\n  constructor(uint64 subId, address coordinator, bytes32 keyhash) VRFConsumerBaseV2(coordinator) \r\n  {\r\n    COORDINATOR = VRFCoordinatorV2Interface(coordinator);\r\n    _owner = msg.sender;\r\n    _subscriptionid = subId;\r\n    _keyhash = keyhash;\r\n    isExcludedFromFees[_owner] = true;\r\n\r\n  }\r\n  function excludeFromFees(address account, bool excluded) external onlyOwner{\r\n        require(isExcludedFromFees[account] != excluded,\"Account is already the value of \u0027excluded\u0027\");\r\n        isExcludedFromFees[account] = excluded;\r\n  }\r\n\r\n  /// @dev verify the contract owner\r\n  /// @return owner\u0027s wallet address\r\n  function getOwner() external view returns (address)\r\n  {\r\n    return _owner;\r\n  } \r\n  \r\n  function setOffice(address office, uint fee, uint tax_, uint priceNumber_, uint32 gasLimit_) external onlyOwner\r\n  {\r\n    require(office != address(0), \"token address 0x000...\");\r\n    require(fee \u003c= 10, \"fee max 10%\");\r\n\r\n      _office = office;\r\n      _fee = fee;\r\n      _tax = tax_;\r\n      \r\n      gasLimit = gasLimit_;\r\n      priceNumber = priceNumber_;\r\n  }\r\n  /// @dev get address office value fee\r\n  /// @return office fee\r\n  function getOffice() external view returns(address office, uint fee)\r\n  {\r\n      return(_office, _fee);\r\n  }\r\n   function stringToUint(string memory s) public pure returns (uint) {\r\n        bytes memory b = bytes(s);\r\n        uint result = 0;\r\n        for (uint256 i = 0; i \u003c b.length; i++) {\r\n            uint256 c = uint256(uint8(b[i]));\r\n            if (c \u003e= 48 \u0026\u0026 c \u003c= 57) {\r\n                result = result * 10 + (c - 48);\r\n            }\r\n        }\r\n        return result;\r\n    } \r\n/// @notice creation init raffle contract \r\n    /// @param raffleName_ title \r\n    /// @param quant_ quant \r\n    /// @param startTime_ start date\r\n    /// @param finishTime_ finish date\r\n    /// @param price_ price number\r\n    /// @param token_ address token\r\n     \r\n  function createRaffle( \r\n        string memory raffleName_, \r\n        uint quant_, \r\n        uint startTime_, \r\n        uint finishTime_, \r\n        uint256 price_, \r\n        address token_,\r\n        string[] memory metadata_,\r\n        uint softcap_) public payable \r\n  {\r\n        uint raffleType = stringToUint(metadata_[3]);\r\n        //0.0002 BNB\r\n        if(isExcludedFromFees[msg.sender] == false)\r\n        {\r\n          if(raffleType == 2)\r\n          {\r\n            require(msg.value == _tax, \"not value deposit\");\r\n          }\r\n          else \r\n          {\r\n            uint256 total = quant_ * priceNumber;\r\n            require(msg.value == total, \"not value deposit\");\r\n          }\r\n        }\r\n        \r\n        //generate the raffle id\r\n        raffleId++;\r\n\r\n        //new index\r\n        eventCount++;\r\n\r\n        //create the raffle contract with id and index\r\n        Raffle _value = new Raffle(address(this));\r\n\r\n        //links the contract address with the contract\r\n        raffleItems[address(_value)] = _value;\r\n\r\n        //start the raffle\r\n        raffleItems[address(_value)].init(\r\n          raffleId, \r\n          eventCount, \r\n          raffleName_, \r\n          quant_, \r\n          startTime_, \r\n          finishTime_, \r\n          price_, \r\n          token_,\r\n          msg.sender,\r\n          metadata_,\r\n          softcap_);\r\n\r\n       \r\n    }\r\n     \r\n    function update(\r\n        address raffle,\r\n        string memory raffleName_, \r\n        uint startTime_, \r\n        uint finishTime_, \r\n        string[] memory metadata_) public  \r\n    {\r\n\r\n        Raffle _value = raffleItems[raffle];\r\n        require(_value.owner() == msg.sender, \"not owner\");\r\n\r\n        _value.update(raffleName_, \r\n                      startTime_, \r\n                      finishTime_, \r\n                      metadata_);\r\n\r\n        //links the contract address with the contract\r\n        \r\n\r\n    } \r\n   /// @notice close the contract\r\n   /// @dev closes the raffle contract that has no purchased numbers\r\n   /// @param raffle address raffle\r\n\r\n   function setClose(address raffle) external \r\n   {\r\n      \r\n      require(raffleItems[raffle].tokenCount() == 0, \"game in progress\");\r\n      require(raffleItems[raffle].owner() == msg.sender, \"not onwer\");\r\n\r\n\r\n      //updates active raffles\r\n      eventCount--;\r\n\r\n      //closes the contract in the raffle\r\n      raffleItems[raffle].setClose();\r\n\r\n      //delete contract from array\r\n      delete raffleItems[raffle];\r\n   }\r\n    \r\n   // \r\n   /// @notice Assumes the subscription is funded sufficiently.\r\n   /// @dev run the draw of the number in the raffle\r\n   /// @param raffle address raffle\r\n   function finalize(address raffle, uint tokenCount) external \r\n   {\r\n      require(randomNumbers[raffle] == false, \"wait random\");\r\n      require(raffleItems[raffle].owner() == msg.sender, \"not onwer\");\r\n\r\n      if(raffleItems[raffle].raffleType() == 2)\r\n      {\r\n          finalizeGiveway(raffleItems[raffle], tokenCount);  \r\n      }\r\n      else \r\n      {\r\n          raffleItems[raffle].setFinishTime(block.timestamp.sub(2000));\r\n          validateRandomWords(raffle);\r\n      }\r\n\r\n      //emit EventFinalize(raffle, raffleItems[raffle].id(), block.timestamp.sub(1000));\r\n   }\r\n\r\n   function finalizeGiveway(Raffle raffle, uint tokenCount) private \r\n   {\r\n     if(raffle.state()==1)\r\n     {\r\n            uint price = raffle.price();\r\n            uint fee =  price.div(100).mul(_fee);  \r\n            address token = raffle.token();\r\n\r\n            require(IERC20(token).transferFrom(msg.sender, _office, fee), \"error transferFrom\");\r\n            require(IERC20(token).transferFrom(msg.sender, address(raffle), price.sub(fee)), \"error transferFrom\");\r\n\r\n            raffle.setTokenCount(tokenCount);\r\n            requestRandomWords(address(raffle));\r\n     }\r\n   }\r\n   function validateRandomWords(address raffle) private\r\n   {\r\n        //validate random\r\n        bool validate = raffleItems[raffle].validateRequest();\r\n      \r\n        if(validate)\r\n        {\r\n           requestRandomWords(raffle);\r\n        }\r\n  }\r\n\r\n  function requestRandomWords(address raffle) private\r\n  {\r\n        uint256 requestId = COORDINATOR.requestRandomWords(\r\n                _keyhash,\r\n                _subscriptionid,\r\n                REQUEST_CONFIRMATIONS,\r\n                gasLimit,\r\n                NUM_WORDS\r\n                );\r\n\r\n        requests[requestId] = raffle;\r\n        randomNumbers[raffle] = true;\r\n  }\r\n\r\n  function addBatchUser(address raffle, string memory tokenAddress, uint ref) external \r\n  {\r\n      require(raffleItems[raffle].owner() == msg.sender, \"not onwer\");\r\n      emit EventLog(raffle, ref, tokenAddress, block.timestamp);\r\n  }\r\n   /// @dev receive number drawn after executing the requestRandomWords function\r\n   /// @param requestId requested number drawn\r\n   /// @param randomWords array number drawn\r\n   \r\n  function fulfillRandomWords(\r\n    uint256 requestId,\r\n    uint256[] memory randomWords\r\n  ) internal override {\r\n\r\n      emit EventLog(address(0), 0, \"resultRandom\", block.timestamp);\r\n      resultRandom(requestId, randomWords[0]);\r\n  }\r\n  function setWinnerGiveway(address raffle, address wallet) external onlyOwner\r\n  {\r\n      if(raffleItems[raffle].raffleType() == 2 \u0026\u0026 results[raffle] != 0)\r\n      {\r\n          raffleItems[raffle].setWinnerGiveway(wallet, results[raffle]);\r\n      }\r\n  }\r\n  function resultRandom(uint256 requestId, uint256 randomWord) private\r\n  {\r\n\r\n    //address contract\r\n    address raffle = requests[requestId];\r\n    //\r\n    uint tokenCount = raffleItems[raffle].tokenCount();\r\n    //\r\n    uint result = (randomWord % tokenCount) + 1;\r\n    //\r\n    results[raffle] = result;\r\n\r\n    //add raffle total\r\n    raffleTotal++;\r\n\r\n    //delete actives\r\n    eventCount--;\r\n\r\n     //emit event\r\n    emit EventRandomResult(\r\n      raffle, \r\n      raffleItems[raffle].id(), \r\n      tokenCount, \r\n      requestId, \r\n      randomWord, \r\n      result, \r\n      block.timestamp); \r\n\r\n    if(raffleItems[raffle].raffleType() \u003c 2)\r\n    {\r\n       //updates the random number in the raffle contract\r\n       raffleItems[raffle].setResult(result);\r\n\r\n       //delete array address \r\n       delete raffleItems[raffle];\r\n    }\r\n     \r\n  }\r\n  \r\n  function addCryptoFlipEventLog(string memory eventName, uint id) external \r\n  {\r\n    //checks if the operator of the raffle contract is the Contract Manager\r\n    require(ICryptoFlip(msg.sender).getOperador() == _owner, \"access denied\");  \r\n\r\n    //emit \r\n    emit EventLog(msg.sender, id, eventName, block.timestamp);\r\n\r\n  }\r\n\r\n  /// @notice add log\r\n  /// @dev receives the parameters of the raffle contract\r\n  /// @param eventName string\r\n  function addEventLog(string memory eventName) external \r\n  {\r\n    //checks if the operator of the raffle contract is the Contract Manager\r\n    require(raffleItems[msg.sender].getOperador() == _owner, \"access denied\");  \r\n\r\n    //emit \r\n    emit EventLog(msg.sender, raffleItems[msg.sender].id(), eventName, block.timestamp);\r\n    //\r\n\r\n    if(keccak256(abi.encodePacked(eventName)) == keccak256(abi.encodePacked(\"EventRafflePurchased\")))\r\n    {\r\n       validateRandomWords(msg.sender);\r\n    }\r\n\r\n  }\r\n  /// @dev checks if the contract is activated in the Manager\r\n  /// @param raffle address\r\n  /// @return address contract\r\n  function getRaffleAddress(address raffle) external view returns (address)\r\n  {\r\n    return address(raffleItems[raffle]);\r\n  }\r\n\r\n  function withdrawFee() public payable onlyOwner \r\n  {\r\n      //IBEP20(token).transfer(msg.sender, IBEP20(token).balanceOf(address(this)));\r\n      payable(msg.sender).transfer(address(this).balance);\r\n  }\r\n\r\n  function getBalance() public view returns (uint) \r\n  {\r\n    return address(this).balance;\r\n  }\r\n}"},"Raffle.sol":{"content":"\r\n\r\n// SPDX-License-Identifier: MIT\r\n \r\n \r\n\r\npragma solidity ^0.8.7;\r\n\r\ncontract ContractGuard {\r\n    mapping(uint256 =\u003e mapping(address =\u003e bool)) private _status;\r\n\r\n    function checkSameOriginReentranted() internal view returns (bool) {\r\n        return _status[block.number][tx.origin];\r\n    }\r\n\r\n    function checkSameSenderReentranted() internal view returns (bool) {\r\n        return _status[block.number][msg.sender];\r\n    }\r\n\r\n    modifier onlyOneBlock() {\r\n        require(!checkSameOriginReentranted(), \"ContractGuard: one block, one function\");\r\n        require(!checkSameSenderReentranted(), \"ContractGuard: one block, one function\");\r\n\r\n        _;\r\n\r\n        _status[block.number][tx.origin] = true;\r\n        _status[block.number][msg.sender] = true;\r\n    }\r\n}\r\n\r\n \r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler\u0027s defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler\u0027s built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003c= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    \r\n}\r\n\r\n// File: interfaces/IERC20.sol\r\npragma solidity ^0.8.7;\r\n\r\ninterface IERC20 \r\n{\r\n    \r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function deposit() external payable;\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n     \r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n    \r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI\u0027s implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n     \r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn\u0027t rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length \u003e 0;\r\n    }\r\n\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\npragma solidity ^0.8.7;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    \r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``\u0027s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n     \r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``\u0027s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\r\npragma solidity ^0.8.7;\r\n\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 =\u003e address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address =\u003e uint256) private _balances;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: invalid token ID\");\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() external view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() external view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n/**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    /// @solidity memory-safe-assembly\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length \u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n\r\n        _afterTokenTransfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if the `tokenId` has not been minted yet.\r\n     */\r\n    function _requireMinted(uint256 tokenId) internal view virtual {\r\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\r\n    }\r\n\r\n   \r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``\u0027s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``\u0027s `tokenId` will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n\r\n/**\r\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\r\n * enumerability of all the token ids in the contract as well as all token ids owned by each\r\n * account.\r\n */\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 =\u003e uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 =\u003e uint256) private _allTokensIndex;\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\r\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n        require(index \u003c ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenByIndex}.\r\n     */\r\n    function tokenByIndex(uint256 index) external view virtual override returns (uint256) {\r\n        require(index \u003c ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``\u0027s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``\u0027s `tokenId` will be burned.\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (from == address(0)) {\r\n            _addTokenToAllTokensEnumeration(tokenId);\r\n        } else if (from != to) {\r\n            _removeTokenFromOwnerEnumeration(from, tokenId);\r\n        }\r\n        if (to == address(0)) {\r\n            _removeTokenFromAllTokensEnumeration(tokenId);\r\n        } else if (to != from) {\r\n            _addTokenToOwnerEnumeration(to, tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension\u0027s ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        uint256 length = ERC721.balanceOf(to);\r\n        _ownedTokens[to][length] = tokenId;\r\n        _ownedTokensIndex[tokenId] = length;\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension\u0027s token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension\u0027s ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from\u0027s tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _ownedTokensIndex[tokenId];\r\n        delete _ownedTokens[from][lastTokenIndex];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension\u0027s token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an \u0027if\u0027 statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _allTokensIndex[tokenId];\r\n        _allTokens.pop();\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n/**\r\n * @dev ERC721 token with storage based token URI management.\r\n */\r\nabstract contract ERC721URIStorage is ERC721 {\r\n    using Strings for uint256;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 =\u003e string) private _tokenURIs;\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = _baseURI();\r\n\r\n        // If there is no base URI, return the token URI.\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\r\n        if (bytes(_tokenURI).length \u003e 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n\r\n        return super.tokenURI(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\r\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\r\n        _tokenURIs[tokenId] = _tokenURI;\r\n    }\r\n \r\n}\r\n\r\n// File: Raffle.sol\r\n\r\n\r\npragma solidity ^0.8.7;\r\n  \r\ninterface IManager \r\n{\r\n    /// @notice addEventLog add Event Log\r\n    /// @dev Function adds an Event to the Contract Manager\r\n    /// @param eventName the name of the Add, Closed, Buy event.\r\n    function addEventLog(string memory eventName) external;\r\n\r\n    /// @notice getOwner owner\u0027s address\r\n    /// @dev Function is return the owner\u0027s wallet\r\n    /// @return address owner the contract\r\n    function getOwner() external view returns (address);\r\n\r\n    /// @notice getPrice token price\r\n    /// @dev Function returns the token price\r\n    /// @param symbol token symbol\r\n    /// @param _decimals decimal places\r\n    /// @return price tokensymbol\r\n    function getPrice(string memory symbol, uint8 _decimals) external view returns (uint);\r\n\r\n    /// @dev get address office value fee\r\n    /// @return office fee\r\n    function getOffice()  external returns(address office, uint fee);\r\n    \r\n}\r\n\r\ncontract Raffle is ERC721Enumerable, \r\n    ERC721URIStorage, \r\n    ContractGuard, \r\n    ReentrancyGuard\r\n{\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    //Address of the Contract Manager that creates the raffles\r\n    address private _operador;\r\n    address public owner;\r\n\r\n    string[] public metadata;\r\n    \r\n    //Number of NFT mint with index \r\n    uint public tokenCount = 0;\r\n\r\n    //Raffle status\r\n    uint public state = 0;\r\n\r\n    //chosen index that corresponds to the token of the chosen number\r\n    uint public winnerId;\r\n\r\n    //Winner\u0027s wallet\r\n\taddress public winner;\r\n\r\n    //Set the status of the open or closed raffle\r\n    bool public closed = false;\r\n\r\n    //Check if the winner has already claimed their reward\r\n    bool public claimed = false;\r\n\r\n    //Check if the winner has already claimed their reward\r\n    bool public withdrawn = false;\r\n\r\n    //Raffle ID generated by the Manager contract\r\n    uint public id; \r\n\r\n    //Raffle index in the list\r\n    uint public index; \r\n\r\n    //Raffle name\r\n    string public raffleName;\r\n\r\n    //Start date\r\n    uint public startTime; \r\n\r\n    //End date\r\n    uint public finishTime; \r\n\r\n    //Address of the token that is in the raffle\r\n    address public token;\r\n\r\n    //Amount of Numbers available\r\n    uint public quant;\r\n\r\n    //Number price\r\n    uint256 public price; \r\n\r\n    //Token Symbol\r\n    string public tokenSymbol;\r\n    //\r\n    uint public raffleType;\r\n\r\n    //\r\n    uint public softcap;\r\n    \r\n    //Number price\r\n    uint256 public claimAmount; \r\n    \r\n    //Number price\r\n    uint256 public withdrawAmount; \r\n\r\n    //Interface that executes the Manager\u0027s methods\r\n    IManager private _manager;\r\n     \r\n     /**\r\n     * @dev Emitted which creates and adds the contract \r\n     */\r\n    event EventRaffleAdd(\r\n            string name,\r\n            uint startTime, \r\n            uint finishTime, \r\n            address token,\r\n            uint quant,\r\n            uint256 price, \r\n            string tokenSymbol,\r\n            uint raffleid,\r\n            address owner,\r\n            string[] metadata,\r\n            uint softcap);\r\n    \r\n    event EventRaffleUpdate(\r\n            string name,\r\n            uint startTime, \r\n            uint finishTime, \r\n            uint raffleid,\r\n            string[] metadata);\r\n    /**\r\n     * @dev Emitted to close the raffle if the end time has passed or if the amount is equal to tokenCount\r\n     */\r\n\r\n    event EventRaffleClosed(\r\n          address winner,\r\n          uint256 winnerId,\r\n          uint tokenCount,\r\n          uint256 balance,\r\n          uint timestamp);\r\n    /**\r\n     * @dev Emitted minting the NFT of your chosen index and numbers\r\n     */\r\n    event EventRafflePurchased(\r\n          address indexed wallet,\r\n          uint timestamp,\r\n          uint[] ids,\r\n          uint tokenCount,\r\n          uint256 balance\r\n    );\r\n    \r\n\r\n    /**\r\n     * @dev Emitted change state\r\n     */\r\n    event EventState(uint state);\r\n\r\n    //Item that defines the properties of the minted NFT itemId is the number chosen in the raffle seller is the buyer\r\n    struct Item \r\n    {\r\n        uint itemId;\r\n        uint timestamp;\r\n        address seller;\r\n    }\r\n    //Mapping NFT guard number chosen itemId with index\r\n    mapping(uint =\u003e bool) public indexTokens;\r\n\r\n    //Mapping the NFT brothers-in-law\r\n    mapping(uint =\u003e Item) public items;\r\n    \r\n    //Run only Contract Manager\r\n    modifier onlyManager() {\r\n        require(address(_manager) == msg.sender, \"manager: caller is not the operator\");\r\n        _;\r\n    }\r\n\r\n\r\n    /// @notice Deploys contract requires creator to be contract Manager\r\n    /// @dev sets `manager` which is the contract that creates the raffles\r\n    /// @param manager_ contract address Manager\r\n   \r\n    constructor(address manager_) ERC721(\"GoldNumber\", \"luckynumber\")\r\n    {\r\n        _manager = IManager(manager_);\r\n        _operador = _manager.getOwner();\r\n        \r\n        \r\n    }\r\n    function stringToUint(string memory s) public pure returns (uint) {\r\n        bytes memory b = bytes(s);\r\n        uint result = 0;\r\n        for (uint256 i = 0; i \u003c b.length; i++) {\r\n            uint256 c = uint256(uint8(b[i]));\r\n            if (c \u003e= 48 \u0026\u0026 c \u003c= 57) {\r\n                result = result * 10 + (c - 48);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /// @notice return operator\r\n    /// @return contract owner address Manager\r\n\r\n    function getOperador() external view returns (address)\r\n    {\r\n        return _operador;\r\n    } \r\n\r\n    /// @notice change the status of the raffle\r\n    /// @dev set 0 opened 1 closed\r\n    /// @param value state\r\n    function setState(uint value) external onlyManager\r\n    {\r\n        state = value;\r\n        emit EventState(state);\r\n    }\r\n\r\n    function setWinnerGiveway(address wallet, uint256 result) external onlyManager\r\n    {\r\n        items[result] = Item(result, block.timestamp, payable(wallet));\r\n\r\n        _safeMint(wallet, result);\r\n        _setResult(result);\r\n    }\r\n    \r\n    function withdraw() external\r\n    {\r\n        require(owner == msg.sender, \"only owner\");\r\n        require(withdrawn==false, \"withdwawn\");\r\n        \r\n        IERC20(token).transfer(owner, withdrawAmount);\r\n        withdrawn = true;\r\n    }\r\n    \r\n    function setResult(uint256 result) external onlyManager\r\n    {   \r\n        _setResult(result);\r\n    }\r\n    \r\n    /// @dev result generated by the VRF of the contract Manager \r\n    /// @param result random number\r\n    function _setResult(uint256 result) private\r\n    {\r\n        //index of the number drawn\r\n        Item storage item = items[result];\r\n\r\n        ///update champion\r\n        winner = item.seller;\r\n\r\n        ///updates chosen number of the index drawn\r\n        winnerId = item.itemId;\r\n        \r\n        //closed raffle\r\n        closed = true;\r\n\r\n        //close raffle\r\n        closeRaffle();\r\n\r\n        uint balance = IERC20(token).balanceOf(address(this));\r\n        withdrawAmount = balance.div(100).mul(softcap);\r\n        claimAmount = balance.sub(withdrawAmount);\r\n    }\r\n    /// @notice closes contract\r\n    /// @dev closes contract after the number draw\r\n\r\n    function closeRaffle() internal \r\n    {\r\n        /**\r\n        * @dev Emitted when `winner, winnerId, tokenCount, balance, date\r\n        */\r\n\r\n        emit EventRaffleClosed(\r\n                winner,\r\n                winnerId,\r\n                tokenCount,\r\n                getBalance(),\r\n                block.timestamp);\r\n\r\n        /**\r\n        * @dev Emitted closing the raffle in the Manager contract\r\n        */\r\n        _manager.addEventLog(\"EventRaffleClosed\");\r\n    }\r\n    /// @notice starts the raffle from the Manager contract\r\n    /// @dev this method is performed by the Manager contract\r\n    /// @param id_ raffle contract\r\n    /// @param index_ raffle contract\r\n    /// @param raffleName_ raffle title\r\n    /// @param quant_ total numbers\r\n    /// @param startTime_ date start\r\n    /// @param finishTime_ date finish\r\n    /// @param price_ price number\r\n    /// @param token_ address token\r\n    function init(\r\n        uint id_, \r\n        uint index_,\r\n        string memory raffleName_, \r\n        uint quant_, \r\n        uint startTime_, \r\n        uint finishTime_, \r\n        uint256 price_, \r\n        address token_,\r\n        address owner_,\r\n        string[] memory metadata_,\r\n        uint softcap_) external onlyManager\r\n    {\r\n       \r\n       require(state==0, \"raffle created\");\r\n       require(token_ != address(0), \"token address 0x000\");   \r\n\r\n       indexTokens[0] = true;\r\n       raffleType = stringToUint(metadata_[3]);\r\n\r\n       /// @dev fill in the parameters\r\n       id = id_;\r\n       index = index_;\r\n       softcap = raffleType == 2 ? 0 : softcap_;\r\n       raffleName = raffleName_;\r\n       startTime = startTime_;\r\n       finishTime = finishTime_; \r\n       token = token_;\r\n       quant = quant_;\r\n       price = price_;\r\n       tokenSymbol = IERC20(token).symbol();\r\n       state = 1;\r\n       metadata = metadata_;\r\n       owner = owner_;\r\n       \r\n       \r\n       /**\r\n        * @dev Emitted add raffle\r\n        */\r\n\r\n       emit EventRaffleAdd(\r\n            raffleName,\r\n            startTime, \r\n            finishTime, \r\n            token,\r\n            quant,\r\n            price, \r\n            tokenSymbol,\r\n            id,\r\n            owner,\r\n            metadata,\r\n            softcap);\r\n\r\n        /**\r\n        * @dev Emitted add raffle in manager\r\n        */\r\n        _manager.addEventLog(\"EventRaffleAdd\");\r\n\r\n    }\r\n   function update(\r\n        string memory raffleName_, \r\n        uint startTime_, \r\n        uint finishTime_, \r\n        string[] memory metadata_) external onlyManager\r\n    {\r\n        \r\n       require(finishTime_ \u003e block.timestamp, \"date range\");\r\n       \r\n       raffleName = raffleName_;\r\n       startTime = startTime_;\r\n       finishTime = finishTime_; \r\n       metadata = metadata_;\r\n      \r\n       \r\n       /**\r\n        * @dev Emitted add raffle\r\n        */\r\n\r\n       emit EventRaffleUpdate(\r\n            raffleName,\r\n            startTime, \r\n            finishTime, \r\n            id,\r\n            metadata);\r\n\r\n        /**\r\n        * @dev Emitted add raffle in manager\r\n        */\r\n        _manager.addEventLog(\"EventRaffleUpdate\");\r\n\r\n    }\r\n    function transferOwnership(address newOwner) public\r\n    {\r\n        require(msg.sender == owner, \"not owner\");\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        owner = newOwner;\r\n    }\r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        override(ERC721, ERC721URIStorage)\r\n        returns (string memory)\r\n    {\r\n        return super.tokenURI(tokenId);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(ERC721, ERC721Enumerable)\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n     \r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\r\n        internal\r\n        override(ERC721, ERC721Enumerable)\r\n    {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    \r\n    /// @notice balance of the amount deposited in the contract for the purchase of numbers\r\n\r\n    function getBalance() public view returns(uint256)\r\n    {\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n    /// @dev function used to validate the randomization of the number drawn\r\n    /// @return true or false\r\n    function validateRequest() external view returns(bool)\r\n    {\r\n        /**\r\n        * @dev verifica a data atual  maior data de termino. Verifica se o total de numeros comprados e igual a quantidade. E o estado. \r\n        */\r\n        if(block.timestamp \u003e= finishTime || quant == tokenCount \u0026\u0026 state == 1 \u0026\u0026 tokenCount \u003e 1)\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /// @notice claim the reward after the draw\r\n    /// @dev checks if the champion is the wallet is the winner\r\n    function claimReward() external onlyOneBlock nonReentrant\r\n    {\r\n        /**\r\n        * @dev check if you are the champion. check if you have already claimed the rewards.\r\n        */\r\n        require(msg.sender == winner, \"not winner\");\r\n        require(claimed == false, \"claimed\");\r\n        require(closed, \"not closed\");\r\n         /**\r\n        * @dev checks if it is the native token or IERC20 and transfers the value to the wallet\r\n        */\r\n        claimed = true; \r\n        require(IERC20(token).transfer(winner, claimAmount), \"error transfer\"); \r\n    }\r\n    function setTokenCount(uint tokenCount_) external onlyManager\r\n    {\r\n        tokenCount = tokenCount_;\r\n    }\r\n    function setFinishTime(uint value) external onlyManager\r\n    {\r\n        finishTime = value;\r\n    }\r\n    /// @notice close raffle\r\n    /// @dev used to close the raffle that no number has been purchased\r\n    function setClose() external onlyManager\r\n    {\r\n         if(tokenCount == 0)\r\n         {\r\n            closed = true;\r\n            claimed = true; \r\n            closeRaffle();\r\n         }\r\n    }\r\n    /// @notice purchased numbers\r\n    /// @dev return purchased numbers\r\n    /// @return array purchased numbers\r\n    function getTokens() external view returns(uint256[] memory) \r\n    {\r\n        uint256[] memory tokensId = new uint256[](tokenCount);\r\n        for(uint256 i = 0; i \u003c tokenCount; i++)\r\n        {   \r\n             Item storage item = items[i+1];\r\n             tokensId[i] = item.itemId;\r\n        }\r\n        return tokensId;\r\n    }\r\n    /// @notice numbers purchased from wallet\r\n    /// @param addr wallet address\r\n    /// @return array numbers purchased\r\n    function tokensOfOwner(address addr) external view returns(uint256[] memory) \r\n    {\r\n        uint256 balance = balanceOf(addr);\r\n        uint256[] memory tokensId = new uint256[](balance);\r\n        for(uint256 i = 0; i \u003c balance; i++)\r\n        {\r\n            uint _index = tokenOfOwnerByIndex(addr, i);\r\n            Item storage item = items[_index];\r\n            tokensId[i] = item.itemId;\r\n        }\r\n        return tokensId;\r\n    }\r\n   \r\n    /// @notice mint nft\r\n    /// @dev  mint NFTs with the numbers purchased from the raffle\r\n    /// @param ids numbers purchased\r\n    function mint(uint[] memory ids) external onlyOneBlock nonReentrant\r\n    {\r\n       \r\n         \r\n        /**\r\n        * @dev check if it\u0027s closed\r\n        */\r\n        require(closed == false, \"closed\");\r\n        /**\r\n        * @dev checks if the date is greater than the end date\r\n        */\r\n        require(block.timestamp \u003c finishTime, \"closed\");\r\n        /**\r\n        * @dev checks if the address is a contract\r\n        */\r\n        require(msg.sender.isContract() == false, \"Not contract\");\r\n        /**\r\n        * @dev checks state\r\n        */\r\n        require(state == 1, \"not opened\");\r\n\r\n        /**\r\n        * @dev checks max 5 ids\r\n        */\r\n        require(ids.length \u003c 6, \"5 max numbers\");\r\n\r\n        uint i = 0;\r\n        uint j = 0;\r\n\r\n        uint[] memory numbers = new uint[](ids.length);\r\n  \r\n        while (i \u003c ids.length) \r\n        { \r\n            uint itemId = ids[i];\r\n            require(itemId \u003c= quant, \"id greater than quantity\");\r\n\r\n            if(indexTokens[itemId]==false)\r\n            {\r\n                numbers[j] = itemId;\r\n                indexTokens[itemId] = true;\r\n                tokenCount++;\r\n               \r\n                j++;\r\n                _mint(itemId);\r\n            }\r\n            i++;\r\n         \r\n        }        \r\n        /**\r\n        * @dev Emitted when `wallet, date, tokensId, tokenCount, balance\r\n        */\r\n        emit EventRafflePurchased(\r\n            msg.sender,\r\n            block.timestamp,\r\n            numbers,\r\n            tokenCount,\r\n            getBalance());\r\n        \r\n        /**\r\n        * @dev Emitted when `purchased Manager\r\n        */\r\n        _manager.addEventLog(\"EventRafflePurchased\");\r\n\r\n        uint256 total = price.mul(j);\r\n        tokenTransfer(total);\r\n    }\r\n    \r\n    \r\n    /// @dev tokenTransfer the value of the NFT of the numbers purchased in the contract\r\n    /// @param total total number purchased * price\r\n    function tokenTransfer(uint256 total) private\r\n    {\r\n       (address _office, uint _fee) = _manager.getOffice();\r\n    \r\n       uint fee =  total.div(100).mul(_fee);       /**\r\n       * @dev transfers the fee amount to the office contract\r\n       */\r\n       require(IERC20(token).transferFrom(msg.sender, _office, fee), \"error transferFrom\");\r\n       require(IERC20(token).transferFrom(msg.sender, address(this), total.sub(fee)), \"error transferFrom\");\r\n      \r\n    }\r\n    /// @notice mint the nft of the purchased number\r\n    /// @param itemId purchased number\r\n \r\n    \r\n    function _mint(uint itemId) private\r\n    {\r\n        items[tokenCount] = Item(itemId, block.timestamp, payable(msg.sender));\r\n        _safeMint(msg.sender, tokenCount);\r\n    }\r\n}\r\n"},"VRFConsumerBaseV2.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\n/** ****************************************************************************\r\n * @notice Interface for contracts using VRF randomness\r\n * *****************************************************************************\r\n * @dev Cesar Maia \r\n *\r\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\r\n * @dev to Vera the verifier in such a way that Vera can be sure he\u0027s not\r\n * @dev making his output up to suit himself. Reggie provides Vera a public key\r\n * @dev to which he knows the secret key. Each time Vera provides a seed to\r\n * @dev Reggie, he gives back a value which is computed completely\r\n * @dev deterministically from the seed and the secret key.\r\n *\r\n * @dev Reggie provides a proof by which Vera can verify that the output was\r\n * @dev correctly computed once Reggie tells it to her, but without that proof,\r\n * @dev the output is indistinguishable to her from a uniform random sample\r\n * @dev from the output space.\r\n *\r\n * @dev The purpose of this contract is to make it easy for unrelated contracts\r\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\r\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\r\n * @dev 1. The fulfillment came from the VRFCoordinator\r\n * @dev 2. The consumer contract implements fulfillRandomWords.\r\n * *****************************************************************************\r\n * @dev USAGE\r\n *\r\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\r\n * @dev initialize VRFConsumerBase\u0027s attributes in their constructor as\r\n * @dev shown:\r\n *\r\n * @dev   contract VRFConsumer {\r\n * @dev     constructor(\u003cother arguments\u003e, address _vrfCoordinator, address _link)\r\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\r\n * @dev         \u003cinitialization with other arguments goes here\u003e\r\n * @dev       }\r\n * @dev   }\r\n *\r\n * @dev The oracle will have given you an ID for the VRF keypair they have\r\n * @dev committed to (let\u0027s call it keyHash). Create subscription, fund it\r\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\r\n * @dev subscription management functions).\r\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\r\n * @dev callbackGasLimit, numWords),\r\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\r\n *\r\n * @dev Once the VRFCoordinator has received and validated the oracle\u0027s response\r\n * @dev to your request, it will call your contract\u0027s fulfillRandomWords method.\r\n *\r\n * @dev The randomness argument to fulfillRandomWords is a set of random words\r\n * @dev generated from your requestId and the blockHash of the request.\r\n *\r\n * @dev If your contract could have concurrent requests open, you can use the\r\n * @dev requestId returned from requestRandomWords to track which response is associated\r\n * @dev with which randomness request.\r\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\r\n * @dev if your contract could have multiple requests in flight simultaneously.\r\n *\r\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\r\n * @dev differ.\r\n *\r\n * *****************************************************************************\r\n * @dev SECURITY CONSIDERATIONS\r\n *\r\n * @dev A method with the ability to call your fulfillRandomness method directly\r\n * @dev could spoof a VRF response with any random value, so it\u0027s critical that\r\n * @dev it cannot be directly called by anything other than this base contract\r\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\r\n *\r\n * @dev For your users to trust that your contract\u0027s random behavior is free\r\n * @dev from malicious interference, it\u0027s best if you can write it so that all\r\n * @dev behaviors implied by a VRF response are executed *during* your\r\n * @dev fulfillRandomness method. If your contract must store the response (or\r\n * @dev anything derived from it) and use it later, you must ensure that any\r\n * @dev user-significant behavior which depends on that stored value cannot be\r\n * @dev manipulated by a subsequent VRF request.\r\n *\r\n * @dev Similarly, both miners and the VRF oracle itself have some influence\r\n * @dev over the order in which VRF responses appear on the blockchain, so if\r\n * @dev your contract could have multiple VRF requests in flight simultaneously,\r\n * @dev you must ensure that the order in which the VRF responses arrive cannot\r\n * @dev be used to manipulate your contract\u0027s user-significant behavior.\r\n *\r\n * @dev Since the block hash of the block which contains the requestRandomness\r\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\r\n * @dev miner could, in principle, fork the blockchain to evict the block\r\n * @dev containing the request, forcing the request to be included in a\r\n * @dev different block with a different hash, and therefore a different input\r\n * @dev to the VRF. However, such an attack would incur a substantial economic\r\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\r\n * @dev until it calls responds to a request. It is for this reason that\r\n * @dev that you can signal to an oracle you\u0027d like them to wait longer before\r\n * @dev responding to the request (however this is not enforced in the contract\r\n * @dev and so remains effective only in the case of unmodified oracle software).\r\n */\r\nabstract contract VRFConsumerBaseV2 {\r\n  error OnlyCoordinatorCanFulfill(address have, address want);\r\n  address public vrfCoordinator;\r\n\r\n  /**\r\n   * @param _vrfCoordinator address of VRFCoordinator contract\r\n   */\r\n  constructor(address _vrfCoordinator) {\r\n    vrfCoordinator = _vrfCoordinator;\r\n  }\r\n\r\n  /**\r\n   * @notice fulfillRandomness handles the VRF response. Your contract must\r\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\r\n   * @notice principles to keep in mind when implementing your fulfillRandomness\r\n   * @notice method.\r\n   *\r\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\r\n   * @dev signature, and will call it once it has verified the proof\r\n   * @dev associated with the randomness. (It is triggered via a call to\r\n   * @dev rawFulfillRandomness, below.)\r\n   *\r\n   * @param requestId The Id initially returned by requestRandomness\r\n   * @param randomWords the VRF output expanded to the requested number of words\r\n   */\r\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\r\n\r\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\r\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\r\n  // the origin of the call\r\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\r\n    if (msg.sender != vrfCoordinator) {\r\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\r\n    }\r\n    fulfillRandomWords(requestId, randomWords);\r\n  }\r\n}\r\n"},"VRFCoordinatorV2Interface.sol":{"content":"\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\ninterface VRFCoordinatorV2Interface \r\n{\r\n  \r\n  /**\r\n   * @notice Request a set of random words.\r\n   * @param keyHash - Corresponds to a particular oracle job which uses\r\n   * that key for generating the VRF proof. Different keyHash\u0027s have different gas price\r\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\r\n   * @param subId  - The ID of the VRF subscription. Must be funded\r\n   * with the minimum subscription balance required for the selected keyHash.\r\n   * @param minimumRequestConfirmations - How many blocks you\u0027d like the\r\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\r\n   * for why you may want to request more. The acceptable range is\r\n   * [minimumRequestBlockConfirmations, 200].\r\n   * @param callbackGasLimit - How much gas you\u0027d like to receive in your\r\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\r\n   * may be slightly less than this amount because of gas used calling the function\r\n   * (argument decoding etc.), so you may need to request slightly more than you expect\r\n   * to have inside fulfillRandomWords. The acceptable range is\r\n   * [0, maxGasLimit]\r\n   * @param numWords - The number of uint256 random values you\u0027d like to receive\r\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\r\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\r\n   * @return requestId - A unique identifier of the request. Can be used to match\r\n   * a request to a response in fulfillRandomWords.\r\n   */\r\n  function requestRandomWords(\r\n    bytes32 keyHash,\r\n    uint64 subId,\r\n    uint16 minimumRequestConfirmations,\r\n    uint32 callbackGasLimit,\r\n    uint32 numWords\r\n  ) external returns (uint256 requestId);\r\n\r\n  \r\n}\r\n"}}