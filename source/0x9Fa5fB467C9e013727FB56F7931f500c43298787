{"AddressStringUtil.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity \u003e=0.5.0;\n\nlibrary AddressStringUtil {\n    // converts an address to the uppercase hex string, extracting only len bytes (up to 20, multiple of 2)\n    function toAsciiString(address addr, uint256 len) internal pure returns (string memory) {\n        require(len % 2 == 0 \u0026\u0026 len \u003e 0 \u0026\u0026 len \u003c= 40, \u0027AddressStringUtil: INVALID_LEN\u0027);\n\n        bytes memory s = new bytes(len);\n        uint256 addrNum = uint256(addr);\n        for (uint256 i = 0; i \u003c len / 2; i++) {\n            // shift right and truncate all but the least significant byte to extract the byte at position 19-i\n            uint8 b = uint8(addrNum \u003e\u003e (8 * (19 - i)));\n            // first hex character is the most significant 4 bits\n            uint8 hi = b \u003e\u003e 4;\n            // second hex character is the least significant 4 bits\n            uint8 lo = b - (hi \u003c\u003c 4);\n            s[2 * i] = char(hi);\n            s[2 * i + 1] = char(lo);\n        }\n        return string(s);\n    }\n\n    // hi and lo are only 4 bits and between 0 and 16\n    // this method converts those values to the unicode/ascii code point for the hex representation\n    // uses upper case for the characters\n    function char(uint8 b) private pure returns (bytes1 c) {\n        if (b \u003c 10) {\n            return bytes1(b + 0x30);\n        } else {\n            return bytes1(b + 0x37);\n        }\n    }\n}"},"Babylonian.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity \u003e=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) \u003c\u003c (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx \u003e= 0x100000000000000000000000000000000) {\n            xx \u003e\u003e= 128;\n            r \u003c\u003c= 64;\n        }\n        if (xx \u003e= 0x10000000000000000) {\n            xx \u003e\u003e= 64;\n            r \u003c\u003c= 32;\n        }\n        if (xx \u003e= 0x100000000) {\n            xx \u003e\u003e= 32;\n            r \u003c\u003c= 16;\n        }\n        if (xx \u003e= 0x10000) {\n            xx \u003e\u003e= 16;\n            r \u003c\u003c= 8;\n        }\n        if (xx \u003e= 0x100) {\n            xx \u003e\u003e= 8;\n            r \u003c\u003c= 4;\n        }\n        if (xx \u003e= 0x10) {\n            xx \u003e\u003e= 4;\n            r \u003c\u003c= 2;\n        }\n        if (xx \u003e= 0x8) {\n            r \u003c\u003c= 1;\n        }\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r \u003c r1 ? r : r1);\n    }\n}"},"BarcelonaswapV2Library.sol":{"content":"pragma solidity \u003e=0.5.0;\n\nimport \"./IBarcelonaswapV2Pair.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary BarcelonaswapV2Library {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \u0027BarcelonaswapV2Library: IDENTICAL_ADDRESSES\u0027);\n        (token0, token1) = tokenA \u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \u0027BarcelonaswapV2Library: ZERO_ADDRESS\u0027);\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex\u0027ff\u0027,\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex\u00271d0e6ae9efa0c1b5ea283cfcb168a7a8274198f87308fc1c4becfad82b460482\u0027 // init code hash\n            ))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IBarcelonaswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA \u003e 0, \u0027BarcelonaswapV2Library: INSUFFICIENT_AMOUNT\u0027);\n        require(reserveA \u003e 0 \u0026\u0026 reserveB \u003e 0, \u0027BarcelonaswapV2Library: INSUFFICIENT_LIQUIDITY\u0027);\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn \u003e 0, \u0027BarcelonaswapV2Library: INSUFFICIENT_INPUT_AMOUNT\u0027);\n        require(reserveIn \u003e 0 \u0026\u0026 reserveOut \u003e 0, \u0027BarcelonaswapV2Library: INSUFFICIENT_LIQUIDITY\u0027);\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut \u003e 0, \u0027BarcelonaswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\u0027);\n        require(reserveIn \u003e 0 \u0026\u0026 reserveOut \u003e 0, \u0027BarcelonaswapV2Library: INSUFFICIENT_LIQUIDITY\u0027);\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length \u003e= 2, \u0027BarcelonaswapV2Library: INVALID_PATH\u0027);\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i \u003c path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length \u003e= 2, \u0027BarcelonaswapV2Library: INVALID_PATH\u0027);\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i \u003e 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}"},"BarcelonaswapV2LiquidityMathLibrary.sol":{"content":"pragma solidity \u003e=0.5.0;\n\nimport \"./SafeMath.sol\";\nimport \"./BarcelonaswapV2Library.sol\";\nimport \"./IBarcelonaswapV2Pair.sol\";\nimport \"./IBarcelonaswapV2Factory.sol\";\nimport \"./Babylonian.sol\";\nimport \"./FullMath.sol\";\n\n// library containing some math for dealing with the liquidity shares of a pair, e.g. computing their exact value\n// in terms of the underlying tokens\nlibrary BarcelonaswapV2LiquidityMathLibrary {\n    using SafeMath for uint256;\n\n    // computes the direction and magnitude of the profit-maximizing trade\n    function computeProfitMaximizingTrade(\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 reserveA,\n        uint256 reserveB\n    ) pure internal returns (bool aToB, uint256 amountIn) {\n        aToB = FullMath.mulDiv(reserveA, truePriceTokenB, reserveB) \u003c truePriceTokenA;\n\n        uint256 invariant = reserveA.mul(reserveB);\n\n        uint256 leftSide = Babylonian.sqrt(\n            FullMath.mulDiv(\n                invariant.mul(1000),\n                aToB ? truePriceTokenA : truePriceTokenB,\n                (aToB ? truePriceTokenB : truePriceTokenA).mul(997)\n            )\n        );\n        uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\n\n        if (leftSide \u003c rightSide) return (false, 0);\n\n        // compute the amount that must be sent to move the price to the profit-maximizing price\n        amountIn = leftSide.sub(rightSide);\n    }\n\n    // gets the reserves after an arbitrage moves the price to the profit-maximizing ratio given an externally observed true price\n    function getReservesAfterArbitrage(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB\n    ) view internal returns (uint256 reserveA, uint256 reserveB) {\n        // first get reserves before the swap\n        (reserveA, reserveB) = BarcelonaswapV2Library.getReserves(factory, tokenA, tokenB);\n\n        require(reserveA \u003e 0 \u0026\u0026 reserveB \u003e 0, \u0027BarcelonaV2ArbitrageLibrary: ZERO_PAIR_RESERVES\u0027);\n\n        // then compute how much to swap to arb to the true price\n        (bool aToB, uint256 amountIn) = computeProfitMaximizingTrade(truePriceTokenA, truePriceTokenB, reserveA, reserveB);\n\n        if (amountIn == 0) {\n            return (reserveA, reserveB);\n        }\n\n        // now affect the trade to the reserves\n        if (aToB) {\n            uint amountOut = BarcelonaswapV2Library.getAmountOut(amountIn, reserveA, reserveB);\n            reserveA += amountIn;\n            reserveB -= amountOut;\n        } else {\n            uint amountOut = BarcelonaswapV2Library.getAmountOut(amountIn, reserveB, reserveA);\n            reserveB += amountIn;\n            reserveA -= amountOut;\n        }\n    }\n\n    // computes liquidity value given all the parameters of the pair\n    function computeLiquidityValue(\n        uint256 reservesA,\n        uint256 reservesB,\n        uint256 totalSupply,\n        uint256 liquidityAmount,\n        bool feeOn,\n        uint kLast\n    ) internal pure returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        if (feeOn \u0026\u0026 kLast \u003e 0) {\n            uint rootK = Babylonian.sqrt(reservesA.mul(reservesB));\n            uint rootKLast = Babylonian.sqrt(kLast);\n            if (rootK \u003e rootKLast) {\n                uint numerator1 = totalSupply;\n                uint numerator2 = rootK.sub(rootKLast);\n                uint denominator = rootK.mul(5).add(rootKLast);\n                uint feeLiquidity = FullMath.mulDiv(numerator1, numerator2, denominator);\n                totalSupply = totalSupply.add(feeLiquidity);\n            }\n        }\n        return (reservesA.mul(liquidityAmount) / totalSupply, reservesB.mul(liquidityAmount) / totalSupply);\n    }\n\n    // get all current parameters from the pair and compute value of a liquidity amount\n    // **note this is subject to manipulation, e.g. sandwich attacks**. prefer passing a manipulation resistant price to\n    // #getLiquidityValueAfterArbitrageToPrice\n    function getLiquidityValue(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 liquidityAmount\n    ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n        (uint256 reservesA, uint256 reservesB) = BarcelonaswapV2Library.getReserves(factory, tokenA, tokenB);\n        IBarcelonaswapV2Pair pair = IBarcelonaswapV2Pair(BarcelonaswapV2Library.pairFor(factory, tokenA, tokenB));\n        bool feeOn = IBarcelonaswapV2Factory(factory).feeTo() != address(0);\n        uint kLast = feeOn ? pair.kLast() : 0;\n        uint totalSupply = pair.totalSupply();\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n    }\n\n    // given two tokens, tokenA and tokenB, and their \"true price\", i.e. the observed ratio of value of token A to token B,\n    // and a liquidity amount, returns the value of the liquidity in terms of tokenA and tokenB\n    function getLiquidityValueAfterArbitrageToPrice(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 liquidityAmount\n    ) internal view returns (\n        uint256 tokenAAmount,\n        uint256 tokenBAmount\n    ) {\n        bool feeOn = IBarcelonaswapV2Factory(factory).feeTo() != address(0);\n        IBarcelonaswapV2Pair pair = IBarcelonaswapV2Pair(BarcelonaswapV2Library.pairFor(factory, tokenA, tokenB));\n        uint kLast = feeOn ? pair.kLast() : 0;\n        uint totalSupply = pair.totalSupply();\n\n        // this also checks that totalSupply \u003e 0\n        require(totalSupply \u003e= liquidityAmount \u0026\u0026 liquidityAmount \u003e 0, \u0027ComputeLiquidityValue: LIQUIDITY_AMOUNT\u0027);\n\n        (uint reservesA, uint reservesB) = getReservesAfterArbitrage(factory, tokenA, tokenB, truePriceTokenA, truePriceTokenB);\n\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\n    }\n}"},"BarcelonaswapV2Migrator.sol":{"content":"pragma solidity =0.6.6;\n\nimport \"./IBarcelonaswapV2Migrator.sol\";\nimport \"./IBarcelonaswapV1Factory.sol\";\nimport \"./IBarcelonaswapV1Exchange.sol\";\nimport \"./IBarcelonaswapV2Router01.sol\";\nimport \"./IPRC20.sol\";\nimport \"./TransferHelper.sol\";\n\ncontract BarcelonaswapV2Migrator is IBarcelonaswapV2Migrator {\n    IBarcelonaswapV1Factory immutable factoryV1;\n    IBarcelonaswapV2Router01 immutable router;\n\n    constructor(address _factoryV1, address _router) public {\n        factoryV1 = IBarcelonaswapV1Factory(_factoryV1);\n        router = IBarcelonaswapV2Router01(_router);\n    }\n\n    // needs to accept ETH from any v1 exchange and the router. ideally this could be enforced, as in the router,\n    // but it\u0027s not possible because it requires a call to the v1 factory, which takes too much gas\n    receive() external payable {}\n\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline)\n        external\n        override\n    {\n        IBarcelonaswapV1Exchange exchangeV1 = IBarcelonaswapV1Exchange(factoryV1.getExchange(token));\n        uint liquidityV1 = exchangeV1.balanceOf(msg.sender);\n        require(exchangeV1.transferFrom(msg.sender, address(this), liquidityV1), \u0027TRANSFER_FROM_FAILED\u0027);\n        (uint amountETHV1, uint amountTokenV1) = exchangeV1.removeLiquidity(liquidityV1, 1, 1, uint(-1));\n        TransferHelper.safeApprove(token, address(router), amountTokenV1);\n        (uint amountTokenV2, uint amountETHV2,) = router.addLiquidityETH{value: amountETHV1}(\n            token,\n            amountTokenV1,\n            amountTokenMin,\n            amountETHMin,\n            to,\n            deadline\n        );\n        if (amountTokenV1 \u003e amountTokenV2) {\n            TransferHelper.safeApprove(token, address(router), 0); // be a good blockchain citizen, reset allowance to 0\n            TransferHelper.safeTransfer(token, msg.sender, amountTokenV1 - amountTokenV2);\n        } else if (amountETHV1 \u003e amountETHV2) {\n            // addLiquidityETH guarantees that all of amountETHV1 or amountTokenV1 will be used, hence this else is safe\n            TransferHelper.safeTransferETH(msg.sender, amountETHV1 - amountETHV2);\n        }\n    }\n}"},"BarcelonaswapV2OracleLibrary.sol":{"content":"pragma solidity \u003e=0.5.0;\n\nimport \"./IBarcelonaswapV2Pair.sol\";\nimport \"./FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary BarcelonaswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IBarcelonaswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IBarcelonaswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IBarcelonaswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}"},"BarcelonaswapV2Router.sol":{"content":"pragma solidity =0.6.6;\n\nimport \"./IBarcelonaswapV2Router02.sol\";\nimport \"./BarcelonaswapV2Library.sol\";\nimport \"./IBarcelonaswapV2Factory.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IPRC20.sol\";\nimport \"./IWETH.sol\";\nimport \"./TransferHelper.sol\";\n\ncontract BarcelonaswapV2Router is IBarcelonaswapV2Router02 {\n    using SafeMath for uint;\n\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline \u003e= block.timestamp, \u0027BarcelonaswapV2Router: EXPIRED\u0027);\n        _;\n    }\n\n    constructor(address _factory, address _WETH) public {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) {\n        // create the pair if it doesn\u0027t exist yet\n        if (IBarcelonaswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IBarcelonaswapV2Factory(factory).createPair(tokenA, tokenB);\n        }\n        (uint reserveA, uint reserveB) = BarcelonaswapV2Library.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 \u0026\u0026 reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = BarcelonaswapV2Library.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal \u003c= amountBDesired) {\n                require(amountBOptimal \u003e= amountBMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_B_AMOUNT\u0027);\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = BarcelonaswapV2Library.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal \u003c= amountADesired);\n                require(amountAOptimal \u003e= amountAMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_A_AMOUNT\u0027);\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = BarcelonaswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IBarcelonaswapV2Pair(pair).mint(to);\n    }\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = BarcelonaswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IBarcelonaswapV2Pair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value \u003e amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = BarcelonaswapV2Library.pairFor(factory, tokenA, tokenB);\n        IBarcelonaswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IBarcelonaswapV2Pair(pair).burn(to);\n        (address token0,) = BarcelonaswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA \u003e= amountAMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_A_AMOUNT\u0027);\n        require(amountB \u003e= amountBMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_B_AMOUNT\u0027);\n    }\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) {\n        address pair = BarcelonaswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IBarcelonaswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        address pair = BarcelonaswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IBarcelonaswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IPRC20(token).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) {\n        address pair = BarcelonaswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IBarcelonaswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint i; i \u003c path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = BarcelonaswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i \u003c path.length - 2 ? BarcelonaswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            IBarcelonaswapV2Pair(BarcelonaswapV2Library.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = BarcelonaswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] \u003e= amountOutMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\u0027);\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = BarcelonaswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] \u003c= amountInMax, \u0027BarcelonaswapV2Router: EXCESSIVE_INPUT_AMOUNT\u0027);\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, \u0027BarcelonaswapV2Router: INVALID_PATH\u0027);\n        amounts = BarcelonaswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] \u003e= amountOutMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\u0027);\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, \u0027BarcelonaswapV2Router: INVALID_PATH\u0027);\n        amounts = BarcelonaswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] \u003c= amountInMax, \u0027BarcelonaswapV2Router: EXCESSIVE_INPUT_AMOUNT\u0027);\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, \u0027BarcelonaswapV2Router: INVALID_PATH\u0027);\n        amounts = BarcelonaswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] \u003e= amountOutMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\u0027);\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, \u0027BarcelonaswapV2Router: INVALID_PATH\u0027);\n        amounts = BarcelonaswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] \u003c= msg.value, \u0027BarcelonaswapV2Router: EXCESSIVE_INPUT_AMOUNT\u0027);\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value \u003e amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n        for (uint i; i \u003c path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = BarcelonaswapV2Library.sortTokens(input, output);\n            IBarcelonaswapV2Pair pair = IBarcelonaswapV2Pair(BarcelonaswapV2Library.pairFor(factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IPRC20(input).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = BarcelonaswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i \u003c path.length - 2 ? BarcelonaswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IPRC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IPRC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) \u003e= amountOutMin,\n            \u0027BarcelonaswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\u0027\n        );\n    }\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    {\n        require(path[0] == WETH, \u0027BarcelonaswapV2Router: INVALID_PATH\u0027);\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(IWETH(WETH).transfer(BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IPRC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IPRC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) \u003e= amountOutMin,\n            \u0027BarcelonaswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\u0027\n        );\n    }\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    {\n        require(path[path.length - 1] == WETH, \u0027BarcelonaswapV2Router: INVALID_PATH\u0027);\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IPRC20(WETH).balanceOf(address(this));\n        require(amountOut \u003e= amountOutMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\u0027);\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n        return BarcelonaswapV2Library.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountOut)\n    {\n        return BarcelonaswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountIn)\n    {\n        return BarcelonaswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(uint amountIn, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return BarcelonaswapV2Library.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(uint amountOut, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return BarcelonaswapV2Library.getAmountsIn(factory, amountOut, path);\n    }\n}"},"BarcelonaswapV2Router01.sol":{"content":"pragma solidity =0.6.6;\n\nimport \"./BarcelonaswapV2Library.sol\";\nimport \"./IBarcelonaswapV2Router01.sol\";\nimport \"./IBarcelonaswapV2Factory.sol\";\nimport \"./IPRC20.sol\";\nimport \"./IWETH.sol\";\nimport \"./TransferHelper.sol\";\n\ncontract BarcelonaswapV2Router01 is IBarcelonaswapV2Router01 {\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline \u003e= block.timestamp, \u0027BarcelonaswapV2Router01: EXPIRED\u0027);\n        _;\n    }\n\n    constructor(address _factory, address _WETH) public {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) private returns (uint amountA, uint amountB) {\n        // create the pair if it doesn\u0027t exist yet\n        if (IBarcelonaswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IBarcelonaswapV2Factory(factory).createPair(tokenA, tokenB);\n        }\n        (uint reserveA, uint reserveB) = BarcelonaswapV2Library.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 \u0026\u0026 reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = BarcelonaswapV2Library.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal \u003c= amountBDesired) {\n                require(amountBOptimal \u003e= amountBMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_B_AMOUNT\u0027);\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = BarcelonaswapV2Library.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal \u003c= amountADesired);\n                require(amountAOptimal \u003e= amountAMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_A_AMOUNT\u0027);\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = BarcelonaswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IBarcelonaswapV2Pair(pair).mint(to);\n    }\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = BarcelonaswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IBarcelonaswapV2Pair(pair).mint(to);\n        if (msg.value \u003e amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); // refund dust eth, if any\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public override ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = BarcelonaswapV2Library.pairFor(factory, tokenA, tokenB);\n        IBarcelonaswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IBarcelonaswapV2Pair(pair).burn(to);\n        (address token0,) = BarcelonaswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA \u003e= amountAMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_A_AMOUNT\u0027);\n        require(amountB \u003e= amountBMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_B_AMOUNT\u0027);\n    }\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external override returns (uint amountA, uint amountB) {\n        address pair = BarcelonaswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IBarcelonaswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external override returns (uint amountToken, uint amountETH) {\n        address pair = BarcelonaswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IBarcelonaswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) private {\n        for (uint i; i \u003c path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = BarcelonaswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i \u003c path.length - 2 ? BarcelonaswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            IBarcelonaswapV2Pair(BarcelonaswapV2Library.pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = BarcelonaswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] \u003e= amountOutMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\u0027);\n        TransferHelper.safeTransferFrom(path[0], msg.sender, BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = BarcelonaswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] \u003c= amountInMax, \u0027BarcelonaswapV2Router: EXCESSIVE_INPUT_AMOUNT\u0027);\n        TransferHelper.safeTransferFrom(path[0], msg.sender, BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\n        _swap(amounts, path, to);\n    }\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, \u0027BarcelonaswapV2Router: INVALID_PATH\u0027);\n        amounts = BarcelonaswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] \u003e= amountOutMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\u0027);\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, \u0027BarcelonaswapV2Router: INVALID_PATH\u0027);\n        amounts = BarcelonaswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] \u003c= amountInMax, \u0027BarcelonaswapV2Router: EXCESSIVE_INPUT_AMOUNT\u0027);\n        TransferHelper.safeTransferFrom(path[0], msg.sender, BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, \u0027BarcelonaswapV2Router: INVALID_PATH\u0027);\n        amounts = BarcelonaswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] \u003e= amountOutMin, \u0027BarcelonaswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\u0027);\n        TransferHelper.safeTransferFrom(path[0], msg.sender, BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, \u0027BarcelonaswapV2Router: INVALID_PATH\u0027);\n        amounts = BarcelonaswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] \u003c= msg.value, \u0027BarcelonaswapV2Router: EXCESSIVE_INPUT_AMOUNT\u0027);\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(BarcelonaswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        if (msg.value \u003e amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); // refund dust eth, if any\n    }\n\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure override returns (uint amountB) {\n        return BarcelonaswapV2Library.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure override returns (uint amountOut) {\n        return BarcelonaswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure override returns (uint amountIn) {\n        return BarcelonaswapV2Library.getAmountOut(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(uint amountIn, address[] memory path) public view override returns (uint[] memory amounts) {\n        return BarcelonaswapV2Library.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(uint amountOut, address[] memory path) public view override returns (uint[] memory amounts) {\n        return BarcelonaswapV2Library.getAmountsIn(factory, amountOut, path);\n    }\n}"},"BitMath.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity \u003e=0.5.0;\n\nlibrary BitMath {\n    // returns the 0 indexed position of the most significant bit of the input x\n    // s.t. x \u003e= 2**msb and x \u003c 2**(msb+1)\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x \u003e 0, \u0027BitMath::mostSignificantBit: zero\u0027);\n\n        if (x \u003e= 0x100000000000000000000000000000000) {\n            x \u003e\u003e= 128;\n            r += 128;\n        }\n        if (x \u003e= 0x10000000000000000) {\n            x \u003e\u003e= 64;\n            r += 64;\n        }\n        if (x \u003e= 0x100000000) {\n            x \u003e\u003e= 32;\n            r += 32;\n        }\n        if (x \u003e= 0x10000) {\n            x \u003e\u003e= 16;\n            r += 16;\n        }\n        if (x \u003e= 0x100) {\n            x \u003e\u003e= 8;\n            r += 8;\n        }\n        if (x \u003e= 0x10) {\n            x \u003e\u003e= 4;\n            r += 4;\n        }\n        if (x \u003e= 0x4) {\n            x \u003e\u003e= 2;\n            r += 2;\n        }\n        if (x \u003e= 0x2) r += 1;\n    }\n\n    // returns the 0 indexed position of the least significant bit of the input x\n    // s.t. (x \u0026 2**lsb) != 0 and (x \u0026 (2**(lsb) - 1)) == 0)\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x \u003e 0, \u0027BitMath::leastSignificantBit: zero\u0027);\n\n        r = 255;\n        if (x \u0026 uint128(-1) \u003e 0) {\n            r -= 128;\n        } else {\n            x \u003e\u003e= 128;\n        }\n        if (x \u0026 uint64(-1) \u003e 0) {\n            r -= 64;\n        } else {\n            x \u003e\u003e= 64;\n        }\n        if (x \u0026 uint32(-1) \u003e 0) {\n            r -= 32;\n        } else {\n            x \u003e\u003e= 32;\n        }\n        if (x \u0026 uint16(-1) \u003e 0) {\n            r -= 16;\n        } else {\n            x \u003e\u003e= 16;\n        }\n        if (x \u0026 uint8(-1) \u003e 0) {\n            r -= 8;\n        } else {\n            x \u003e\u003e= 8;\n        }\n        if (x \u0026 0xf \u003e 0) {\n            r -= 4;\n        } else {\n            x \u003e\u003e= 4;\n        }\n        if (x \u0026 0x3 \u003e 0) {\n            r -= 2;\n        } else {\n            x \u003e\u003e= 2;\n        }\n        if (x \u0026 0x1 \u003e 0) r -= 1;\n    }\n}"},"FixedPoint.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity \u003e=0.4.0;\n\nimport \"./FullMath.sol\";\nimport \"./Babylonian.sol\";\nimport \"./BitMath.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 public constant RESOLUTION = 112;\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) \u003c\u003c RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) \u003c\u003c RESOLUTION);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x \u003e\u003e RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x \u003e\u003e RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, \u0027FixedPoint::mul: overflow\u0027);\n        return uq144x112(z);\n    }\n\n    // multiply a UQ112x112 by an int and decode, returning an int\n    // reverts on overflow\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n        uint256 z = FullMath.mulDiv(self._x, uint256(y \u003c 0 ? -y : y), Q112);\n        require(z \u003c 2**255, \u0027FixedPoint::muli: overflow\u0027);\n        return y \u003c 0 ? -int256(z) : int256(z);\n    }\n\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n    // lossy\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        if (self._x == 0 || other._x == 0) {\n            return uq112x112(0);\n        }\n        uint112 upper_self = uint112(self._x \u003e\u003e RESOLUTION); // * 2^0\n        uint112 lower_self = uint112(self._x \u0026 LOWER_MASK); // * 2^-112\n        uint112 upper_other = uint112(other._x \u003e\u003e RESOLUTION); // * 2^0\n        uint112 lower_other = uint112(other._x \u0026 LOWER_MASK); // * 2^-112\n\n        // partial products\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n        // so the bit shift does not overflow\n        require(upper \u003c= uint112(-1), \u0027FixedPoint::muluq: upper overflow\u0027);\n\n        // this cannot exceed 256 bits, all values are 224 bits\n        uint256 sum = uint256(upper \u003c\u003c RESOLUTION) + uppers_lowero + uppero_lowers + (lower \u003e\u003e RESOLUTION);\n\n        // so the cast does not overflow\n        require(sum \u003c= uint224(-1), \u0027FixedPoint::muluq: sum overflow\u0027);\n\n        return uq112x112(uint224(sum));\n    }\n\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        require(other._x \u003e 0, \u0027FixedPoint::divuq: division by zero\u0027);\n        if (self._x == other._x) {\n            return uq112x112(uint224(Q112));\n        }\n        if (self._x \u003c= uint144(-1)) {\n            uint256 value = (uint256(self._x) \u003c\u003c RESOLUTION) / other._x;\n            require(value \u003c= uint224(-1), \u0027FixedPoint::divuq: overflow\u0027);\n            return uq112x112(uint224(value));\n        }\n\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n        require(result \u003c= uint224(-1), \u0027FixedPoint::divuq: overflow\u0027);\n        return uq112x112(uint224(result));\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // can be lossy\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator \u003e 0, \u0027FixedPoint::fraction: division by zero\u0027);\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator \u003c= uint144(-1)) {\n            uint256 result = (numerator \u003c\u003c RESOLUTION) / denominator;\n            require(result \u003c= uint224(-1), \u0027FixedPoint::fraction: overflow\u0027);\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result \u003c= uint224(-1), \u0027FixedPoint::fraction: overflow\u0027);\n            return uq112x112(uint224(result));\n        }\n    }\n\n    // take the reciprocal of a UQ112x112\n    // reverts on overflow\n    // lossy\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, \u0027FixedPoint::reciprocal: reciprocal of zero\u0027);\n        require(self._x != 1, \u0027FixedPoint::reciprocal: overflow\u0027);\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        if (self._x \u003c= uint144(-1)) {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) \u003c\u003c 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) \u003c\u003c safeShiftBits) \u003c\u003c ((112 - safeShiftBits) / 2)));\n    }\n}"},"FullMath.sol":{"content":"// SPDX-License-Identifier: CC-BY-4.0\npragma solidity \u003e=0.4.0;\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm \u003c l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d \u0026 -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n\n        uint256 mm = mulmod(x, y, d);\n        if (mm \u003e l) h -= 1;\n        l -= mm;\n\n        if (h == 0) return l / d;\n\n        require(h \u003c d, \u0027FullMath: FULLDIV_OVERFLOW\u0027);\n        return fullDiv(l, h, d);\n    }\n}"},"IBarcelonaswapV1Exchange.sol":{"content":"pragma solidity \u003e=0.5.0;\n\ninterface IBarcelonaswapV1Exchange {\n    function balanceOf(address owner) external view returns (uint);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function removeLiquidity(uint, uint, uint, uint) external returns (uint, uint);\n    function tokenToEthSwapInput(uint, uint, uint) external returns (uint);\n    function ethToTokenSwapInput(uint, uint) external payable returns (uint);\n}"},"IBarcelonaswapV1Factory.sol":{"content":"pragma solidity \u003e=0.5.0;\n\ninterface IBarcelonaswapV1Factory {\n    function getExchange(address) external view returns (address);\n}"},"IBarcelonaswapV2Factory.sol":{"content":"pragma solidity \u003e=0.5.0;\n\ninterface IBarcelonaswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}"},"IBarcelonaswapV2Migrator.sol":{"content":"pragma solidity \u003e=0.5.0;\n\ninterface IBarcelonaswapV2Migrator {\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;\n}"},"IBarcelonaswapV2Pair.sol":{"content":"pragma solidity \u003e=0.5.0;\n\ninterface IBarcelonaswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"},"IBarcelonaswapV2Router01.sol":{"content":"pragma solidity \u003e=0.6.2;\n\ninterface IBarcelonaswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"},"IBarcelonaswapV2Router02.sol":{"content":"pragma solidity \u003e=0.6.2;\n\nimport \"./IBarcelonaswapV2Router01.sol\";\n\ninterface IBarcelonaswapV2Router02 is IBarcelonaswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"},"IPRC20.sol":{"content":"pragma solidity \u003e=0.5.0;\n\ninterface IPRC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}"},"IWETH.sol":{"content":"pragma solidity \u003e=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}"},"SafeERC20Namer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity \u003e=0.5.0;\n\nimport \"./AddressStringUtil.sol\";\n\n// produces token descriptors from inconsistent or absent ERC20 symbol implementations that can return string or bytes32\n// this library will always produce a string symbol to represent the token\nlibrary SafeERC20Namer {\n    function bytes32ToString(bytes32 x) private pure returns (string memory) {\n        bytes memory bytesString = new bytes(32);\n        uint256 charCount = 0;\n        for (uint256 j = 0; j \u003c 32; j++) {\n            bytes1 char = x[j];\n            if (char != 0) {\n                bytesString[charCount] = char;\n                charCount++;\n            }\n        }\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 j = 0; j \u003c charCount; j++) {\n            bytesStringTrimmed[j] = bytesString[j];\n        }\n        return string(bytesStringTrimmed);\n    }\n\n    // assumes the data is in position 2\n    function parseStringData(bytes memory b) private pure returns (string memory) {\n        uint256 charCount = 0;\n        // first parse the charCount out of the data\n        for (uint256 i = 32; i \u003c 64; i++) {\n            charCount \u003c\u003c= 8;\n            charCount += uint8(b[i]);\n        }\n\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 i = 0; i \u003c charCount; i++) {\n            bytesStringTrimmed[i] = b[i + 64];\n        }\n\n        return string(bytesStringTrimmed);\n    }\n\n    // uses a heuristic to produce a token name from the address\n    // the heuristic returns the full hex of the address string in upper case\n    function addressToName(address token) private pure returns (string memory) {\n        return AddressStringUtil.toAsciiString(token, 40);\n    }\n\n    // uses a heuristic to produce a token symbol from the address\n    // the heuristic returns the first 6 hex of the address string in upper case\n    function addressToSymbol(address token) private pure returns (string memory) {\n        return AddressStringUtil.toAsciiString(token, 6);\n    }\n\n    // calls an external view token contract method that returns a symbol or name, and parses the output into a string\n    function callAndParseStringReturn(address token, bytes4 selector) private view returns (string memory) {\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(selector));\n        // if not implemented, or returns empty data, return empty string\n        if (!success || data.length == 0) {\n            return \u0027\u0027;\n        }\n        // bytes32 data always has length 32\n        if (data.length == 32) {\n            bytes32 decoded = abi.decode(data, (bytes32));\n            return bytes32ToString(decoded);\n        } else if (data.length \u003e 64) {\n            return abi.decode(data, (string));\n        }\n        return \u0027\u0027;\n    }\n\n    // attempts to extract the token symbol. if it does not implement symbol, returns a symbol derived from the address\n    function tokenSymbol(address token) internal view returns (string memory) {\n        // 0x95d89b41 = bytes4(keccak256(\"symbol()\"))\n        string memory symbol = callAndParseStringReturn(token, 0x95d89b41);\n        if (bytes(symbol).length == 0) {\n            // fallback to 6 uppercase hex of address\n            return addressToSymbol(token);\n        }\n        return symbol;\n    }\n\n    // attempts to extract the token name. if it does not implement name, returns a name derived from the address\n    function tokenName(address token) internal view returns (string memory) {\n        // 0x06fdde03 = bytes4(keccak256(\"name()\"))\n        string memory name = callAndParseStringReturn(token, 0x06fdde03);\n        if (bytes(name).length == 0) {\n            // fallback to full hex of address\n            return addressToName(token);\n        }\n        return name;\n    }\n}"},"SafeMath.sol":{"content":"pragma solidity =0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) \u003e= x, \u0027ds-math-add-overflow\u0027);\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) \u003c= x, \u0027ds-math-sub-underflow\u0027);\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \u0027ds-math-mul-overflow\u0027);\n    }\n}"},"TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity \u003e=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes(\u0027approve(address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \u0027TransferHelper::safeApprove: approve failed\u0027\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes(\u0027transfer(address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \u0027TransferHelper::safeTransfer: transfer failed\u0027\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes(\u0027transferFrom(address,address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \u0027TransferHelper::transferFrom: transferFrom failed\u0027\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \u0027TransferHelper::safeTransferETH: ETH transfer failed\u0027);\n    }\n}"}}