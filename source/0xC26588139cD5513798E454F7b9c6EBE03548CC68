{"AlpacaAuth.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n/**\n  ∩~~~~∩ \n  ξ ･×･ ξ \n  ξ　~　ξ \n  ξ　　 ξ \n  ξ　　 “~～~～〇 \n  ξ　　　　　　 ξ \n  ξ ξ ξ~～~ξ ξ ξ \n　 ξ_ξξ_ξ　ξ_ξξ_ξ\nAlpaca Fin Corporation\n*/\n\npragma solidity 0.6.12;\n\nimport \"./IAuth.sol\";\n\ncontract AlpacaAuthEvents {\n  event LogSetAuthority(address indexed _authority);\n  event LogSetOwner(address indexed _owner);\n}\n\ncontract AlpacaAuth is AlpacaAuthEvents {\n  IAuthority public authority;\n  address public owner;\n\n  constructor() public {\n    owner = msg.sender;\n    emit LogSetOwner(msg.sender);\n  }\n\n  function setOwner(address _owner) public auth {\n    owner = _owner;\n    emit LogSetOwner(owner);\n  }\n\n  function setAuthority(IAuthority _authority) public auth {\n    authority = _authority;\n    emit LogSetAuthority(address(authority));\n  }\n\n  modifier auth() {\n    require(isAuthorized(msg.sender, msg.sig), \"alpaca-auth-unauthorized\");\n    _;\n  }\n\n  function isAuthorized(address _src, bytes4 _sig) internal view returns (bool) {\n    if (_src == address(this)) {\n      return true;\n    } else if (_src == owner) {\n      return true;\n    } else if (address(authority) == address(0)) {\n      return false;\n    } else {\n      return authority.canCall(_src, address(this), _sig);\n    }\n  }\n}\n"},"AlpacaNote.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n/**\n  ∩~~~~∩ \n  ξ ･×･ ξ \n  ξ　~　ξ \n  ξ　　 ξ \n  ξ　　 “~～~～〇 \n  ξ　　　　　　 ξ \n  ξ ξ ξ~～~ξ ξ ξ \n　 ξ_ξξ_ξ　ξ_ξξ_ξ\nAlpaca Fin Corporation\n*/\n\npragma solidity 0.6.12;\n\ncontract AlpacaNote {\n  event LogNote(\n    bytes4 indexed sig,\n    address indexed guy,\n    bytes32 indexed foo,\n    bytes32 indexed bar,\n    uint256 wad,\n    bytes fax\n  ) anonymous;\n\n  modifier note() {\n    bytes32 foo;\n    bytes32 bar;\n    uint256 wad;\n\n    assembly {\n      foo := calldataload(4)\n      bar := calldataload(36)\n      wad := callvalue()\n    }\n\n    _;\n\n    emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n  }\n}\n"},"IAuth.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n/**\n  ∩~~~~∩ \n  ξ ･×･ ξ \n  ξ　~　ξ \n  ξ　　 ξ \n  ξ　　 “~～~～〇 \n  ξ　　　　　　 ξ \n  ξ ξ ξ~～~ξ ξ ξ \n　 ξ_ξξ_ξ　ξ_ξξ_ξ\nAlpaca Fin Corporation\n*/\n\npragma solidity 0.6.12;\n\ninterface IAuthority {\n  function canCall(\n    address src,\n    address dst,\n    bytes4 sig\n  ) external view returns (bool);\n}\n"},"ProxyWallet.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n/**\n  ∩~~~~∩ \n  ξ ･×･ ξ \n  ξ　~　ξ \n  ξ　　 ξ \n  ξ　　 “~～~～〇 \n  ξ　　　　　　 ξ \n  ξ ξ ξ~～~ξ ξ ξ \n　 ξ_ξξ_ξ　ξ_ξξ_ξ\nAlpaca Fin Corporation\n*/\n\npragma solidity 0.6.12;\n\nimport \"./AlpacaAuth.sol\";\nimport \"./AlpacaNote.sol\";\nimport \"./ProxyWalletCache.sol\";\n\n// ProxyWallet\n// Allows code execution using a persistant identity This can be very\n// useful to execute a sequence of atomic actions. Since the owner of\n// the proxy can be changed, this allows for dynamic ownership models\n// i.e. a multisig\ncontract ProxyWallet is AlpacaAuth, AlpacaNote {\n  ProxyWalletCache public cache; // global cache for contracts\n\n  constructor(address _cacheAddr) public {\n    setCache(_cacheAddr);\n  }\n\n  receive() external payable {}\n\n  // use the proxy to execute calldata _data on contract _code\n  function execute(bytes memory _code, bytes memory _data)\n    public\n    payable\n    returns (address _target, bytes memory _response)\n  {\n    _target = cache.read(_code);\n    if (_target == address(0)) {\n      // deploy contract \u0026 store its address in cache\n      _target = cache.write(_code);\n    }\n\n    _response = execute(_target, _data);\n  }\n\n  function execute(address _target, bytes memory _data) public payable auth note returns (bytes memory _response) {\n    require(_target != address(0), \"proxy-wallet-target-address-required\");\n\n    // call contract in current context\n    assembly {\n      let _succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\n      let _size := returndatasize()\n\n      _response := mload(0x40)\n      mstore(0x40, add(_response, and(add(add(_size, 0x20), 0x1f), not(0x1f))))\n      mstore(_response, _size)\n      returndatacopy(add(_response, 0x20), 0, _size)\n\n      switch iszero(_succeeded)\n      case 1 {\n        // throw if delegatecall failed\n        revert(add(_response, 0x20), _size)\n      }\n    }\n  }\n\n  //set new cache\n  function setCache(address _cacheAddr) public auth note returns (bool) {\n    require(_cacheAddr != address(0), \"proxy-wallet-cache-address-required\");\n    cache = ProxyWalletCache(_cacheAddr); // overwrite cache\n    return true;\n  }\n}\n"},"ProxyWalletCache.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n/**\n  ∩~~~~∩ \n  ξ ･×･ ξ \n  ξ　~　ξ \n  ξ　　 ξ \n  ξ　　 “~～~～〇 \n  ξ　　　　　　 ξ \n  ξ ξ ξ~～~ξ ξ ξ \n　 ξ_ξξ_ξ　ξ_ξξ_ξ\nAlpaca Fin Corporation\n*/\n\npragma solidity 0.6.12;\n\ncontract ProxyWalletCache {\n  mapping(bytes32 =\u003e address) cache;\n\n  function read(bytes memory _code) public view returns (address) {\n    bytes32 hash = keccak256(_code);\n    return cache[hash];\n  }\n\n  function write(bytes memory _code) public returns (address _target) {\n    assembly {\n      _target := create(0, add(_code, 0x20), mload(_code))\n      switch iszero(extcodesize(_target))\n      case 1 {\n        // throw if contract failed to deploy\n        revert(0, 0)\n      }\n    }\n    bytes32 hash = keccak256(_code);\n    cache[hash] = _target;\n  }\n}\n"}}