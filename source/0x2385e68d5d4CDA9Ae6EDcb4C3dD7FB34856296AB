pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Exchange
*/

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract Exchange {

	address owner;
	uint256 public minExchange1To2amtInTermsOfNativeToken = uint256(1000000000000000);
	uint256 public tax1To2rate = uint256(5000);
	uint256 public from1To2AmtInBank0 = uint256(0);
	uint256 public from1To2AmtInBank1 = uint256(0);
	uint256 public from1To2AmtInBank = uint256(0);
	uint256 public minExchange2To1amtInTermsOfCoinJERO_TOKEN = uint256(10000000000000000);
	uint256 public tax2To1rate = uint256(5000);
	uint256 public from2To1AmtInBank0 = uint256(0);
	uint256 public from2To1AmtInBank1 = uint256(0);
	uint256 public from2To1AmtInBank = uint256(0);
	uint256 public taxDiversion0 = uint256(90);
	uint256 public taxDiversion1 = uint256(10);
	event Exchanged (address indexed tgt);

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	function squareRootUInt(uint y) internal pure returns (uint z) {
	if (y > 3) {
		z = y;
		uint x = y / 2 + 1;
		while (x < z) {
			z = x;
			x = (y / x + x) / 2;
		}
	} else if (y != 0) {
		z = 1;
	}
}

/**
 * Function changeValueOf_minExchange1To2amtInTermsOfNativeToken
 * Notes for _minExchange1To2amtInTermsOfNativeToken : 1 Native Token is represented by 10^18.
 * The function takes in 1 variable, (zero or a positive integer) _minExchange1To2amtInTermsOfNativeToken. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates minExchange1To2amtInTermsOfNativeToken as _minExchange1To2amtInTermsOfNativeToken
*/
	function changeValueOf_minExchange1To2amtInTermsOfNativeToken(uint256 _minExchange1To2amtInTermsOfNativeToken) external onlyOwner {
		minExchange1To2amtInTermsOfNativeToken  = _minExchange1To2amtInTermsOfNativeToken;
	}

/**
 * Function changeValueOf_tax1To2rate
 * Notes for _tax1To2rate : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _tax1To2rate. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates tax1To2rate as _tax1To2rate
*/
	function changeValueOf_tax1To2rate(uint256 _tax1To2rate) external onlyOwner {
		tax1To2rate  = _tax1To2rate;
	}

/**
 * Function changeValueOf_minExchange2To1amtInTermsOfCoinJERO_TOKEN
 * Notes for _minExchange2To1amtInTermsOfCoinJERO_TOKEN : 1 Coin JERO_TOKEN is represented by 10^18.
 * The function takes in 1 variable, (zero or a positive integer) _minExchange2To1amtInTermsOfCoinJERO_TOKEN. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates minExchange2To1amtInTermsOfCoinJERO_TOKEN as _minExchange2To1amtInTermsOfCoinJERO_TOKEN
*/
	function changeValueOf_minExchange2To1amtInTermsOfCoinJERO_TOKEN(uint256 _minExchange2To1amtInTermsOfCoinJERO_TOKEN) external onlyOwner {
		minExchange2To1amtInTermsOfCoinJERO_TOKEN  = _minExchange2To1amtInTermsOfCoinJERO_TOKEN;
	}

/**
 * Function changeValueOf_tax2To1rate
 * Notes for _tax2To1rate : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _tax2To1rate. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates tax2To1rate as _tax2To1rate
*/
	function changeValueOf_tax2To1rate(uint256 _tax2To1rate) external onlyOwner {
		tax2To1rate  = _tax2To1rate;
	}

/**
 * Function changeValueOf_taxDiversion0
 * Notes for _taxDiversion0 : Set Percentage of the Tax diverted by this address. 1 = 1%
 * The function takes in 1 variable, (zero or a positive integer) _taxDiversion0. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates taxDiversion0 as _taxDiversion0
*/
	function changeValueOf_taxDiversion0(uint256 _taxDiversion0) external onlyOwner {
		taxDiversion0  = _taxDiversion0;
	}

/**
 * Function changeValueOf_taxDiversion1
 * Notes for _taxDiversion1 : Set Percentage of the Tax diverted by this address. 1 = 1%
 * The function takes in 1 variable, (zero or a positive integer) _taxDiversion1. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates taxDiversion1 as _taxDiversion1
*/
	function changeValueOf_taxDiversion1(uint256 _taxDiversion1) external onlyOwner {
		taxDiversion1  = _taxDiversion1;
	}

/**
 * Function resultantAmtFromExchanging1To2
 * ExchangeRateConverter
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable originalExchangeVal with initial value ((_amt) * (ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract))) / (amount of native currency owned by the address of this contract)
 * creates an internal variable newExchangeVal with initial value ((_amt) * (((ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract)) - (from2To1AmtInBank0) - (from2To1AmtInBank1) - (from2To1AmtInBank)) - (originalExchangeVal))) / (((amount of native currency owned by the address of this contract) - (from1To2AmtInBank0) - (from1To2AmtInBank1) - (from1To2AmtInBank)) + (_amt))
 * returns square root of (originalExchangeVal) * (newExchangeVal) as output
*/
	function resultantAmtFromExchanging1To2(uint256 _amt) public view returns (uint256) {
		uint256 originalExchangeVal = ((_amt * ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this))) / address(this).balance);
		uint256 newExchangeVal = ((_amt * ((ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this)) - from2To1AmtInBank0 - from2To1AmtInBank1 - from2To1AmtInBank) - originalExchangeVal)) / ((address(this).balance - from1To2AmtInBank0 - from1To2AmtInBank1 - from1To2AmtInBank) + _amt));
		return squareRootUInt((originalExchangeVal * newExchangeVal));
	}

/**
 * Function exchange1To2
 * Minimum Exchange Amount : Variable minExchange1To2amtInTermsOfNativeToken
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that (amount of native currency sent to contract) is greater than or equals to minExchange1To2amtInTermsOfNativeToken
 * updates from1To2AmtInBank0 as (from1To2AmtInBank0) + (((amount of native currency sent to contract) * (taxDiversion0) * (tax1To2rate)) / (100000000))
 * updates from1To2AmtInBank1 as (from1To2AmtInBank1) + (((amount of native currency sent to contract) * (taxDiversion1) * (tax1To2rate)) / (100000000))
 * updates from1To2AmtInBank as (from1To2AmtInBank) + (((amount of native currency sent to contract) * (tax1To2rate) * ((100) - (taxDiversion0) - (taxDiversion1))) / (100000000))
 * checks that (ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((resultantAmtFromExchanging1To2 with variable _amt as (((amount of native currency sent to contract) * ((1000000) - (tax1To2rate))) / (1000000))) + (from2To1AmtInBank0) + (from2To1AmtInBank1) + (from2To1AmtInBank))
 * if (resultantAmtFromExchanging1To2 with variable _amt as (((amount of native currency sent to contract) * ((1000000) - (tax1To2rate))) / (1000000))) is strictly greater than 0 then (calls ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at transfer function  with variable recipient as (the address that called this function), variable amount as (resultantAmtFromExchanging1To2 with variable _amt as (((amount of native currency sent to contract) * ((1000000) - (tax1To2rate))) / (1000000))))
 * emits event Exchanged with inputs the address that called this function
*/
	function exchange1To2() public payable {
		require((msg.value >= minExchange1To2amtInTermsOfNativeToken), "Too little exchanged");
		from1To2AmtInBank0  = (from1To2AmtInBank0 + ((msg.value * taxDiversion0 * tax1To2rate) / uint256(100000000)));
		from1To2AmtInBank1  = (from1To2AmtInBank1 + ((msg.value * taxDiversion1 * tax1To2rate) / uint256(100000000)));
		from1To2AmtInBank  = (from1To2AmtInBank + ((msg.value * tax1To2rate * (uint256(100) - taxDiversion0 - taxDiversion1)) / uint256(100000000)));
		require((ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this)) >= (resultantAmtFromExchanging1To2(((msg.value * (uint256(1000000) - tax1To2rate)) / uint256(1000000))) + from2To1AmtInBank0 + from2To1AmtInBank1 + from2To1AmtInBank)), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((resultantAmtFromExchanging1To2(((msg.value * (uint256(1000000) - tax1To2rate)) / uint256(1000000))) > uint256(0))){
			ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).transfer(msg.sender, resultantAmtFromExchanging1To2(((msg.value * (uint256(1000000) - tax1To2rate)) / uint256(1000000))));
		}
		emit Exchanged(msg.sender);
	}

/**
 * Function from1To2TaxWithdrawAmt0
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that (the address that called this function) is equals to Address 0xff190c4b9c793a0B2b3fEA5584dD7771F9D44837
 * checks that (amount of native currency owned by the address of this contract) is greater than or equals to from1To2AmtInBank0
 * if from1To2AmtInBank0 is strictly greater than 0 then (transfers from1To2AmtInBank0 of the native currency to the address that called this function)
 * updates from1To2AmtInBank0 as 0
*/
	function from1To2TaxWithdrawAmt0() public {
		require((msg.sender == address(0xff190c4b9c793a0B2b3fEA5584dD7771F9D44837)), "Not the withdrawal address");
		require((address(this).balance >= from1To2AmtInBank0), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((from1To2AmtInBank0 > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : from1To2AmtInBank0}(""); require(success_1, "can't send money");
		}
		from1To2AmtInBank0  = uint256(0);
	}

/**
 * Function from1To2TaxWithdrawAmt1
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that (the address that called this function) is equals to Address 0xA47F105cD37a49C905B5a59dcBe62b37e9c84636
 * checks that (amount of native currency owned by the address of this contract) is greater than or equals to from1To2AmtInBank1
 * if from1To2AmtInBank1 is strictly greater than 0 then (transfers from1To2AmtInBank1 of the native currency to the address that called this function)
 * updates from1To2AmtInBank1 as 0
*/
	function from1To2TaxWithdrawAmt1() public {
		require((msg.sender == address(0xA47F105cD37a49C905B5a59dcBe62b37e9c84636)), "Not the withdrawal address");
		require((address(this).balance >= from1To2AmtInBank1), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((from1To2AmtInBank1 > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : from1To2AmtInBank1}(""); require(success_1, "can't send money");
		}
		from1To2AmtInBank1  = uint256(0);
	}

/**
 * Function from1To2TaxWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (amount of native currency owned by the address of this contract) is greater than or equals to from1To2AmtInBank
 * if from1To2AmtInBank is strictly greater than 0 then (transfers from1To2AmtInBank of the native currency to the address that called this function)
 * updates from1To2AmtInBank as 0
*/
	function from1To2TaxWithdrawAmt() public onlyOwner {
		require((address(this).balance >= from1To2AmtInBank), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((from1To2AmtInBank > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : from1To2AmtInBank}(""); require(success_1, "can't send money");
		}
		from1To2AmtInBank  = uint256(0);
	}

/**
 * Function resultantAmtFromExchanging2To1
 * ExchangeRateConverter
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable originalExchangeVal with initial value ((_amt) * (amount of native currency owned by the address of this contract)) / (ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract))
 * creates an internal variable newExchangeVal with initial value ((_amt) * (((amount of native currency owned by the address of this contract) - (from1To2AmtInBank0) - (from1To2AmtInBank1) - (from1To2AmtInBank)) - (originalExchangeVal))) / (((ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract)) - (from2To1AmtInBank0) - (from2To1AmtInBank1) - (from2To1AmtInBank)) + (_amt))
 * returns square root of (originalExchangeVal) * (newExchangeVal) as output
*/
	function resultantAmtFromExchanging2To1(uint256 _amt) public view returns (uint256) {
		uint256 originalExchangeVal = ((_amt * address(this).balance) / ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this)));
		uint256 newExchangeVal = ((_amt * ((address(this).balance - from1To2AmtInBank0 - from1To2AmtInBank1 - from1To2AmtInBank) - originalExchangeVal)) / ((ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this)) - from2To1AmtInBank0 - from2To1AmtInBank1 - from2To1AmtInBank) + _amt));
		return squareRootUInt((originalExchangeVal * newExchangeVal));
	}

/**
 * Function exchange2To1
 * Minimum Exchange Amount : Variable minExchange2To1amtInTermsOfCoinJERO_TOKEN
 * The function takes in 1 variable, (zero or a positive integer) v0. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that v0 is greater than or equals to minExchange2To1amtInTermsOfCoinJERO_TOKEN
 * calls ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as v0
 * updates from2To1AmtInBank0 as (from2To1AmtInBank0) + (((v0) * (taxDiversion0) * (tax2To1rate)) / (100000000))
 * updates from2To1AmtInBank1 as (from2To1AmtInBank1) + (((v0) * (taxDiversion1) * (tax2To1rate)) / (100000000))
 * updates from2To1AmtInBank as (from2To1AmtInBank) + (((v0) * (tax2To1rate) * ((100) - (taxDiversion0) - (taxDiversion1))) / (100000000))
 * checks that (amount of native currency owned by the address of this contract) is greater than or equals to ((resultantAmtFromExchanging2To1 with variable _amt as (((v0) * ((1000000) - (tax2To1rate))) / (1000000))) + (from1To2AmtInBank0) + (from1To2AmtInBank1) + (from1To2AmtInBank))
 * if (resultantAmtFromExchanging2To1 with variable _amt as (((v0) * ((1000000) - (tax2To1rate))) / (1000000))) is strictly greater than 0 then (transfers resultantAmtFromExchanging2To1 with variable _amt as (((v0) * ((1000000) - (tax2To1rate))) / (1000000)) of the native currency to the address that called this function)
 * emits event Exchanged with inputs the address that called this function
*/
	function exchange2To1(uint256 v0) public {
		require((v0 >= minExchange2To1amtInTermsOfCoinJERO_TOKEN), "Too little exchanged");
		ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).transferFrom(msg.sender, address(this), v0);
		from2To1AmtInBank0  = (from2To1AmtInBank0 + ((v0 * taxDiversion0 * tax2To1rate) / uint256(100000000)));
		from2To1AmtInBank1  = (from2To1AmtInBank1 + ((v0 * taxDiversion1 * tax2To1rate) / uint256(100000000)));
		from2To1AmtInBank  = (from2To1AmtInBank + ((v0 * tax2To1rate * (uint256(100) - taxDiversion0 - taxDiversion1)) / uint256(100000000)));
		require((address(this).balance >= (resultantAmtFromExchanging2To1(((v0 * (uint256(1000000) - tax2To1rate)) / uint256(1000000))) + from1To2AmtInBank0 + from1To2AmtInBank1 + from1To2AmtInBank)), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((resultantAmtFromExchanging2To1(((v0 * (uint256(1000000) - tax2To1rate)) / uint256(1000000))) > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : resultantAmtFromExchanging2To1(((v0 * (uint256(1000000) - tax2To1rate)) / uint256(1000000)))}(""); require(success_1, "can't send money");
		}
		emit Exchanged(msg.sender);
	}

/**
 * Function from2To1TaxWithdrawAmt0
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that (the address that called this function) is equals to Address 0xff190c4b9c793a0B2b3fEA5584dD7771F9D44837
 * checks that (ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to from2To1AmtInBank0
 * if from2To1AmtInBank0 is strictly greater than 0 then (calls ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at transfer function  with variable recipient as (the address that called this function), variable amount as from2To1AmtInBank0)
 * updates from2To1AmtInBank0 as 0
*/
	function from2To1TaxWithdrawAmt0() public {
		require((msg.sender == address(0xff190c4b9c793a0B2b3fEA5584dD7771F9D44837)), "Not the withdrawal address");
		require((ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this)) >= from2To1AmtInBank0), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((from2To1AmtInBank0 > uint256(0))){
			ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).transfer(msg.sender, from2To1AmtInBank0);
		}
		from2To1AmtInBank0  = uint256(0);
	}

/**
 * Function from2To1TaxWithdrawAmt1
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that (the address that called this function) is equals to Address 0xA47F105cD37a49C905B5a59dcBe62b37e9c84636
 * checks that (ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to from2To1AmtInBank1
 * if from2To1AmtInBank1 is strictly greater than 0 then (calls ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at transfer function  with variable recipient as (the address that called this function), variable amount as from2To1AmtInBank1)
 * updates from2To1AmtInBank1 as 0
*/
	function from2To1TaxWithdrawAmt1() public {
		require((msg.sender == address(0xA47F105cD37a49C905B5a59dcBe62b37e9c84636)), "Not the withdrawal address");
		require((ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this)) >= from2To1AmtInBank1), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((from2To1AmtInBank1 > uint256(0))){
			ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).transfer(msg.sender, from2To1AmtInBank1);
		}
		from2To1AmtInBank1  = uint256(0);
	}

/**
 * Function from2To1TaxWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to from2To1AmtInBank
 * if from2To1AmtInBank is strictly greater than 0 then (calls ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at transfer function  with variable recipient as (the address that called this function), variable amount as from2To1AmtInBank)
 * updates from2To1AmtInBank as 0
*/
	function from2To1TaxWithdrawAmt() public onlyOwner {
		require((ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this)) >= from2To1AmtInBank), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((from2To1AmtInBank > uint256(0))){
			ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).transfer(msg.sender, from2To1AmtInBank);
		}
		from2To1AmtInBank  = uint256(0);
	}

/**
 * Function baselineExchangeRate1To2
 * BaselineExchangeRateConverterForDeposits
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that (amount of native currency owned by the address of this contract) is strictly greater than 0
 * returns ((_amt) * ((ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract)) - (from2To1AmtInBank0) - (from2To1AmtInBank1) - (from2To1AmtInBank))) / ((amount of native currency owned by the address of this contract) - (from1To2AmtInBank0) - (from1To2AmtInBank1) - (from1To2AmtInBank)) as output
*/
	function baselineExchangeRate1To2(uint256 _amt) public view returns (uint256) {
		require((address(this).balance > uint256(0)), "Exchange rate cannot be calculated as balance of Native Token is 0.");
		return ((_amt * (ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this)) - from2To1AmtInBank0 - from2To1AmtInBank1 - from2To1AmtInBank)) / (address(this).balance - from1To2AmtInBank0 - from1To2AmtInBank1 - from1To2AmtInBank));
	}

/**
 * Function initialDepositOfTokens
 * InitialDeposits
 * The function takes in 1 variable, (zero or a positive integer) _amountOfToken2. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (amount of native currency owned by the address of this contract) is equals to (amount of native currency sent to contract)
 * checks that (amount of native currency sent to contract) is strictly greater than 0
 * checks that (ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract)) is equals to 0
 * checks that _amountOfToken2 is strictly greater than 0
 * calls ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _amountOfToken2
*/
	function initialDepositOfTokens(uint256 _amountOfToken2) public payable onlyOwner {
		require((address(this).balance == msg.value), "Need balance of Native Token to be deposit amount.");
		require((msg.value > uint256(0)), "Need deposit of Native Token to be greater than 0.");
		require((ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this)) == uint256(0)), "Need balance of Coin JERO_TOKEN to be 0.");
		require((_amountOfToken2 > uint256(0)), "Need deposit of Coin JERO_TOKEN to be greater than 0.");
		ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).transferFrom(msg.sender, address(this), _amountOfToken2);
	}

/**
 * Function subsequentDepositOfTokens
 * SubsequentDeposits
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that ((amount of native currency owned by the address of this contract) - (from1To2AmtInBank0) - (from1To2AmtInBank1) - (from1To2AmtInBank)) is strictly greater than (amount of native currency sent to contract)
 * checks that ((ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract)) - (from2To1AmtInBank0) - (from2To1AmtInBank1) - (from2To1AmtInBank)) is strictly greater than 0
 * checks that (amount of native currency sent to contract) is strictly greater than 0
 * calls ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as (baselineExchangeRate1To2 with variable _amt as (amount of native currency sent to contract))
*/
	function subsequentDepositOfTokens() public payable onlyOwner {
		require(((address(this).balance - from1To2AmtInBank0 - from1To2AmtInBank1 - from1To2AmtInBank) > msg.value), "Need balance of Native Token to be greater than deposit amount.");
		require(((ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this)) - from2To1AmtInBank0 - from2To1AmtInBank1 - from2To1AmtInBank) > uint256(0)), "Need balance of Coin JERO_TOKEN to be greater than 0.");
		require((msg.value > uint256(0)), "Need deposit of Native Token to be greater than 0.");
		ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).transferFrom(msg.sender, address(this), baselineExchangeRate1To2(msg.value));
	}

/**
 * Function withdrawTokens
 * The function takes in 1 variable, (zero or a positive integer) _firstTokenAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (amount of native currency owned by the address of this contract) is greater than or equals to ((_firstTokenAmt) + (from1To2AmtInBank0) + (from1To2AmtInBank1) + (from1To2AmtInBank))
 * if _firstTokenAmt is strictly greater than 0 then (transfers _firstTokenAmt of the native currency to the address that called this function)
 * checks that (ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((baselineExchangeRate1To2 with variable _amt as _firstTokenAmt) + (from2To1AmtInBank0) + (from2To1AmtInBank1) + (from2To1AmtInBank))
 * if (baselineExchangeRate1To2 with variable _amt as _firstTokenAmt) is strictly greater than 0 then (calls ERC20(Address 0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)'s at transfer function  with variable recipient as (the address that called this function), variable amount as (baselineExchangeRate1To2 with variable _amt as _firstTokenAmt))
*/
	function withdrawTokens(uint256 _firstTokenAmt) public onlyOwner {
		require((address(this).balance >= (_firstTokenAmt + from1To2AmtInBank0 + from1To2AmtInBank1 + from1To2AmtInBank)), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((_firstTokenAmt > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : _firstTokenAmt}(""); require(success_1, "can't send money");
		}
		require((ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).balanceOf(address(this)) >= (baselineExchangeRate1To2(_firstTokenAmt) + from2To1AmtInBank0 + from2To1AmtInBank1 + from2To1AmtInBank)), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((baselineExchangeRate1To2(_firstTokenAmt) > uint256(0))){
			ERC20(address(0xaC58Ec16df7aaCbeE412676315F147a88ed870AF)).transfer(msg.sender, baselineExchangeRate1To2(_firstTokenAmt));
		}
	}

	function sendMeNativeCurrency() external payable {
	}
}