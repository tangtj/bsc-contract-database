{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller\u0027s account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}"},"Main.sol":{"content":"//Test on Mainnet\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"./IERC20.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\n\n\ninterface IPrebitReferrals {\n\n\n\n    function generateReferralCode(uint256 _parentCode) external;\n    function generateReferralCodeWithContract(uint256 _parentCode, address _user) external;\n    function userReferralCode(address _user) external view returns (uint256, address, address, bool);\n    function referralCodeToAddress(uint256 _referralCode) external view returns (address);\n    function userReferralCodeCheck(address _user) external view returns (bool);\n    function userReferralCodeToAddress(uint256 _code) external view returns (address);\n    function getUserTparent(address _user) external view returns (address);\n    function getUserParent(address _user) external view returns (address);\n    function isContractAllowed(address _contractAddress) external view returns (bool);\n}\n\ninterface IPrebit {\n    function injectFunds(uint256 _prebitId, uint256 _amount, uint256 _row) external;\n}\n\n\ncontract MainPrebit is Ownable {\n    using SafeMath for uint256;\n    //Interfaces\n    IPrebitReferrals public referralContract;\n    // Token used for purchasing tickets\n    IERC20 public payToken;\n   \n    address public injectorAddress;\n    address public operatorAddress;\n\n    address public treasuryAddress;\n    address[] public treasuryWallets;\n    uint256[] public treasuryPercentages;\n    \n    //Percents\n    uint256 public percentTreasury = 15;\n\n\n    uint256 public percentReferralsLv1 = 10; // Level 1 :10% , Level 2 : 5%\n    uint256 public percentReferralsLv2 = 5; // Level 1 :10% , Level 2 : 5%\n\n    uint256 public constant MAX_OWNER_FEE = 15; // 15%\n    uint256 public constant MAX_REFERRAL_FEE = 15; // 15%\n\n  \n    //Price and variables\n    uint256 precardPrice = 2000000000000000000;\n    uint256 public constant MAX_CARD_PRICE = 10000000000000000000; // 10 USDT\n\n\n    //Pot Percent\n     uint256 public potPercent = 70; // 70%\n    //\n    uint256 public currentPreBitId;\n    uint256 public currentPreCardId;\n\n\n \n    enum Status {\n        Pending,\n        Open,\n        Close,\n        End\n    }\n\n    struct Prebit {\n        Status status;\n        uint256 startTime;\n        uint256 openPredictTime;\n        uint256 closePredictTime;\n        uint256 endTime;\n        uint256[6] amountInRows;\n        uint256[6] rewardEachCard;\n        uint256[6] cardsInRows;\n        uint256 firstPrecardId;\n        uint256 totalTreasuryAmount;\n        uint256 totalEntryAmount;\n        uint256 totalPayReferrals;\n        uint256 finalPrice;\n        bool priceSet;\n    }\n\n    struct RowData {\n    uint256 amountInRow;\n    uint256 cardsInRow;\n    uint256 rewardEachCard;\n}\n\n// Define a struct to hold Prebit data\nstruct PrebitData {\n    uint256 endTime;\n    uint256 userPrecardCount;\n}\n\n\n    struct Precard {\n        uint256 predictPrice;\n        address owner;\n        bool claimed;\n    }\n    mapping(uint256 =\u003e Prebit) public _prebits;\n    mapping(uint256 =\u003e Precard) public _precards;\n    uint256[6] public rowsRange;\n\n\n    uint256 public latestPrecardCalculated;\n    uint256 public pendingInjectionNextPrebit;\n\n\n    mapping(address =\u003e mapping(uint256 =\u003e uint256[]))\n        public _userPreCardIdsPerPreBitId;\n\n\n\n            modifier onlyOperator() {\n        require(msg.sender == operatorAddress, \"Not operator\");\n        _;\n    }\n\n    modifier onlyOwnerOrInjector() {\n        require((msg.sender == owner()) || (msg.sender == injectorAddress), \"Not owner or injector\");\n        _;\n    }\n    //Events\n    event PurchasePrecardEvent(address _user ,uint256 _prebitID,uint256[] _prediction,uint256 _count,uint256 _referralCode);\n    event PayReferralsEvent(address _parent ,uint256 _prebitID,uint256 _payReferralAmount,uint256 _totalAmount,uint256 _type);\n    event StartNextPrebitEvent(uint256 indexed prebitId,uint256 _endTime,uint256 _openPrecardTime, uint256 _closePrecardTime,uint256 firstTicketId);\n    event ExecuteDrawFinalPriceEvent(uint256 indexed prebitId, uint256 finalPrice);\n    event ClaimTicketEvent(address _user,uint256 indexed prebitId, uint256[] precards,uint256 amount);\n\n   \n\n    constructor(address _payToken , address _referralContractAddress) {\n        payToken = IERC20(_payToken);\n       \n        referralContract = IPrebitReferrals(_referralContractAddress);\n        rowsRange[0] = 0; // Row 1 - 0 Cent\n        rowsRange[1] = 25;// Row 2 - 25 Cent\n        rowsRange[2] = 50;// Row 3 - 50 Cent\n        rowsRange[3] = 100;// Row 4 - 100 Cent\n        rowsRange[4] = 500;// Row 5 - 500 Cent\n        rowsRange[5] = 1000;// Row 6 - 1000 Cent\n    }\n\n    // Purchase a ticket \n    function purchasePrecard(\n        uint256 _prebitID,\n        uint256[] memory _prediction,\n        uint256 _referralCode\n    ) external {\n        require(\n            _prebits[_prebitID].status == Status.Open,\n            \"Prebit ID is not open\"\n        );\n        require(\n            block.timestamp \u003c _prebits[_prebitID].closePredictTime,\n            \"Prebit ID is over\"\n        );\n\n        require(\n            _prediction.length \u003e 0,\n            \"101 : Precard count must be greater than 0\"\n        );\n\n        //Calculate BUSD Price and transfer BUSD\n\n        uint256 totalPayAmount = _prediction.length * precardPrice;\n         \n       require(payToken.balanceOf(msg.sender) \u003e= totalPayAmount, \"102 : Insufficient USDT balance\");\n\n        // Pays \u0026 Generate referral code\n     \n         referralContract.generateReferralCodeWithContract(_referralCode,msg.sender);\n        _paysProcess(totalPayAmount);\n\n       \n        uint256 amountPot = totalPayAmount.mul(potPercent).div(100);\n       // Increment the total amount collected for the prebit round\n        _prebits[_prebitID].totalEntryAmount += amountPot;\n        _prebits[_prebitID].totalTreasuryAmount += totalPayAmount.mul(percentTreasury).div(100);\n       \n  \n        //Calulate\n\n        _prebits[_prebitID].amountInRows[0] +=   amountPot.mul(30).div(100);\n        _prebits[_prebitID].amountInRows[1] +=  amountPot.mul(20).div(100); \n        _prebits[_prebitID].amountInRows[2] += amountPot.mul(15).div(100); \n        _prebits[_prebitID].amountInRows[3] += amountPot.mul(12).div(100); \n        _prebits[_prebitID].amountInRows[4] += amountPot.mul(10).div(100); \n        _prebits[_prebitID].amountInRows[5] += amountPot.mul(13).div(100); \n\n      \n        //Insert Precard\n\n        for (uint256 i = 0; i \u003c _prediction.length; i++) {\n            uint256 thisPrecardPrice = _prediction[i];\n\n            _userPreCardIdsPerPreBitId[msg.sender][_prebitID].push(\n                currentPreCardId\n            );\n\n            _precards[currentPreCardId] = Precard({\n                predictPrice: thisPrecardPrice,\n                owner: msg.sender,\n                claimed: false\n            });\n\n          \n            currentPreCardId++;\n        }\n\n        emit PurchasePrecardEvent(msg.sender,_prebitID, _prediction, _prediction.length, _referralCode);\n    }\n\n     function _paysProcess(uint256 _totalPayAmount) private {\n\n         uint256 newAmount = _totalPayAmount;\n         address parentAddress = referralContract.getUserParent(msg.sender);\n        if (parentAddress != address(0)  ) {\n             newAmount -=  _totalPayAmount.mul(percentReferralsLv1).div(100);\n            payToken.transferFrom(\n                msg.sender,\n                parentAddress,\n                _totalPayAmount.mul(percentReferralsLv1).div(100)\n            );\n\n             emit PayReferralsEvent(parentAddress, currentPreBitId,  _totalPayAmount.mul(percentReferralsLv1).div(100), _totalPayAmount,1);\n                 address tParentAddress = referralContract.getUserTparent(msg.sender);\n            if (tParentAddress != address(0)) {\n                payToken.transferFrom(\n                    msg.sender,\n                    tParentAddress,\n                    _totalPayAmount.mul(percentReferralsLv2).div(100)\n                );\n\n                emit PayReferralsEvent(tParentAddress, currentPreBitId,  _totalPayAmount.mul(percentReferralsLv2).div(100), _totalPayAmount,2);\n\n                 newAmount -=  _totalPayAmount.mul(percentReferralsLv2).div(100);\n            } else {\n             \n            _prebits[currentPreBitId].totalTreasuryAmount += _totalPayAmount.mul(percentReferralsLv2).div(100);\n            }\n        } else {\n             _prebits[currentPreBitId].totalTreasuryAmount +=  _totalPayAmount.mul(percentReferralsLv1+percentReferralsLv2).div(100);\n        }\n\n         payToken.transferFrom(msg.sender, address(this), newAmount);\n    }\n\n    function startNextPrebit(\n        uint256 _endTime,\n        uint256 _openPrecardTime,\n        uint256 _closePrecardTime\n    ) external onlyOperator {\n        require(\n            (currentPreBitId == 0) ||\n                (_prebits[currentPreBitId].status == Status.End),\n            \"Not time to start PreBit\"\n        );\n\n        currentPreBitId++;\n\n        _prebits[currentPreBitId] = Prebit({\n            status: Status.Open,\n            startTime: block.timestamp,\n            openPredictTime: _openPrecardTime,\n            closePredictTime: _closePrecardTime,\n            endTime: _endTime,\n            amountInRows: [\n                uint256(0),\n                uint256(0),\n                uint256(0),\n                uint256(0),\n                uint256(0),\n                uint256(0)\n            ],\n            rewardEachCard: [\n                uint256(0),\n                uint256(0),\n                uint256(0),\n                uint256(0),\n                uint256(0),\n                uint256(0)\n            ],\n            cardsInRows: [\n                uint256(0),\n                uint256(0),\n                uint256(0),\n                uint256(0),\n                uint256(0),\n                uint256(0)\n            ],\n            firstPrecardId: currentPreCardId,\n            totalTreasuryAmount: 0,\n            totalEntryAmount: 0,\n            totalPayReferrals: 0,\n            finalPrice: 0,\n            priceSet: false\n        });\n        _prebits[currentPreBitId].amountInRows[0]= pendingInjectionNextPrebit ;\n        pendingInjectionNextPrebit = 0;\n\n        emit StartNextPrebitEvent(currentPreBitId, _endTime, _openPrecardTime, _closePrecardTime, currentPreCardId);\n    }\n\n    function executeDrawFinalPrice(uint256 _prebitId, uint256 _price,uint256 _batchSize) external onlyOperator {\n\n\n         require(\n            block.timestamp \u003e _prebits[_prebitId].endTime,\n            \"Prebit Not End\"\n        );\n\n\n  require(\n            _prebits[_prebitId].status != Status.End,\n            \"This Prebit is Finished\"\n        );\n\n   uint256 finalPrice;\n            if( _prebits[_prebitId].priceSet == false ){\n               _prebits[_prebitId].finalPrice=_price;\n               finalPrice=_price;\n               _prebits[_prebitId].priceSet = true;\n            }else{\nfinalPrice =  _prebits[_prebitId].finalPrice;\n            }\n      \n      \n\n\n\n        \n        //Percent Rows\n\n   \n    uint256 startPrecardId = latestPrecardCalculated;\n    uint256 endPrecardId = startPrecardId + _batchSize;\n    // Ensure we don\u0027t exceed the total number of precards\n    if (endPrecardId \u003e currentPreCardId) {\n        endPrecardId = currentPreCardId;\n    }\n\n        for (\n            uint256 i = startPrecardId;\n            i \u003c endPrecardId;\n            i++\n        ) {\n            uint256 cardPrice = _precards[i].predictPrice;\n            if (cardPrice == finalPrice) {\n                //Jackpot\n                _prebits[_prebitId].cardsInRows[0] =\n                    _prebits[_prebitId].cardsInRows[0] +\n                    1;\n            } else if (\n                isPredictionWithinRange(cardPrice, rowsRange[1], finalPrice)\n            ) {\n                _prebits[_prebitId].cardsInRows[1] =\n                    _prebits[_prebitId].cardsInRows[1] +\n                    1;\n            } else if (\n                isPredictionWithinRange(cardPrice, rowsRange[2], finalPrice)\n            ) {\n                _prebits[_prebitId].cardsInRows[2] =\n                    _prebits[_prebitId].cardsInRows[2] +\n                    1;\n            } else if (\n                isPredictionWithinRange(cardPrice, rowsRange[3], finalPrice)\n            ) {\n                _prebits[_prebitId].cardsInRows[3] =\n                    _prebits[_prebitId].cardsInRows[3] +\n                    1;\n            } else if (\n                isPredictionWithinRange(cardPrice, rowsRange[4], finalPrice)\n            ) {\n                _prebits[_prebitId].cardsInRows[4] =\n                    _prebits[_prebitId].cardsInRows[4] +\n                    1;\n            } else if (\n                isPredictionWithinRange(cardPrice, rowsRange[5], finalPrice)\n            ) {\n                _prebits[_prebitId].cardsInRows[5] =\n                    _prebits[_prebitId].cardsInRows[5] +\n                    1;\n            }\n\n             latestPrecardCalculated++;\n        }\n \n        if (latestPrecardCalculated == currentPreCardId){\n        //Calc  Reward Each card\n        if (_prebits[_prebitId].cardsInRows[0] \u003e 0){\n         _prebits[_prebitId].rewardEachCard[0] =    (_prebits[_prebitId].amountInRows[0]).div(_prebits[_prebitId].cardsInRows[0]);\n        }else{\n            pendingInjectionNextPrebit += _prebits[_prebitId].amountInRows[0];\n        }\n\n  if (_prebits[_prebitId].cardsInRows[1] \u003e 0){\n         _prebits[_prebitId].rewardEachCard[1] =    (_prebits[_prebitId].amountInRows[1]).div(_prebits[_prebitId].cardsInRows[1]);\n        }else{\n            pendingInjectionNextPrebit += _prebits[_prebitId].amountInRows[1];\n        }\n\n\n  if (_prebits[_prebitId].cardsInRows[2] \u003e 0){\n         _prebits[_prebitId].rewardEachCard[2] =    (_prebits[_prebitId].amountInRows[2]).div(_prebits[_prebitId].cardsInRows[2]);\n        }else{\n            pendingInjectionNextPrebit += _prebits[_prebitId].amountInRows[2];\n        }\n\n\n  if (_prebits[_prebitId].cardsInRows[3] \u003e 0){\n         _prebits[_prebitId].rewardEachCard[3] =    (_prebits[_prebitId].amountInRows[3]).div(_prebits[_prebitId].cardsInRows[3]);\n        }else{\n            pendingInjectionNextPrebit += _prebits[_prebitId].amountInRows[3];\n        }\n\n          if (_prebits[_prebitId].cardsInRows[4] \u003e 0){\n         _prebits[_prebitId].rewardEachCard[4] =    (_prebits[_prebitId].amountInRows[4]).div(_prebits[_prebitId].cardsInRows[4]);\n        }else{\n            pendingInjectionNextPrebit += _prebits[_prebitId].amountInRows[4];\n        }\n        \n\n          if (_prebits[_prebitId].cardsInRows[5] \u003e 0){\n         _prebits[_prebitId].rewardEachCard[5] =    (_prebits[_prebitId].amountInRows[5]).div(_prebits[_prebitId].cardsInRows[5]);\n        }else{\n            pendingInjectionNextPrebit += _prebits[_prebitId].amountInRows[5];\n        }\n    \n   \n        // Mark the Prebit as finalized\n        _prebits[_prebitId].status = Status.End;\n\n        //Transfer TreasuryAmount\n\n      \n\n       _paysTreasury(_prebits[_prebitId].totalTreasuryAmount);\n    \n        //\n        emit ExecuteDrawFinalPriceEvent(_prebitId, finalPrice);\n        }\n    }\n\n    function claimRewardPrebit(\n        uint256 _prebitID\n    ) external {\n         require(_prebits[_prebitID].status == Status.End, \"Prebit not claimable\");\n         uint256[] memory _preCardsIDs;\n        _preCardsIDs = getUserPreCardIDs(msg.sender, _prebitID);\n\n        require(_preCardsIDs.length != 0, \"You Don\u0027t Have Any Precard in This Round\");\n        uint256 rewardInUsdtToTransfer;\n                for (uint256 i = 0; i \u003c _preCardsIDs.length; i++) {\n           \n\n            uint256 thisPrecard = _preCardsIDs[i];\n\n         \n            require(_prebits[_prebitID].firstPrecardId \u003c= thisPrecard, \"TicketId too low\");\n            require(msg.sender == _precards[thisPrecard].owner, \"Not the owner\");\n\n            // Update the lottery ticket owner to 0x address\n            _precards[thisPrecard].owner = address(0);\n            _precards[thisPrecard].claimed=true;\n            uint256 rewardForPrecardId = _calculateRewardsForOnePrecard(_prebitID, thisPrecard);\n\n            // Increment the reward to transfer\n            rewardInUsdtToTransfer += rewardForPrecardId;\n        }\n\n            require(rewardInUsdtToTransfer \u003e 0, \"You are not winner in this round\");\n            //Transfer to User\n            payToken.transfer(msg.sender, rewardInUsdtToTransfer.mul(97).div(100));\n            //Transfer to Referrals lv1\n            if (referralContract.getUserParent(msg.sender) != address(0)  ) {\n                     address parentAddress = referralContract.getUserParent(msg.sender);\n                     payToken.transfer(parentAddress,rewardInUsdtToTransfer.mul(3).div(100));\n            }else{\n\n                _paysTreasury(rewardInUsdtToTransfer.mul(3).div(100));\n                    \n            }\n\n            emit ClaimTicketEvent(msg.sender, _prebitID, _preCardsIDs, rewardInUsdtToTransfer.mul(97).div(100));\n    }\n    \n\n\n      function _paysTreasury(uint256 _totalTransfers) private {\n\n            uint256 remainingAmount = _totalTransfers;\n  if (treasuryWallets.length \u003e 0 ){\n          for (uint256 i = 0; i \u003c treasuryWallets.length; i++) {\n\n            uint256 amountToTransfer = (_totalTransfers).mul(treasuryPercentages[i]).div(100);\n          \n                if (amountToTransfer \u003e 0){\n                     remainingAmount -= amountToTransfer;\n              payToken.transfer(treasuryWallets[i], amountToTransfer);\n              }\n\n        }\n\n         if (remainingAmount\u003e 0 )    { \n   payToken.transfer(treasuryAddress, remainingAmount);\n   }\n        }else{\n      payToken.transfer(treasuryAddress,remainingAmount);\n        }\n  \n        \n    }\n\n    function _calculateRewardsForOnePrecard(\n        uint256 _prebitId,\n        uint256 _precardId\n    ) public view returns (uint256) {\n        // Retrieve the user number combination from the ticketId\n        if (!_precards[_precardId].claimed) {\n            uint256 userPredictPrice = _precards[_precardId].predictPrice;\n\n            uint256 rowCard = getRowsTicketInPrebit(\n                userPredictPrice,\n                _prebitId\n            );\n            if(rowCard !=6) { // Means not in any rows and return 0\n            if (getCountAndAmountCardsInRow(_prebitId, rowCard)[2] \u003e 0){\n            return getCountAndAmountCardsInRow(_prebitId, rowCard)[2];\n            }else{\n                return 0 ;\n            }\n            }else{\n               return 0; \n            }\n        } else {\n            return 0;\n        }\n    }\n\n    function _calculateRewardsForAllPrecard(uint256 _prebitId,address _user)\n        public\n        view\n        returns (uint256)\n    {\n        // Retrieve the user number combination from the ticketId\n\n        uint256[] memory userPrecards = getUserPreCardIDs(\n            _user,\n            _prebitId\n        );\n        uint256 sumReward;\n        for (uint256 i = 0; i \u003c userPrecards.length; i++) {\n            sumReward += _calculateRewardsForOnePrecard(\n                _prebitId,\n                userPrecards[i]\n            );\n        }\n\n        return sumReward;\n    }\n\n    function getRowsTicketInPrebit(uint256 _cardPrice, uint256 _prebitId)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 _prebitFinalPrice = _prebits[_prebitId].finalPrice;\n        if (_cardPrice == _prebitFinalPrice) {\n            //Bitpot\n            return 0;\n        } else if (\n            isPredictionWithinRange(_cardPrice, rowsRange[1], _prebitFinalPrice)\n        ) {\n            return 1;\n        } else if (\n            isPredictionWithinRange(_cardPrice, rowsRange[2], _prebitFinalPrice)\n        ) {\n            return 2;\n        } else if (\n            isPredictionWithinRange(_cardPrice, rowsRange[3], _prebitFinalPrice)\n        ) {\n            return 3;\n        } else if (\n            isPredictionWithinRange(_cardPrice, rowsRange[4], _prebitFinalPrice)\n        ) {\n            return 4;\n        } else if (\n            isPredictionWithinRange(_cardPrice, rowsRange[5], _prebitFinalPrice)\n        ) {\n            return 5;\n        } else {\n            return 6; // Means not in any rows\n        }\n    }\n\n    function isPredictionWithinRange (\n        uint256 _myPrice,\n        uint256 _rangeCent,\n        uint256 _bitcoinPrice\n    ) private  pure returns (bool) {\n        return\n            (_myPrice \u003e= _bitcoinPrice.sub(_rangeCent)) \u0026\u0026\n            (_myPrice \u003c= _bitcoinPrice.add(_rangeCent));\n    }\n\n    function getUserPreCardIDs(address _address, uint256 _prebit)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return _userPreCardIdsPerPreBitId[_address][_prebit];\n    }\n\n\n     function getPredictPriceWithPrecards(uint256[] memory _cards)\n        public\n        view\n        returns (uint256[] memory)\n    {\n          uint256[] memory _data = new uint256[](_cards.length);\n         for (uint256 i = 0; i \u003c _cards.length; i++) {\n             _data[i] = _precards[_cards[i]].predictPrice;\n        \n        }\n        return _data;\n    }\n\n    function TotalTicketInPrebitId(uint256 _prebit)\n        public\n        view\n        returns (uint256)\n    {\n       \n               \n     if (currentPreBitId == _prebit)\n     {\n            return currentPreCardId - (_prebits[_prebit].firstPrecardId);\n        }\n        else  {\n              return (_prebits[_prebit+1].firstPrecardId) - _prebits[_prebit].firstPrecardId ;\n        }\n       \n    }\n\n    function getCurrentBitPot()\n        public\n        view\n        returns (uint256)\n    {\n        return getCountAndAmountCardsInRow(currentPreBitId, 0)[0];\n    }\n\n    function getCurrentAmountInAllRows()\n        public\n        view\n        returns (uint256)\n    {\n        uint256 sumAmount=0;\n         for (uint256 i = 0; i \u003c 6; i++) {\n             sumAmount+=getCountAndAmountCardsInRow(currentPreBitId,i)[0];\n        \n        }\n        return sumAmount;\n    }\n\n\n function getRowsData(uint256 _prebit) public view returns (RowData[] memory) {\n    RowData[] memory rowArray = new RowData[](6);\n\n    for (uint256 i = 0; i \u003c 6; i++) {\n        rowArray[i] = RowData({\n            amountInRow: _prebits[_prebit].amountInRows[i],\n            cardsInRow: _prebits[_prebit].cardsInRows[i],\n            rewardEachCard: _prebits[_prebit].rewardEachCard[i]\n        });\n    }\n\n    return rowArray;\n}\n\n// Function to get data for multiple Prebits\nfunction getLatestPrebitsData(uint256[] memory _prebitIds, address _user) public view returns (PrebitData[] memory) {\n    PrebitData[] memory prebitsData = new PrebitData[](_prebitIds.length);\n\n    for (uint256 i = 0; i \u003c _prebitIds.length; i++) {\n        uint256 prebitId = _prebitIds[i];\n        uint256 getUserPrecardCount = getUserPreCardIDs(_user, prebitId).length;\n\n        prebitsData[i] = PrebitData({\n            endTime: _prebits[prebitId].endTime,\n            userPrecardCount: getUserPrecardCount\n        });\n    }\n\n    return prebitsData;\n}\n   \n function getCountAndAmountCardsInRow(uint256 _prebit, uint256 _row)\n    public\n    view\n    returns (uint256[] memory)\n{\n    uint256[] memory _data = new uint256[](3); // Initialize _data with a length of 3\n\n    _data[0] = _prebits[_prebit].amountInRows[_row];\n    _data[1] = _prebits[_prebit].cardsInRows[_row];\n    _data[2] = _prebits[_prebit].rewardEachCard[_row];\n\n    return _data;\n}\n\n\n    function injectFunds(uint256 _prebitId, uint256 _amount,uint256 _row) external  onlyOwnerOrInjector {\n        require(_prebits[_prebitId].status != Status.End, \"Prebit not be End\");\n\n        payToken.transferFrom(address(msg.sender), address(this) , _amount);\n        _prebits[_prebitId].amountInRows[_row] += _amount;\n\n       \n    }\n\n\n      function setOperatorAndTreasuryAndInjectorAddresses(\n        address _operatorAddress,\n        address _treasuryAddress,\n        address _injectorAddress\n    ) external onlyOwner {\n        require(_operatorAddress != address(0), \"Cannot be zero address\");\n        require(_treasuryAddress != address(0), \"Cannot be zero address\");\n        require(_injectorAddress != address(0), \"Cannot be zero address\");\n\n        operatorAddress = _operatorAddress;\n        treasuryAddress = _treasuryAddress;\n        injectorAddress = _injectorAddress;\n\n        \n    }\n\n\nfunction setPrecardPrice(uint256 _newPrice) external onlyOwner {\n    require(_newPrice \u003c= MAX_CARD_PRICE, \"Price exceeds the maximum allowed\");\n\n    precardPrice = _newPrice;\n}\n\n      function addTreasuryWallet(address _wallet, uint256 _percentage) external onlyOwner {\n        require(_wallet != address(0), \"Treasury wallet address cannot be zero\");\n        require(_percentage \u003c= 100, \"Percentage must be between 0 and 100\");\n        uint256 totalPercentage = 0;\n          for (uint256 i = 0; i \u003c treasuryWallets.length; i++) {\n            totalPercentage += treasuryPercentages[i];\n        }\n         require(totalPercentage+_percentage \u003c= 100 , \"Percentage must be less than 100\");\n\n        treasuryWallets.push(_wallet);\n        treasuryPercentages.push(_percentage);\n    }\n\n    function updateTreasuryWallet(uint256 _index, address _wallet, uint256 _percentage) external onlyOwner {\n        require(_index \u003c treasuryWallets.length, \"Invalid index\");\n        require(_wallet != address(0), \"Treasury wallet address cannot be zero\");\n        require(_percentage \u003c= 100, \"Percentage must be between 1 and 100\");\n\n   uint256 totalPercentage = 0;\n          for (uint256 i = 0; i \u003c treasuryWallets.length; i++) {\n            totalPercentage += treasuryPercentages[i];\n        }\n         require(totalPercentage+_percentage \u003c= 100 , \"Percentage must be less than 100\");\n\n\n        treasuryWallets[_index] = _wallet;\n        treasuryPercentages[_index] = _percentage;\n    }\n\n function migrateToNewVersion(address _newContract) external onlyOwner {\n        // Ensure that the new contract address is set\n        require(_newContract != address(0), \"New contract address not set\");\n\n        // Transfer all pending injections to the new contract\n        uint256 totalPendingInjection = pendingInjectionNextPrebit;\n        if (totalPendingInjection \u003e 0) {\n            payToken.transfer(_newContract, totalPendingInjection);\n            IPrebit(_newContract).injectFunds(1, totalPendingInjection, 0);\n            pendingInjectionNextPrebit = 0;\n        }\n\n      \n      \n    }\n\n    //For test \n\n        function withdraw() public onlyOwner {\n        (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        require(os);\n    }\n    function withdrawTokens(IERC20 token) public onlyOwner {\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(msg.sender, balance);\n    }\n\n    //Set Variables\n\n\n\n    /*\n    Helper for Error Handling \n    Error Code : \n    101 : You must select precard , or Count Precard must be greater than 0\n    102 : Insufficient BUSD balance\n    103 : Error Allowance BUSD\n    104 : User Have Referral Code\n    */\n}\n"},"Ownable.sol":{"content":"\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"},"SafeMath.sol":{"content":"\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler\u0027s built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n            // benefit is lost if \u0027b\u0027 is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}"}}