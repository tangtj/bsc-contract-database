pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Staking
 * Referral Scheme : 10, 10, 5, 5
*/

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract Staking {

	address owner;
	uint256 public principalAmtInBank0 = uint256(0);
	uint256 public principalAmtInBank = uint256(0);
	uint256 public taxDiversion0 = uint256(100);
	struct record1 { uint256 stakeTime; uint256 stakeAmt; uint256 lastUpdateTime; uint256 accumulatedInterestToUpdateTime; uint256 amtWithdrawn; }
	mapping(address => record1) public informationAboutStakeScheme1;
	mapping(uint256 => address) public addressStore1;
	uint256 public numberOfAddressesCurrentlyStaked1 = uint256(0);
	uint256 public maxStakeAmt1 = uint256(25000000000000000000);
	uint256 public principalWithdrawalTax1 = uint256(50000);
	uint256 public dailyInterestRate1 = uint256(1000);
	uint256 public dailyInterestRate1_1 = uint256(1000);
	uint256 public dailyInterestRate1_2 = uint256(2000);
	uint256 public minStakePeriod1 = (uint256(36500) * uint256(864));
	uint256 public totalWithdrawals1 = uint256(0);
	struct record2 { uint256 stakeTime; uint256 stakeAmt; uint256 lastUpdateTime; uint256 accumulatedInterestToUpdateTime; uint256 amtWithdrawn; }
	mapping(address => record2) public informationAboutStakeScheme2;
	mapping(uint256 => address) public addressStore2;
	uint256 public numberOfAddressesCurrentlyStaked2 = uint256(0);
	uint256 public maxStakeAmt2 = uint256(25000000000000000000);
	uint256 public principalWithdrawalTax2 = uint256(50000);
	uint256 public dailyInterestRate2 = uint256(3000);
	uint256 public dailyInterestRate2_1 = uint256(3000);
	uint256 public dailyInterestRate2_2 = uint256(4000);
	uint256 public minStakePeriod2 = (uint256(109500) * uint256(864));
	uint256 public totalWithdrawals2 = uint256(0);
	struct referralRecord { bool hasDeposited; address referringAddress; uint256 unclaimedRewards; uint256 referralsAmtAtLevel0; uint256 referralsCountAtLevel0; uint256 referralsAmtAtLevel1; uint256 referralsCountAtLevel1; uint256 referralsAmtAtLevel2; uint256 referralsCountAtLevel2; uint256 referralsAmtAtLevel3; uint256 referralsCountAtLevel3; }
	mapping(address => referralRecord) public referralRecordMap;
	event ReferralAddressAdded (address indexed referredAddress);
	uint256 public totalUnclaimedRewards = uint256(0);
	uint256 public totalClaimedRewards = uint256(0);
	event Staked (address indexed account);
	event Unstaked (address indexed account);

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

/**
 * Function changeValueOf_taxDiversion0
 * Notes for _taxDiversion0 : Set Percentage of the Tax diverted by this address. 1 = 1%
 * The function takes in 1 variable, (zero or a positive integer) _taxDiversion0. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates taxDiversion0 as _taxDiversion0
*/
	function changeValueOf_taxDiversion0(uint256 _taxDiversion0) external onlyOwner {
		taxDiversion0  = _taxDiversion0;
	}

/**
 * Function changeValueOf_maxStakeAmt1
 * Notes for _maxStakeAmt1 : 1 Coin AntiBotLiquidityGeneratorToken is represented by 10^9.
 * The function takes in 1 variable, (zero or a positive integer) _maxStakeAmt1. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates maxStakeAmt1 as _maxStakeAmt1
*/
	function changeValueOf_maxStakeAmt1(uint256 _maxStakeAmt1) external onlyOwner {
		maxStakeAmt1  = _maxStakeAmt1;
	}

/**
 * Function changeValueOf_principalWithdrawalTax1
 * Notes for _principalWithdrawalTax1 : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _principalWithdrawalTax1. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _principalWithdrawalTax1
 * checks that 1000000 is strictly greater than _principalWithdrawalTax1
 * updates principalWithdrawalTax1 as _principalWithdrawalTax1
*/
	function changeValueOf_principalWithdrawalTax1(uint256 _principalWithdrawalTax1) external onlyOwner {
		require((uint256(0) < _principalWithdrawalTax1), "Tax rate needs to be larger than 0%");
		require((uint256(1000000) > _principalWithdrawalTax1), "Tax rate needs to be smaller than 100%");
		principalWithdrawalTax1  = _principalWithdrawalTax1;
	}

/**
 * Function changeValueOf_minStakePeriod1
 * Notes for _minStakePeriod1 : 1 day is represented by 86400 (seconds)
 * The function takes in 1 variable, (zero or a positive integer) _minStakePeriod1. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates minStakePeriod1 as _minStakePeriod1
*/
	function changeValueOf_minStakePeriod1(uint256 _minStakePeriod1) external onlyOwner {
		minStakePeriod1  = _minStakePeriod1;
	}

/**
 * Function changeValueOf_maxStakeAmt2
 * Notes for _maxStakeAmt2 : 1 Coin AntiBotLiquidityGeneratorToken is represented by 10^9.
 * The function takes in 1 variable, (zero or a positive integer) _maxStakeAmt2. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates maxStakeAmt2 as _maxStakeAmt2
*/
	function changeValueOf_maxStakeAmt2(uint256 _maxStakeAmt2) external onlyOwner {
		maxStakeAmt2  = _maxStakeAmt2;
	}

/**
 * Function changeValueOf_principalWithdrawalTax2
 * Notes for _principalWithdrawalTax2 : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _principalWithdrawalTax2. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _principalWithdrawalTax2
 * checks that 1000000 is strictly greater than _principalWithdrawalTax2
 * updates principalWithdrawalTax2 as _principalWithdrawalTax2
*/
	function changeValueOf_principalWithdrawalTax2(uint256 _principalWithdrawalTax2) external onlyOwner {
		require((uint256(0) < _principalWithdrawalTax2), "Tax rate needs to be larger than 0%");
		require((uint256(1000000) > _principalWithdrawalTax2), "Tax rate needs to be smaller than 100%");
		principalWithdrawalTax2  = _principalWithdrawalTax2;
	}

/**
 * Function changeValueOf_minStakePeriod2
 * Notes for _minStakePeriod2 : 1 day is represented by 86400 (seconds)
 * The function takes in 1 variable, (zero or a positive integer) _minStakePeriod2. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates minStakePeriod2 as _minStakePeriod2
*/
	function changeValueOf_minStakePeriod2(uint256 _minStakePeriod2) external onlyOwner {
		minStakePeriod2  = _minStakePeriod2;
	}

/**
 * Function addReferralAddress
 * The function takes in 1 variable, (an address) _referringAddress. It can only be called by functions outside of this contract. It does the following :
 * checks that referralRecordMap with element _referringAddress with element hasDeposited
 * checks that not _referringAddress is equals to (the address that called this function)
 * checks that (referralRecordMap with element the address that called this function with element referringAddress) is equals to Address 0
 * updates referralRecordMap (Element the address that called this function) (Entity referringAddress) as _referringAddress
 * emits event ReferralAddressAdded with inputs the address that called this function
*/
	function addReferralAddress(address _referringAddress) external {
		require(referralRecordMap[_referringAddress].hasDeposited, "Referring Address has not made a deposit");
		require(!((_referringAddress == msg.sender)), "Self-referrals are not allowed");
		require((referralRecordMap[msg.sender].referringAddress == address(0)), "User has previously indicated a referral address");
		referralRecordMap[msg.sender].referringAddress  = _referringAddress;
		emit ReferralAddressAdded(msg.sender);
	}

/**
 * Function withdrawReferral
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that (referralRecordMap with element the address that called this function with element unclaimedRewards) is greater than or equals to _amt
 * updates referralRecordMap (Element the address that called this function) (Entity unclaimedRewards) as (referralRecordMap with element the address that called this function with element unclaimedRewards) - (_amt)
 * updates totalUnclaimedRewards as (totalUnclaimedRewards) - (_amt)
 * updates totalClaimedRewards as (totalClaimedRewards) + (_amt)
 * checks that (ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _amt
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	function withdrawReferral(uint256 _amt) public {
		require((referralRecordMap[msg.sender].unclaimedRewards >= _amt), "Insufficient referral rewards to withdraw");
		referralRecordMap[msg.sender].unclaimedRewards  = (referralRecordMap[msg.sender].unclaimedRewards - _amt);
		totalUnclaimedRewards  = (totalUnclaimedRewards - _amt);
		totalClaimedRewards  = (totalClaimedRewards + _amt);
		require((ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).balanceOf(address(this)) >= _amt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transfer(msg.sender, _amt);
		}
	}

/**
 * Function addReferral
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can only be called by other functions in this contract. It does the following :
 * creates an internal variable referringAddress with initial value referralRecordMap with element the address that called this function with element referringAddress
 * creates an internal variable referralsAllocated with initial value 0
 * if not referralRecordMap with element the address that called this function with element hasDeposited then (updates referralRecordMap (Element the address that called this function) (Entity hasDeposited) as true)
 * if referringAddress is equals to Address 0 then (returns referralsAllocated as output)
 * updates referralRecordMap (Element referringAddress) (Entity referralsAmtAtLevel0) as (referralRecordMap with element referringAddress with element referralsAmtAtLevel0) + (_amt)
 * updates referralRecordMap (Element referringAddress) (Entity referralsCountAtLevel0) as (referralRecordMap with element referringAddress with element referralsCountAtLevel0) + (1)
 * updates referralRecordMap (Element referringAddress) (Entity unclaimedRewards) as (referralRecordMap with element referringAddress with element unclaimedRewards) + ((10) * (_amt))
 * updates referralsAllocated as (referralsAllocated) + ((10) * (_amt))
 * updates referringAddress as referralRecordMap with element referringAddress with element referringAddress
 * if referringAddress is equals to Address 0 then (updates totalUnclaimedRewards as (totalUnclaimedRewards) + (referralsAllocated); and then returns referralsAllocated as output)
 * updates referralRecordMap (Element referringAddress) (Entity referralsAmtAtLevel1) as (referralRecordMap with element referringAddress with element referralsAmtAtLevel1) + (_amt)
 * updates referralRecordMap (Element referringAddress) (Entity referralsCountAtLevel1) as (referralRecordMap with element referringAddress with element referralsCountAtLevel1) + (1)
 * updates referralRecordMap (Element referringAddress) (Entity unclaimedRewards) as (referralRecordMap with element referringAddress with element unclaimedRewards) + ((10) * (_amt))
 * updates referralsAllocated as (referralsAllocated) + ((10) * (_amt))
 * updates referringAddress as referralRecordMap with element referringAddress with element referringAddress
 * if referringAddress is equals to Address 0 then (updates totalUnclaimedRewards as (totalUnclaimedRewards) + (referralsAllocated); and then returns referralsAllocated as output)
 * updates referralRecordMap (Element referringAddress) (Entity referralsAmtAtLevel2) as (referralRecordMap with element referringAddress with element referralsAmtAtLevel2) + (_amt)
 * updates referralRecordMap (Element referringAddress) (Entity referralsCountAtLevel2) as (referralRecordMap with element referringAddress with element referralsCountAtLevel2) + (1)
 * updates referralRecordMap (Element referringAddress) (Entity unclaimedRewards) as (referralRecordMap with element referringAddress with element unclaimedRewards) + ((5) * (_amt))
 * updates referralsAllocated as (referralsAllocated) + ((5) * (_amt))
 * updates referringAddress as referralRecordMap with element referringAddress with element referringAddress
 * if referringAddress is equals to Address 0 then (updates totalUnclaimedRewards as (totalUnclaimedRewards) + (referralsAllocated); and then returns referralsAllocated as output)
 * updates referralRecordMap (Element referringAddress) (Entity referralsAmtAtLevel3) as (referralRecordMap with element referringAddress with element referralsAmtAtLevel3) + (_amt)
 * updates referralRecordMap (Element referringAddress) (Entity referralsCountAtLevel3) as (referralRecordMap with element referringAddress with element referralsCountAtLevel3) + (1)
 * updates referralRecordMap (Element referringAddress) (Entity unclaimedRewards) as (referralRecordMap with element referringAddress with element unclaimedRewards) + ((5) * (_amt))
 * updates referralsAllocated as (referralsAllocated) + ((5) * (_amt))
 * updates referringAddress as referralRecordMap with element referringAddress with element referringAddress
 * updates totalUnclaimedRewards as (totalUnclaimedRewards) + (referralsAllocated)
 * returns referralsAllocated as output
*/
	function addReferral(uint256 _amt) internal returns (uint256) {
		address referringAddress = referralRecordMap[msg.sender].referringAddress;
		uint256 referralsAllocated = uint256(0);
		if (!(referralRecordMap[msg.sender].hasDeposited)){
			referralRecordMap[msg.sender].hasDeposited  = true;
		}
		if ((referringAddress == address(0))){
			return referralsAllocated;
		}
		referralRecordMap[referringAddress].referralsAmtAtLevel0  = (referralRecordMap[referringAddress].referralsAmtAtLevel0 + _amt);
		referralRecordMap[referringAddress].referralsCountAtLevel0  = (referralRecordMap[referringAddress].referralsCountAtLevel0 + uint256(1));
		referralRecordMap[referringAddress].unclaimedRewards  = (referralRecordMap[referringAddress].unclaimedRewards + (uint256(10) * _amt));
		referralsAllocated  = (referralsAllocated + (uint256(10) * _amt));
		referringAddress  = referralRecordMap[referringAddress].referringAddress;
		if ((referringAddress == address(0))){
			totalUnclaimedRewards  = (totalUnclaimedRewards + referralsAllocated);
			return referralsAllocated;
		}
		referralRecordMap[referringAddress].referralsAmtAtLevel1  = (referralRecordMap[referringAddress].referralsAmtAtLevel1 + _amt);
		referralRecordMap[referringAddress].referralsCountAtLevel1  = (referralRecordMap[referringAddress].referralsCountAtLevel1 + uint256(1));
		referralRecordMap[referringAddress].unclaimedRewards  = (referralRecordMap[referringAddress].unclaimedRewards + (uint256(10) * _amt));
		referralsAllocated  = (referralsAllocated + (uint256(10) * _amt));
		referringAddress  = referralRecordMap[referringAddress].referringAddress;
		if ((referringAddress == address(0))){
			totalUnclaimedRewards  = (totalUnclaimedRewards + referralsAllocated);
			return referralsAllocated;
		}
		referralRecordMap[referringAddress].referralsAmtAtLevel2  = (referralRecordMap[referringAddress].referralsAmtAtLevel2 + _amt);
		referralRecordMap[referringAddress].referralsCountAtLevel2  = (referralRecordMap[referringAddress].referralsCountAtLevel2 + uint256(1));
		referralRecordMap[referringAddress].unclaimedRewards  = (referralRecordMap[referringAddress].unclaimedRewards + (uint256(5) * _amt));
		referralsAllocated  = (referralsAllocated + (uint256(5) * _amt));
		referringAddress  = referralRecordMap[referringAddress].referringAddress;
		if ((referringAddress == address(0))){
			totalUnclaimedRewards  = (totalUnclaimedRewards + referralsAllocated);
			return referralsAllocated;
		}
		referralRecordMap[referringAddress].referralsAmtAtLevel3  = (referralRecordMap[referringAddress].referralsAmtAtLevel3 + _amt);
		referralRecordMap[referringAddress].referralsCountAtLevel3  = (referralRecordMap[referringAddress].referralsCountAtLevel3 + uint256(1));
		referralRecordMap[referringAddress].unclaimedRewards  = (referralRecordMap[referringAddress].unclaimedRewards + (uint256(5) * _amt));
		referralsAllocated  = (referralsAllocated + (uint256(5) * _amt));
		referringAddress  = referralRecordMap[referringAddress].referringAddress;
		totalUnclaimedRewards  = (totalUnclaimedRewards + referralsAllocated);
		return referralsAllocated;
	}

/**
 * Function stake1
 * Daily Interest Rate : Variable dailyInterestRate1
 * This interest rate is modified under certain circumstances, as articulated in the consolidatedInterestRate1 function
 * Minimum Stake Period : Variable minStakePeriod1
 * Address Map : informationAboutStakeScheme1
 * The function takes in 1 variable, (zero or a positive integer) _stakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that _stakeAmt is strictly greater than 0
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element the address that called this function
 * checks that ((_stakeAmt) + (thisRecord with element stakeAmt)) is less than or equals to maxStakeAmt1
 * checks that (thisRecord with element stakeAmt) is equals to 0
 * updates informationAboutStakeScheme1 (Element the address that called this function) as Struct comprising current time, _stakeAmt, current time, 0, 0
 * updates addressStore1 (Element numberOfAddressesCurrentlyStaked1) as the address that called this function
 * updates numberOfAddressesCurrentlyStaked1 as (numberOfAddressesCurrentlyStaked1) + (1)
 * calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _stakeAmt
 * calls addReferral with variable _amt as _stakeAmt
 * emits event Staked with inputs the address that called this function
*/
	function stake1(uint256 _stakeAmt) public {
		require((_stakeAmt > uint256(0)), "Staked amount needs to be greater than 0");
		record1 memory thisRecord = informationAboutStakeScheme1[msg.sender];
		require(((_stakeAmt + thisRecord.stakeAmt) <= maxStakeAmt1), "More than maximum stake amount");
		require((thisRecord.stakeAmt == uint256(0)), "Need to unstake before restaking");
		informationAboutStakeScheme1[msg.sender]  = record1 (block.timestamp, _stakeAmt, block.timestamp, uint256(0), uint256(0));
		addressStore1[numberOfAddressesCurrentlyStaked1]  = msg.sender;
		numberOfAddressesCurrentlyStaked1  = (numberOfAddressesCurrentlyStaked1 + uint256(1));
		ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transferFrom(msg.sender, address(this), _stakeAmt);
		addReferral(_stakeAmt);
		emit Staked(msg.sender);
	}

/**
 * Function unstake1
 * The function takes in 1 variable, (zero or a positive integer) _unstakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element the address that called this function
 * checks that _unstakeAmt is less than or equals to (thisRecord with element stakeAmt)
 * checks that ((current time) - (minStakePeriod1)) is greater than or equals to (thisRecord with element stakeTime)
 * creates an internal variable newAccum with initial value (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((current time) - (thisRecord with element lastUpdateTime)) * (consolidatedInterestRate1 with variable _stakedAmt as (thisRecord with element stakeAmt))) / (86400000000))
 * creates an internal variable interestToRemove with initial value ((newAccum) * (_unstakeAmt)) / (thisRecord with element stakeAmt)
 * updates principalAmtInBank0 as (principalAmtInBank0) + (((_unstakeAmt) * (taxDiversion0) * (principalWithdrawalTax1)) / (100000000))
 * updates principalAmtInBank as (principalAmtInBank) + (((_unstakeAmt) * (principalWithdrawalTax1) * ((100) - (taxDiversion0))) / (100000000))
 * if _unstakeAmt is equals to (thisRecord with element stakeAmt) then (repeat numberOfAddressesCurrentlyStaked1 times with loop variable i0 :  (if (addressStore1 with element Loop Variable i0) is equals to (the address that called this function) then (updates addressStore1 (Element Loop Variable i0) as addressStore1 with element (numberOfAddressesCurrentlyStaked1) - (1); then updates numberOfAddressesCurrentlyStaked1 as (numberOfAddressesCurrentlyStaked1) - (1); and then terminates the for-next loop)))
 * updates informationAboutStakeScheme1 (Element the address that called this function) as Struct comprising (thisRecord with element stakeTime), ((thisRecord with element stakeAmt) - (_unstakeAmt)), current time, ((newAccum) - (interestToRemove)), ((thisRecord with element amtWithdrawn) + (interestToRemove))
 * emits event Unstaked with inputs the address that called this function
 * checks that (ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((((_unstakeAmt) * ((1000000) - (principalWithdrawalTax1))) / (1000000)) + (interestToRemove))
 * if ((((_unstakeAmt) * ((1000000) - (principalWithdrawalTax1))) / (1000000)) + (interestToRemove)) is strictly greater than 0 then (calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transfer function  with variable recipient as (the address that called this function), variable amount as ((((_unstakeAmt) * ((1000000) - (principalWithdrawalTax1))) / (1000000)) + (interestToRemove)))
 * updates totalWithdrawals1 as (totalWithdrawals1) + (interestToRemove)
*/
	function unstake1(uint256 _unstakeAmt) public {
		record1 memory thisRecord = informationAboutStakeScheme1[msg.sender];
		require((_unstakeAmt <= thisRecord.stakeAmt), "Withdrawing more than staked amount");
		require(((block.timestamp - minStakePeriod1) >= thisRecord.stakeTime), "Insufficient stake period");
		uint256 newAccum = (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * consolidatedInterestRate1(thisRecord.stakeAmt)) / uint256(86400000000)));
		uint256 interestToRemove = ((newAccum * _unstakeAmt) / thisRecord.stakeAmt);
		principalAmtInBank0  = (principalAmtInBank0 + ((_unstakeAmt * taxDiversion0 * principalWithdrawalTax1) / uint256(100000000)));
		principalAmtInBank  = (principalAmtInBank + ((_unstakeAmt * principalWithdrawalTax1 * (uint256(100) - taxDiversion0)) / uint256(100000000)));
		if ((_unstakeAmt == thisRecord.stakeAmt)){
			for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked1; i0++){
				if ((addressStore1[i0] == msg.sender)){
					addressStore1[i0]  = addressStore1[(numberOfAddressesCurrentlyStaked1 - uint256(1))];
					numberOfAddressesCurrentlyStaked1  = (numberOfAddressesCurrentlyStaked1 - uint256(1));
					break;
				}
			}
		}
		informationAboutStakeScheme1[msg.sender]  = record1 (thisRecord.stakeTime, (thisRecord.stakeAmt - _unstakeAmt), block.timestamp, (newAccum - interestToRemove), (thisRecord.amtWithdrawn + interestToRemove));
		emit Unstaked(msg.sender);
		require((ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).balanceOf(address(this)) >= (((_unstakeAmt * (uint256(1000000) - principalWithdrawalTax1)) / uint256(1000000)) + interestToRemove)), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if (((((_unstakeAmt * (uint256(1000000) - principalWithdrawalTax1)) / uint256(1000000)) + interestToRemove) > uint256(0))){
			ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transfer(msg.sender, (((_unstakeAmt * (uint256(1000000) - principalWithdrawalTax1)) / uint256(1000000)) + interestToRemove));
		}
		totalWithdrawals1  = (totalWithdrawals1 + interestToRemove);
	}

/**
 * Function updateRecordsWithLatestInterestRates1
 * The function takes in 0 variables. It can only be called by other functions in this contract. It does the following :
 * repeat numberOfAddressesCurrentlyStaked1 times with loop variable i0 :  (creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element addressStore1 with element Loop Variable i0; and then updates informationAboutStakeScheme1 (Element addressStore1 with element Loop Variable i0) as Struct comprising (thisRecord with element stakeTime), (thisRecord with element stakeAmt), current time, ((thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((current time) - (thisRecord with element lastUpdateTime)) * (consolidatedInterestRate1 with variable _stakedAmt as (Loop Variable i0))) / (86400000000))), (thisRecord with element amtWithdrawn))
*/
	function updateRecordsWithLatestInterestRates1() internal {
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked1; i0++){
			record1 memory thisRecord = informationAboutStakeScheme1[addressStore1[i0]];
			informationAboutStakeScheme1[addressStore1[i0]]  = record1 (thisRecord.stakeTime, thisRecord.stakeAmt, block.timestamp, (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * consolidatedInterestRate1(i0)) / uint256(86400000000))), thisRecord.amtWithdrawn);
		}
	}

/**
 * Function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1
 * The function takes in 1 variable, (an address) _address. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element _address
 * returns (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((current time) - (thisRecord with element lastUpdateTime)) * (consolidatedInterestRate1 with variable _stakedAmt as (thisRecord with element stakeAmt))) / (86400000000)) as output
*/
	function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(address _address) public view returns (uint256) {
		record1 memory thisRecord = informationAboutStakeScheme1[_address];
		return (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * consolidatedInterestRate1(thisRecord.stakeAmt)) / uint256(86400000000)));
	}

/**
 * Function totalStakedAmount1
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfAddressesCurrentlyStaked1 times with loop variable i0 :  (creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element addressStore1 with element Loop Variable i0; and then updates total as (total) + (thisRecord with element stakeAmt))
 * returns total as output
*/
	function totalStakedAmount1() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked1; i0++){
			record1 memory thisRecord = informationAboutStakeScheme1[addressStore1[i0]];
			total  = (total + thisRecord.stakeAmt);
		}
		return total;
	}

/**
 * Function totalAccumulatedInterest1
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfAddressesCurrentlyStaked1 times with loop variable i0 :  (updates total as (total) + (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1 with variable _address as (addressStore1 with element Loop Variable i0)))
 * returns total as output
*/
	function totalAccumulatedInterest1() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked1; i0++){
			total  = (total + interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(addressStore1[i0]));
		}
		return total;
	}

/**
 * Function withdrawInterestWithoutUnstaking1
 * The function takes in 1 variable, (zero or a positive integer) _withdrawalAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable totalInterestEarnedTillNow with initial value interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1 with variable _address as (the address that called this function)
 * checks that _withdrawalAmt is less than or equals to totalInterestEarnedTillNow
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element the address that called this function
 * updates informationAboutStakeScheme1 (Element the address that called this function) as Struct comprising (thisRecord with element stakeTime), (thisRecord with element stakeAmt), current time, ((totalInterestEarnedTillNow) - (_withdrawalAmt)), ((thisRecord with element amtWithdrawn) + (_withdrawalAmt))
 * checks that (ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _withdrawalAmt
 * if _withdrawalAmt is strictly greater than 0 then (calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _withdrawalAmt)
 * updates totalWithdrawals1 as (totalWithdrawals1) + (_withdrawalAmt)
*/
	function withdrawInterestWithoutUnstaking1(uint256 _withdrawalAmt) public {
		uint256 totalInterestEarnedTillNow = interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(msg.sender);
		require((_withdrawalAmt <= totalInterestEarnedTillNow), "Withdrawn amount must be less than withdrawable amount");
		record1 memory thisRecord = informationAboutStakeScheme1[msg.sender];
		informationAboutStakeScheme1[msg.sender]  = record1 (thisRecord.stakeTime, thisRecord.stakeAmt, block.timestamp, (totalInterestEarnedTillNow - _withdrawalAmt), (thisRecord.amtWithdrawn + _withdrawalAmt));
		require((ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).balanceOf(address(this)) >= _withdrawalAmt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_withdrawalAmt > uint256(0))){
			ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transfer(msg.sender, _withdrawalAmt);
		}
		totalWithdrawals1  = (totalWithdrawals1 + _withdrawalAmt);
	}

/**
 * Function withdrawAllInterestWithoutUnstaking1
 * The function takes in 0 variables. It can only be called by functions outside of this contract. It does the following :
 * calls withdrawInterestWithoutUnstaking1 with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1 with variable _address as (the address that called this function))
*/
	function withdrawAllInterestWithoutUnstaking1() external {
		withdrawInterestWithoutUnstaking1(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(msg.sender));
	}

/**
 * Function consolidatedInterestRate1
 * The function takes in 1 variable, (zero or a positive integer) _stakedAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * if _stakedAmt is greater than or equals to 201000000000 then (returns dailyInterestRate1_2 as output)
 * if (20000000000 is less than or equals to _stakedAmt) and (_stakedAmt is less than or equals to 200000000000) then (returns dailyInterestRate1_1 as output)
 * returns dailyInterestRate1 as output
*/
	function consolidatedInterestRate1(uint256 _stakedAmt) public view returns (uint256) {
		if ((_stakedAmt >= uint256(201000000000))){
			return dailyInterestRate1_2;
		}
		if (((uint256(20000000000) <= _stakedAmt) && (_stakedAmt <= uint256(200000000000)))){
			return dailyInterestRate1_1;
		}
		return dailyInterestRate1;
	}

/**
 * Function modifyDailyInterestRate1
 * Notes for _dailyInterestRate : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _dailyInterestRate. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _dailyInterestRate
 * calls updateRecordsWithLatestInterestRates1
 * updates dailyInterestRate1 as _dailyInterestRate
*/
	function modifyDailyInterestRate1(uint256 _dailyInterestRate) public onlyOwner {
		require((uint256(0) < _dailyInterestRate), "Interest rate needs to be larger than 0%");
		updateRecordsWithLatestInterestRates1();
		dailyInterestRate1  = _dailyInterestRate;
	}

/**
 * Function modifyDailyInterestRate1_1
 * Notes for _dailyInterestRate : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _dailyInterestRate. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _dailyInterestRate
 * calls updateRecordsWithLatestInterestRates1
 * updates dailyInterestRate1_1 as _dailyInterestRate
*/
	function modifyDailyInterestRate1_1(uint256 _dailyInterestRate) public onlyOwner {
		require((uint256(0) < _dailyInterestRate), "Interest rate needs to be larger than 0%");
		updateRecordsWithLatestInterestRates1();
		dailyInterestRate1_1  = _dailyInterestRate;
	}

/**
 * Function modifyDailyInterestRate1_2
 * Notes for _dailyInterestRate : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _dailyInterestRate. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _dailyInterestRate
 * calls updateRecordsWithLatestInterestRates1
 * updates dailyInterestRate1_2 as _dailyInterestRate
*/
	function modifyDailyInterestRate1_2(uint256 _dailyInterestRate) public onlyOwner {
		require((uint256(0) < _dailyInterestRate), "Interest rate needs to be larger than 0%");
		updateRecordsWithLatestInterestRates1();
		dailyInterestRate1_2  = _dailyInterestRate;
	}

/**
 * Function stake2
 * Daily Interest Rate : Variable dailyInterestRate2
 * This interest rate is modified under certain circumstances, as articulated in the consolidatedInterestRate2 function
 * Minimum Stake Period : Variable minStakePeriod2
 * Address Map : informationAboutStakeScheme2
 * The function takes in 1 variable, (zero or a positive integer) _stakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that _stakeAmt is strictly greater than 0
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element the address that called this function
 * checks that ((_stakeAmt) + (thisRecord with element stakeAmt)) is less than or equals to maxStakeAmt2
 * checks that (thisRecord with element stakeAmt) is equals to 0
 * updates informationAboutStakeScheme2 (Element the address that called this function) as Struct comprising current time, _stakeAmt, current time, 0, 0
 * updates addressStore2 (Element numberOfAddressesCurrentlyStaked2) as the address that called this function
 * updates numberOfAddressesCurrentlyStaked2 as (numberOfAddressesCurrentlyStaked2) + (1)
 * calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _stakeAmt
 * calls addReferral with variable _amt as _stakeAmt
 * emits event Staked with inputs the address that called this function
*/
	function stake2(uint256 _stakeAmt) public {
		require((_stakeAmt > uint256(0)), "Staked amount needs to be greater than 0");
		record2 memory thisRecord = informationAboutStakeScheme2[msg.sender];
		require(((_stakeAmt + thisRecord.stakeAmt) <= maxStakeAmt2), "More than maximum stake amount");
		require((thisRecord.stakeAmt == uint256(0)), "Need to unstake before restaking");
		informationAboutStakeScheme2[msg.sender]  = record2 (block.timestamp, _stakeAmt, block.timestamp, uint256(0), uint256(0));
		addressStore2[numberOfAddressesCurrentlyStaked2]  = msg.sender;
		numberOfAddressesCurrentlyStaked2  = (numberOfAddressesCurrentlyStaked2 + uint256(1));
		ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transferFrom(msg.sender, address(this), _stakeAmt);
		addReferral(_stakeAmt);
		emit Staked(msg.sender);
	}

/**
 * Function unstake2
 * The function takes in 1 variable, (zero or a positive integer) _unstakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element the address that called this function
 * checks that _unstakeAmt is less than or equals to (thisRecord with element stakeAmt)
 * checks that ((current time) - (minStakePeriod2)) is greater than or equals to (thisRecord with element stakeTime)
 * creates an internal variable newAccum with initial value (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((current time) - (thisRecord with element lastUpdateTime)) * (consolidatedInterestRate2 with variable _stakedAmt as (thisRecord with element stakeAmt))) / (86400000000))
 * creates an internal variable interestToRemove with initial value ((newAccum) * (_unstakeAmt)) / (thisRecord with element stakeAmt)
 * updates principalAmtInBank0 as (principalAmtInBank0) + (((_unstakeAmt) * (taxDiversion0) * (principalWithdrawalTax2)) / (100000000))
 * updates principalAmtInBank as (principalAmtInBank) + (((_unstakeAmt) * (principalWithdrawalTax2) * ((100) - (taxDiversion0))) / (100000000))
 * if _unstakeAmt is equals to (thisRecord with element stakeAmt) then (repeat numberOfAddressesCurrentlyStaked2 times with loop variable i0 :  (if (addressStore2 with element Loop Variable i0) is equals to (the address that called this function) then (updates addressStore2 (Element Loop Variable i0) as addressStore2 with element (numberOfAddressesCurrentlyStaked2) - (1); then updates numberOfAddressesCurrentlyStaked2 as (numberOfAddressesCurrentlyStaked2) - (1); and then terminates the for-next loop)))
 * updates informationAboutStakeScheme2 (Element the address that called this function) as Struct comprising (thisRecord with element stakeTime), ((thisRecord with element stakeAmt) - (_unstakeAmt)), current time, ((newAccum) - (interestToRemove)), ((thisRecord with element amtWithdrawn) + (interestToRemove))
 * emits event Unstaked with inputs the address that called this function
 * checks that (ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((((_unstakeAmt) * ((1000000) - (principalWithdrawalTax2))) / (1000000)) + (interestToRemove))
 * if ((((_unstakeAmt) * ((1000000) - (principalWithdrawalTax2))) / (1000000)) + (interestToRemove)) is strictly greater than 0 then (calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transfer function  with variable recipient as (the address that called this function), variable amount as ((((_unstakeAmt) * ((1000000) - (principalWithdrawalTax2))) / (1000000)) + (interestToRemove)))
 * updates totalWithdrawals2 as (totalWithdrawals2) + (interestToRemove)
*/
	function unstake2(uint256 _unstakeAmt) public {
		record2 memory thisRecord = informationAboutStakeScheme2[msg.sender];
		require((_unstakeAmt <= thisRecord.stakeAmt), "Withdrawing more than staked amount");
		require(((block.timestamp - minStakePeriod2) >= thisRecord.stakeTime), "Insufficient stake period");
		uint256 newAccum = (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * consolidatedInterestRate2(thisRecord.stakeAmt)) / uint256(86400000000)));
		uint256 interestToRemove = ((newAccum * _unstakeAmt) / thisRecord.stakeAmt);
		principalAmtInBank0  = (principalAmtInBank0 + ((_unstakeAmt * taxDiversion0 * principalWithdrawalTax2) / uint256(100000000)));
		principalAmtInBank  = (principalAmtInBank + ((_unstakeAmt * principalWithdrawalTax2 * (uint256(100) - taxDiversion0)) / uint256(100000000)));
		if ((_unstakeAmt == thisRecord.stakeAmt)){
			for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked2; i0++){
				if ((addressStore2[i0] == msg.sender)){
					addressStore2[i0]  = addressStore2[(numberOfAddressesCurrentlyStaked2 - uint256(1))];
					numberOfAddressesCurrentlyStaked2  = (numberOfAddressesCurrentlyStaked2 - uint256(1));
					break;
				}
			}
		}
		informationAboutStakeScheme2[msg.sender]  = record2 (thisRecord.stakeTime, (thisRecord.stakeAmt - _unstakeAmt), block.timestamp, (newAccum - interestToRemove), (thisRecord.amtWithdrawn + interestToRemove));
		emit Unstaked(msg.sender);
		require((ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).balanceOf(address(this)) >= (((_unstakeAmt * (uint256(1000000) - principalWithdrawalTax2)) / uint256(1000000)) + interestToRemove)), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if (((((_unstakeAmt * (uint256(1000000) - principalWithdrawalTax2)) / uint256(1000000)) + interestToRemove) > uint256(0))){
			ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transfer(msg.sender, (((_unstakeAmt * (uint256(1000000) - principalWithdrawalTax2)) / uint256(1000000)) + interestToRemove));
		}
		totalWithdrawals2  = (totalWithdrawals2 + interestToRemove);
	}

/**
 * Function updateRecordsWithLatestInterestRates2
 * The function takes in 0 variables. It can only be called by other functions in this contract. It does the following :
 * repeat numberOfAddressesCurrentlyStaked2 times with loop variable i0 :  (creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element addressStore2 with element Loop Variable i0; and then updates informationAboutStakeScheme2 (Element addressStore2 with element Loop Variable i0) as Struct comprising (thisRecord with element stakeTime), (thisRecord with element stakeAmt), current time, ((thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((current time) - (thisRecord with element lastUpdateTime)) * (consolidatedInterestRate2 with variable _stakedAmt as (Loop Variable i0))) / (86400000000))), (thisRecord with element amtWithdrawn))
*/
	function updateRecordsWithLatestInterestRates2() internal {
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked2; i0++){
			record2 memory thisRecord = informationAboutStakeScheme2[addressStore2[i0]];
			informationAboutStakeScheme2[addressStore2[i0]]  = record2 (thisRecord.stakeTime, thisRecord.stakeAmt, block.timestamp, (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * consolidatedInterestRate2(i0)) / uint256(86400000000))), thisRecord.amtWithdrawn);
		}
	}

/**
 * Function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2
 * The function takes in 1 variable, (an address) _address. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element _address
 * returns (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((current time) - (thisRecord with element lastUpdateTime)) * (consolidatedInterestRate2 with variable _stakedAmt as (thisRecord with element stakeAmt))) / (86400000000)) as output
*/
	function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(address _address) public view returns (uint256) {
		record2 memory thisRecord = informationAboutStakeScheme2[_address];
		return (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * consolidatedInterestRate2(thisRecord.stakeAmt)) / uint256(86400000000)));
	}

/**
 * Function totalStakedAmount2
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfAddressesCurrentlyStaked2 times with loop variable i0 :  (creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element addressStore2 with element Loop Variable i0; and then updates total as (total) + (thisRecord with element stakeAmt))
 * returns total as output
*/
	function totalStakedAmount2() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked2; i0++){
			record2 memory thisRecord = informationAboutStakeScheme2[addressStore2[i0]];
			total  = (total + thisRecord.stakeAmt);
		}
		return total;
	}

/**
 * Function totalAccumulatedInterest2
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfAddressesCurrentlyStaked2 times with loop variable i0 :  (updates total as (total) + (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2 with variable _address as (addressStore2 with element Loop Variable i0)))
 * returns total as output
*/
	function totalAccumulatedInterest2() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked2; i0++){
			total  = (total + interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(addressStore2[i0]));
		}
		return total;
	}

/**
 * Function withdrawInterestWithoutUnstaking2
 * The function takes in 1 variable, (zero or a positive integer) _withdrawalAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable totalInterestEarnedTillNow with initial value interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2 with variable _address as (the address that called this function)
 * checks that _withdrawalAmt is less than or equals to totalInterestEarnedTillNow
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element the address that called this function
 * updates informationAboutStakeScheme2 (Element the address that called this function) as Struct comprising (thisRecord with element stakeTime), (thisRecord with element stakeAmt), current time, ((totalInterestEarnedTillNow) - (_withdrawalAmt)), ((thisRecord with element amtWithdrawn) + (_withdrawalAmt))
 * checks that (ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _withdrawalAmt
 * if _withdrawalAmt is strictly greater than 0 then (calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _withdrawalAmt)
 * updates totalWithdrawals2 as (totalWithdrawals2) + (_withdrawalAmt)
*/
	function withdrawInterestWithoutUnstaking2(uint256 _withdrawalAmt) public {
		uint256 totalInterestEarnedTillNow = interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(msg.sender);
		require((_withdrawalAmt <= totalInterestEarnedTillNow), "Withdrawn amount must be less than withdrawable amount");
		record2 memory thisRecord = informationAboutStakeScheme2[msg.sender];
		informationAboutStakeScheme2[msg.sender]  = record2 (thisRecord.stakeTime, thisRecord.stakeAmt, block.timestamp, (totalInterestEarnedTillNow - _withdrawalAmt), (thisRecord.amtWithdrawn + _withdrawalAmt));
		require((ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).balanceOf(address(this)) >= _withdrawalAmt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_withdrawalAmt > uint256(0))){
			ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transfer(msg.sender, _withdrawalAmt);
		}
		totalWithdrawals2  = (totalWithdrawals2 + _withdrawalAmt);
	}

/**
 * Function withdrawAllInterestWithoutUnstaking2
 * The function takes in 0 variables. It can only be called by functions outside of this contract. It does the following :
 * calls withdrawInterestWithoutUnstaking2 with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2 with variable _address as (the address that called this function))
*/
	function withdrawAllInterestWithoutUnstaking2() external {
		withdrawInterestWithoutUnstaking2(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(msg.sender));
	}

/**
 * Function consolidatedInterestRate2
 * The function takes in 1 variable, (zero or a positive integer) _stakedAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * if _stakedAmt is greater than or equals to 251000000000 then (returns dailyInterestRate2_2 as output)
 * if (50000000000 is less than or equals to _stakedAmt) and (_stakedAmt is less than or equals to 250000000000) then (returns dailyInterestRate2_1 as output)
 * returns dailyInterestRate2 as output
*/
	function consolidatedInterestRate2(uint256 _stakedAmt) public view returns (uint256) {
		if ((_stakedAmt >= uint256(251000000000))){
			return dailyInterestRate2_2;
		}
		if (((uint256(50000000000) <= _stakedAmt) && (_stakedAmt <= uint256(250000000000)))){
			return dailyInterestRate2_1;
		}
		return dailyInterestRate2;
	}

/**
 * Function modifyDailyInterestRate2
 * Notes for _dailyInterestRate : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _dailyInterestRate. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _dailyInterestRate
 * calls updateRecordsWithLatestInterestRates2
 * updates dailyInterestRate2 as _dailyInterestRate
*/
	function modifyDailyInterestRate2(uint256 _dailyInterestRate) public onlyOwner {
		require((uint256(0) < _dailyInterestRate), "Interest rate needs to be larger than 0%");
		updateRecordsWithLatestInterestRates2();
		dailyInterestRate2  = _dailyInterestRate;
	}

/**
 * Function modifyDailyInterestRate2_1
 * Notes for _dailyInterestRate : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _dailyInterestRate. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _dailyInterestRate
 * calls updateRecordsWithLatestInterestRates2
 * updates dailyInterestRate2_1 as _dailyInterestRate
*/
	function modifyDailyInterestRate2_1(uint256 _dailyInterestRate) public onlyOwner {
		require((uint256(0) < _dailyInterestRate), "Interest rate needs to be larger than 0%");
		updateRecordsWithLatestInterestRates2();
		dailyInterestRate2_1  = _dailyInterestRate;
	}

/**
 * Function modifyDailyInterestRate2_2
 * Notes for _dailyInterestRate : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _dailyInterestRate. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _dailyInterestRate
 * calls updateRecordsWithLatestInterestRates2
 * updates dailyInterestRate2_2 as _dailyInterestRate
*/
	function modifyDailyInterestRate2_2(uint256 _dailyInterestRate) public onlyOwner {
		require((uint256(0) < _dailyInterestRate), "Interest rate needs to be larger than 0%");
		updateRecordsWithLatestInterestRates2();
		dailyInterestRate2_2  = _dailyInterestRate;
	}

/**
 * Function principalTaxWithdrawAmt0
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that (the address that called this function) is equals to Address 0xaC6d0ec3F2bdC250c61eE638B1635506Ac6546D6
 * checks that (ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to principalAmtInBank0
 * if principalAmtInBank0 is strictly greater than 0 then (calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transfer function  with variable recipient as (the address that called this function), variable amount as principalAmtInBank0)
 * updates principalAmtInBank0 as 0
*/
	function principalTaxWithdrawAmt0() public {
		require((msg.sender == address(0xaC6d0ec3F2bdC250c61eE638B1635506Ac6546D6)), "Not the withdrawal address");
		require((ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).balanceOf(address(this)) >= principalAmtInBank0), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((principalAmtInBank0 > uint256(0))){
			ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transfer(msg.sender, principalAmtInBank0);
		}
		principalAmtInBank0  = uint256(0);
	}

/**
 * Function principalTaxWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to principalAmtInBank
 * if principalAmtInBank is strictly greater than 0 then (calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transfer function  with variable recipient as (the address that called this function), variable amount as principalAmtInBank)
 * updates principalAmtInBank as 0
*/
	function principalTaxWithdrawAmt() public onlyOwner {
		require((ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).balanceOf(address(this)) >= principalAmtInBank), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((principalAmtInBank > uint256(0))){
			ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transfer(msg.sender, principalAmtInBank);
		}
		principalAmtInBank  = uint256(0);
	}

/**
 * Function withdrawToken
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((_amt) + (totalUnclaimedRewards) + (totalAccumulatedInterest1) + (totalAccumulatedInterest2) + (principalAmtInBank0) + (principalAmtInBank) + (totalStakedAmount1) + (totalStakedAmount2))
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	function withdrawToken(uint256 _amt) public onlyOwner {
		require((ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).balanceOf(address(this)) >= (_amt + totalUnclaimedRewards + totalAccumulatedInterest1() + totalAccumulatedInterest2() + principalAmtInBank0 + principalAmtInBank + totalStakedAmount1() + totalStakedAmount2())), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0x273aDa5300b3a32cB10aAD2b7960e4C5fd8BF345)).transfer(msg.sender, _amt);
		}
	}
}