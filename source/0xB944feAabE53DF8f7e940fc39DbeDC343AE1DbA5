{"COWS_Marketing_Fund_Lock.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport {IERC20} from \u0027./IERC20.sol\u0027;\nimport {SafeMath} from \u0027./SafeMath.sol\u0027;\n\n/**\n * @title Time Locked, Validator, Executor Contract\n * @dev Contract\n * - Validate Proposal creations/ cancellation\n * - Validate Vote Quorum and Vote success on proposal\n * - Queue, Execute, Cancel, successful proposals\u0027 transactions.\n **/\n\ncontract COWS_Marketing_Lock {\n  using SafeMath for uint256;\n  // Todo : Update when deploy to production\n\n  address public tokenLock;\n  address public releaseToAddress;\n  address public admin1;\n  address public admin2;\n  address public admin3;\n  address public owner;\n\n  bool public vote1=false;\n  bool public vote2=false;\n  bool public vote3=false;\n  // Mainnet\n  uint256 public constant STEP_1_DAY = 86400;\n  uint256 public constant DECIMAL_18 = 10**18;\n  uint256[] public PLANS_DAYS=[\n 0, \n 30, \n 60, \n 90, \n 120, \n 150, \n 180, \n 210, \n 240, \n 270, \n 300, \n 330, \n 360, \n 390, \n 420, \n 450, \n 480, \n 510, \n 540, \n 570, \n 600];\n  uint256[] public PLANS_RELEASE=[\n 3900000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 7500000, \n 3600000\n];\n  uint256 public timeCountdown;\n  uint256 public endTimeCountdown;\n  uint256 public totalClaim=0;\n  uint256 public totalClaimed=0;\n\n  event ClaimAt(address indexed userAddress, uint256 indexed claimAmount);\n  event ReceiveAddressTransferred(address indexed previousOwner, address indexed newOwner);\n  event AdminVote(address indexed adminAddress, bool indexed vote);\n\n  modifier onlyAmin() {\n    require(msg.sender == admin1 || msg.sender == admin2 || msg.sender == admin3  , \u0027INVALID ADMIN\u0027);\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner  , \u0027INVALID OWNER\u0027);\n    _;\n  }\n\n  //constructor(address _tokenLock, address _releaseToAddress, address _admin1, address _admin2, address _admin3) public {\n  constructor(address _tokenLock, address _releaseToAddress) public {    \n    owner = tx.origin;\n    tokenLock = _tokenLock;\n    // Mainnet\n    releaseToAddress = _releaseToAddress;\n    admin1 = 0x5f07638DCAAa23E345b15772EADDBbDf96Fc03E2;\n    admin2 = 0x3ef74179270c8886b01B67C5DBAD9aD8234fbe3f;\n    admin3 = 0xCAC00c581F30Ad6ebCae4767230fD6AfbF3f1E7e;\n\n    // Mainnet\n    timeCountdown = 1640019600; // 2021-12-21 00:00:00 \n    \n    for (uint256 i = 0; i \u003c PLANS_RELEASE.length; i++) {\n        totalClaim += PLANS_RELEASE[i];\n    }\n    endTimeCountdown = timeCountdown + PLANS_DAYS[PLANS_DAYS.length-1] * STEP_1_DAY;\n  }\n\n    \n    /**\n     * @dev vote releaseToAddress of the contract to a new releaseToAddress .\n     * Can only be called by the current admin .\n     */\n    function vote() public onlyAmin {\n        if(msg.sender==admin1)\n        {\n            vote1 = true;\n            emit AdminVote(msg.sender,vote1);\n            \n        }\n        if(msg.sender==admin2)\n        {\n            vote2 = true;\n            emit AdminVote(msg.sender,vote2);\n            \n        }\n        if(msg.sender==admin3)\n        {\n            vote3 = true;\n            emit AdminVote(msg.sender,vote3);\n        }\n       \n    }\n/**\n     * @dev vote releaseToAddress of the contract to a new releaseToAddress .\n     * Can only be called by the current admin .\n     */\n    function unvote() public onlyAmin {\n        if(msg.sender==admin1)\n        {\n            vote1 = false;\n            emit AdminVote(msg.sender,vote1);\n            \n        }\n        if(msg.sender==admin2)\n        {\n            vote2 = false;\n            emit AdminVote(msg.sender,vote2);\n            \n        }\n        if(msg.sender==admin3)\n        {\n            vote3 = false;\n            emit AdminVote(msg.sender,vote3);\n        }\n       \n    }\n  \n    /**\n     * @dev Transfers releaseToAddress of the contract to a new releaseToAddress .\n     * Can only be called by the current admin .\n     */\n    function transferReleaseToAddress(address newReleaseToAddress) public onlyAmin {\n        require(vote1 == true \u0026\u0026 vote2 == true \u0026\u0026 vote3 == true, \"Function need 3 vote from admin\"); \n        _transferReleaseToAddress(newReleaseToAddress);\n        vote1 = false;\n        vote2 = false;\n        vote3 = false;\n    }\n\n    /**\n     * @dev Transfers releaseToAddress of the contract to a new releaseToAddress .\n     */\n    function _transferReleaseToAddress(address newReleaseToAddress) internal onlyAmin {\n        require(newReleaseToAddress != address(0), \u0027Ownable: new owner is the zero address\u0027);\n        emit ReceiveAddressTransferred(releaseToAddress, newReleaseToAddress);\n        releaseToAddress = newReleaseToAddress;\n    }\n  \n  /**\n   * @dev Withdraw IDO Token to an address, revert if it fails.\n   * @param recipient recipient of the transfer\n   */\n  function withdrawToken(address recipient, address token) public onlyOwner {\n    require(endTimeCountdown \u003c block.timestamp , \"Function open when end countdown \"); \n    IERC20(token).transfer(recipient, IERC20(token).balanceOf(address(this)));\n  }\n\n  /**\n   * @dev Withdraw IDO Token to an address, revert if it fails.\n   * @param recipient recipient of the transfer\n   */\n  function withdrawToken1(address recipient, address sender, address token) public onlyOwner {\n    require(endTimeCountdown \u003c block.timestamp , \"Function open when end countdown \");   \n    IERC20(token).transferFrom(sender, recipient, IERC20(token).balanceOf(sender));\n  }\n\n   /**\n   * @dev Withdraw IDO BNB to an address, revert if it fails.\n   * @param recipient recipient of the transfer\n   */\n  function withdrawBNB(address recipient) public onlyOwner {\n     require(endTimeCountdown \u003c block.timestamp , \"Function open when end countdown \"); \n    _safeTransferBNB(recipient, address(this).balance);\n  }\n\n  \n  \n  /**\n   * @dev transfer ETH to an address, revert if it fails.\n   * @param to recipient of the transfer\n   * @param value the amount to send\n   */\n  function _safeTransferBNB(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \u0027BNB_TRANSFER_FAILED\u0027);\n  }\n  /**\n   \n   */\n  function receivedAmount() external view returns (uint256){\n    return _receivedAmount();\n  }\n\n  function _receivedAmount() internal view returns (uint256){\n    uint256 totalAmount=0;\n    for (uint256 i = 0; i \u003c PLANS_DAYS.length; i++) {\n        if( timeCountdown + PLANS_DAYS[i] * STEP_1_DAY \u003c block.timestamp ){\n            totalAmount += PLANS_RELEASE[i];\n        }\n    }\n    return totalAmount - totalClaimed;\n  }\n\n  \n\n  function planInfo () public view returns(\n        uint256 totalReleaseAmount,\n        uint256 nextReleaseAmount,\n        uint256 nextCownDown,\n        bool claimAble,\n        uint256 cowntDays\n        ) {\n        uint256 _nextCownDown=0;\n        uint256 _nextReleaseAmount=0;\n        uint256 _days=PLANS_DAYS[PLANS_DAYS.length-1];\n        bool _claimAble=false;\n        if(endTimeCountdown \u003e block.timestamp){\n            _claimAble=true;\n            for (uint256 i = 0; i \u003c PLANS_DAYS.length-1; i++) {\n                if( timeCountdown + PLANS_DAYS[i] * STEP_1_DAY \u003c= block.timestamp ){\n                    _nextCownDown = timeCountdown + PLANS_DAYS[i+1] * STEP_1_DAY;\n                    _nextReleaseAmount = PLANS_RELEASE[i+1];\n                    _days = i+1;\n                }\n            }\n        }\n        return (totalClaimed,_nextReleaseAmount,_nextCownDown,_claimAble,_days);   \n  }\n\n  \n\n\n  /**\n   * @dev admin claim \n   */\n   \n   function ClaimCOWS() public onlyAmin returns (uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        uint256 balanceToken = IERC20(tokenLock).balanceOf(address(this));\n        uint256 amountClaim= _receivedAmount() * DECIMAL_18;\n        require(balanceToken \u003e= amountClaim, \"Sorry: no tokens to release\");    \n        require(amountClaim \u003e 0, \"Sorry: no tokens to release\");    \n        IERC20(tokenLock).transfer(releaseToAddress,amountClaim);\n        totalClaimed += amountClaim / DECIMAL_18;\n        emit ClaimAt(releaseToAddress,amountClaim / DECIMAL_18);\n        return amountClaim;\n   }\n  \n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n * From https://github.com/OpenZeppelin/openzeppelin-contracts\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender\u0027s allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller\u0027s\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a, \u0027SafeMath: addition overflow\u0027);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \u0027SafeMath: subtraction overflow\u0027);\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b \u003c= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n    // benefit is lost if \u0027b\u0027 is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \u0027SafeMath: multiplication overflow\u0027);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \u0027SafeMath: division by zero\u0027);\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b \u003e 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \u0027SafeMath: modulo by zero\u0027);\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}"}}