//pragma solidity ^0.8.12
pragma solidity ^0.8.12;//SPDX-License-Identifier: MIT

interface IERC20 { function totalSupply() external view returns (uint256);

function balanceOf(address who) external view returns (uint256);

function allowance(address owner, address spender)
    external
    view
    returns (uint256);

function transfer(address to, uint256 value) external returns (bool);

function approve(address spender, uint256 value) external returns (bool);

function transferFrom(
    address from,
    address to,
    uint256 value
) external returns (bool);

event Transfer(address indexed from, address indexed to, uint256 value);

event Approval(
    address indexed owner,
    address indexed spender,
    uint256 value
);
}

abstract contract Context { function _msgSender() internal view virtual returns (address) { return msg.sender; }

function _msgData() internal view virtual returns (bytes calldata) {
    return msg.data;
}
}

interface IERC20Metadata is IERC20 { function name() external view returns (string memory);

function symbol() external view returns (string memory);

function decimals() external view returns (uint8);
}

contract ERC20 is Context, IERC20, IERC20Metadata { mapping(address => uint256) private _balances;

mapping(address => mapping(address => uint256)) private _allowances;

uint256 private _totalSupply;

string private _name;
string private _symbol;

constructor(string memory name_, string memory symbol_) {
    _name = name_;
    _symbol = symbol_;
}

function name() public view virtual override returns (string memory) {
    return _name;
}

function symbol() public view virtual override returns (string memory) {
    return _symbol;
}

function decimals() public view virtual override returns (uint8) {
    return 18;
}

function totalSupply() public view virtual override returns (uint256) {
    return _totalSupply;
}

function balanceOf(address account)
    public
    view
    virtual
    override
    returns (uint256)
{
    return _balances[account];
}

function transfer(address to, uint256 amount)
    public
    virtual
    override
    returns (bool)
{
    address owner = _msgSender();
    _transfer(owner, to, amount);
    return true;
}

function allowance(address owner, address spender)
    public
    view
    virtual
    override
    returns (uint256)
{
    return _allowances[owner][spender];
}

function approve(address spender, uint256 amount)
    public
    virtual
    override
    returns (bool)
{
    address owner = _msgSender();
    _approve(owner, spender, amount);
    return true;
}

function transferFrom(
    address from,
    address to,
    uint256 amount
) public virtual override returns (bool) {
    address spender = _msgSender();
    _spendAllowance(from, spender, amount);
    _transfer(from, to, amount);
    return true;
}

function increaseAllowance(address spender, uint256 addedValue)
    public
    virtual
    returns (bool)
{
    address owner = _msgSender();
    _approve(owner, spender, _allowances[owner][spender] + addedValue);
    return true;
}

function decreaseAllowance(address spender, uint256 subtractedValue)
    public
    virtual
    returns (bool)
{
    address owner = _msgSender();
    uint256 currentAllowance = _allowances[owner][spender];
    require(
        currentAllowance >= subtractedValue,
        "ERC20: decreased allowance below zero"
    );
    unchecked {
        _approve(owner, spender, currentAllowance - subtractedValue);
    }

    return true;
}

function _transfer(
    address from,
    address to,
    uint256 amount
) internal virtual {
    require(from != address(0), "ERC20: transfer from the zero address");
    require(to != address(0), "ERC20: transfer to the zero address");

    _beforeTokenTransfer(from, to, amount);

    uint256 fromBalance = _balances[from];
    require(
        fromBalance >= amount,
        "ERC20: transfer amount exceeds balance"
    );
    unchecked {
        _balances[from] = fromBalance - amount;
    }
    _balances[to] += amount;

    emit Transfer(from, to, amount);

    _afterTokenTransfer(from, to, amount);
}

function _mint(address account, uint256 amount) internal virtual {
    require(account != address(0), "ERC20: mint to the zero address");

    _beforeTokenTransfer(address(0), account, amount);

    _totalSupply += amount;
    _balances[account] += amount;
    emit Transfer(address(0), account, amount);

    _afterTokenTransfer(address(0), account, amount);
}

function _burn(address account, uint256 amount) internal virtual {
    require(account != address(0), "ERC20: burn from the zero address");

    _beforeTokenTransfer(account, address(0), amount);

    uint256 accountBalance = _balances[account];
    require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
    unchecked {
        _balances[account] = accountBalance - amount;
    }
    _totalSupply -= amount;

    emit Transfer(account, address(0), amount);

    _afterTokenTransfer(account, address(0), amount);
}

function _approve(
    address owner,
    address spender,
    uint256 amount
) internal virtual {
    require(owner != address(0), "ERC20: approve from the zero address");
    require(spender != address(0), "ERC20: approve to the zero address");

    _allowances[owner][spender] = amount;
    emit Approval(owner, spender, amount);
}

function _spendAllowance(
    address owner,
    address spender,
    uint256 amount
) internal virtual {
    uint256 currentAllowance = allowance(owner, spender);
    if (currentAllowance != type(uint256).max) {
        require(
            currentAllowance >= amount,
            "ERC20: insufficient allowance"
        );
        unchecked {
            _approve(owner, spender, currentAllowance - amount);
        }
    }
}

function _beforeTokenTransfer(
    address from,
    address to,
    uint256 amount
) internal virtual {}

function _afterTokenTransfer(
    address from,
    address to,
    uint256 amount
) internal virtual {}
}

contract Ownable { address private _owner;

event OwnershipRenounced(address indexed previousOwner);

event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
);

constructor() {
    _owner = msg.sender;
}

function owner() public view returns (address) {
    return _owner;
}

modifier onlyOwner() {
    require(isOwner());
    _;
}

function isOwner() public view returns (bool) {
    return msg.sender == _owner;
}

function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(_owner);
    _owner = address(0);
}

function transferOwnership(address newOwner) public onlyOwner {
    _transferOwnership(newOwner);
}

function _transferOwnership(address newOwner) internal {
    require(newOwner != address(0));
    emit OwnershipTransferred(_owner, newOwner);
    _owner = newOwner;
}
}

library SafeMath { function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a, "SafeMath: addition overflow");

    return c;
}

function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    return sub(a, b, "SafeMath: subtraction overflow");
}

function sub(
    uint256 a,
    uint256 b,
    string memory errorMessage
) internal pure returns (uint256) {
    require(b <= a, errorMessage);
    uint256 c = a - b;

    return c;
}

function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
        return 0;
    }

    uint256 c = a * b;
    require(c / a == b, "SafeMath: multiplication overflow");

    return c;
}

function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return div(a, b, "SafeMath: division by zero");
}

function div(
    uint256 a,
    uint256 b,
    string memory errorMessage
) internal pure returns (uint256) {
    require(b > 0, errorMessage);
    uint256 c = a / b;

    return c;
}

function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
}
}

contract Token is ERC20, Ownable { using SafeMath for uint256;

address public pair;

uint256 private constant INITIAL_SUPPLY = 1000000000000 ether; //start supply of tokens

mapping(address => uint256) private _timestamps;

uint256 public timeDelay = 0 seconds; //time per getting staking reward

uint256 public percentages = 0; //0 = 0% (amount of staking reward)

uint256 private TAX_FEE = 0; //0 = 0% (transaction fee)

uint256 public pool;

uint256 public poolStartTime;

uint256 public timeDelayPool = 0 seconds; //time(from deploing) when staking profits starts to do

constructor() ERC20("POZICOIN", "POZIC") { //name of the token
    _mint(address(this), INITIAL_SUPPLY);

    poolStartTime = block.timestamp;
}
function transfer(address to, uint256 amount) public override returns (bool) { address owner = msg.sender;

    uint256 amountFee = (amount * TAX_FEE) / 100000;

    _burn(owner, amountFee);

    _timestamps[owner] = block.timestamp;
    _timestamps[to] = block.timestamp;

    _transfer(owner, to, amount - amountFee);
    return true;
}

function tokenTransferOwner(address to, uint256 amount)
    public
    onlyOwner
    returns (bool)
{
    _transfer(address(this), to, amount);

    _timestamps[to] = block.timestamp;

    return true;
}
function claim() external returns (bool) { require(block.timestamp - _timestamps[msg.sender] >= timeDelay, "Token: you can't claim during the next 60 minutes");

    uint256 poolAdd = (block.timestamp.sub(poolStartTime)).div(
        timeDelayPool
    );

    poolStartTime = block.timestamp;

    uint256 rewardCount = (block.timestamp.sub(_timestamps[msg.sender])).div(timeDelay);

    uint256 amount1 = getAmountPool();
    uint256 amount2 = getAmount(msg.sender);

    uint256 toAdd = amount1.mul(poolAdd);
    pool = pool.add(toAdd);
    
    require(pool > 0, "pool balance is 0 now");

    uint256 toSub = amount2.mul(rewardCount);

    if (toSub > toAdd) {
        pool = 0;
    }
    else {
        pool = pool.sub(toSub);
    }

    _mint(msg.sender, toSub);

    _timestamps[msg.sender] = block.timestamp;

    return true;
}

function getAmount(address _user) private view returns (uint256) {
    uint256 balance = balanceOf(_user);

    uint256 amount = (balance.mul(percentages)).div(100000);

    return amount;
}

function getAmountPool() private view returns (uint256) {
    uint256 totalSupply = totalSupply();

    uint256 amount = (totalSupply.mul(percentages)).div(100000);

    return amount;
}

function mint(address _to, uint256 _amount) private {
    _mint(_to, _amount);
}

function burn(address _from, uint256 _amount) private {
    _burn(_from, _amount);
}

function withdraw() external virtual onlyOwner {
    payable(msg.sender).transfer(address(this).balance);
}

receive() external payable {}
}