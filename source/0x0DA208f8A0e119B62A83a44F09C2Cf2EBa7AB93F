{"CryptoForSpeedToken.sol":{"content":"pragma solidity =0.6.6;\n\nimport \"IERC20.sol\";\nimport \"SafeMath.sol\";\nimport \"IAddressManager.sol\";\nimport \"Z_CryptoForSpeedGlobalImpl.sol\";\n\nabstract contract CryptoForSpeedCFSFee {\n    function swapCFS() external virtual returns (bool);\n}\n\n//erc20 token\ncontract A_CryptoForSpeedToken is CryptoForSpeedGlobalImpl, IERC20 {\n    IAddressManager public addressManager;\n    bool public pause = false;\n\n    string  _name;\n    string  _symbol;\n    uint8  _decimals;\n    // max supply\n    uint256 _totalSupply;\n    // current supply\n    uint256 public currentSupply = 0;\n    // for minters\n    mapping(address =\u003e bool) public _minters;\n\n    mapping(address =\u003e uint256) balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) internal allowed;\n\n    // transfer fee, ten thousandth ratio\n    uint256 public fee = 500;\n    mapping(address =\u003e bool) public noFeeAddress;\n\n    event Mint(address indexed to, uint256 amount);\n    event Burn(address indexed account, uint256 amount);\n\n    constructor(address _addressManager) public {\n        addressManager = IAddressManager(_addressManager);\n        _decimals = 18;\n        _symbol = \"CFS\";\n        _name = \"CFS Token\";\n        //100,000,000 token\n        _totalSupply = 100000000 * (10 ** uint256(_decimals));\n        noFeeAddress[address(this)] = true;\n        noFeeAddress[msg.sender] = true;\n        noFeeAddress[addressManager.getAddress(\"CFSTokenFeeAddress\")] = true;\n    }\n\n    modifier onlyMinter() {\n        require(_minters[msg.sender], \"!minter\");\n        _;\n    }\n\n    modifier notPaused() {\n        require(!pause, \"paused\");\n        _;\n    }\n\n    function setAddressManagerAddress(address _addressManager) onlyOwner public {\n        addressManager = IAddressManager(_addressManager);\n    }\n\n    function setPause(bool b) onlyOwner public {\n        pause = b;\n    }\n\n    function name() public override view returns (string memory){\n        return _name;\n    }\n\n    function symbol() public override view returns (string memory){\n        return _symbol;\n    }\n\n    function decimals() public override view returns (uint8){\n        return _decimals;\n    }\n\n    function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _owner) override public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) override public notPaused returns (bool) {\n        require(_to != address(0));\n        require(_value \u003c= balances[msg.sender]);\n\n        _transfer(msg.sender, _to, _value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) override public notPaused returns (bool){\n        require(_to != address(0));\n        require(_value \u003c= balances[_from]);\n        require(_value \u003c= allowed[_from][msg.sender]);\n\n        _transfer(_from, _to, _value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = balances[_from].sub(_value);\n        if (noFeeAddress[_from] || noFeeAddress[_to]) {\n            balances[_to] = balances[_to].add(_value);\n        } else {\n            uint256 _fee = _value.mul(fee).div(10000);\n            uint256 _realValue = _value.sub(_fee);\n            balances[_to] = balances[_to].add(_realValue);\n            address feeTo = addressManager.getAddress(\"CFSTokenFeeAddress\");\n            balances[feeTo] = balances[feeTo].add(_fee);\n            CryptoForSpeedCFSFee(feeTo).swapCFS();\n        }\n    }\n\n    function approve(address _spender, uint256 _value) override public notPaused returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) override public view returns (uint256){\n        return allowed[_owner][_spender];\n    }\n\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool)    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool)    {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue \u003e oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n\n    function addMinter(address minter) public onlyOwner {\n        _minters[minter] = true;\n    }\n\n    function removeMinter(address minter) public onlyOwner {\n        _minters[minter] = false;\n    }\n\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address _to, uint256 _amount) onlyMinter public returns (bool)    {\n        uint256 tmpTotal = currentSupply.add(_amount);\n        require(tmpTotal \u003c= _totalSupply, \"mint too much\");\n        currentSupply = currentSupply.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n    /**\n     * @dev Destroys `_amount` tokens from `_account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must have at least `_amount` tokens.\n     */\n    function burn(address _account, uint256 _amount) onlyMinter public returns (bool)  {\n        require(_account != address(0), \"BEP20: burn from the zero address\");\n\n        balances[_account] = balances[_account].sub(_amount);\n        currentSupply = currentSupply.sub(_amount);\n        emit Burn(_account, _amount);\n        emit Transfer(_account, address(0), _amount);\n        return true;\n    }\n\n    /**\n     * @dev Function to set fee\n     * @param _fee The fee.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function setFee(uint256 _fee) onlyOwner public returns (bool)    {\n        fee = _fee;\n        return true;\n    }\n    /**\n     * @dev Function to add no fee accounts\n     * @param addr The address that will add to noFeeAddress.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function addNoFeeAddress(address addr) onlyOwner public returns (bool)    {\n        require(!noFeeAddress[addr], \"Already in the list\");\n        noFeeAddress[addr] = true;\n        return true;\n    }\n    /**\n     * @dev Function to remove no fee accounts\n     * @param addr The address that will remove from noFeeAddress.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function removeNoFeeAddress(address addr) onlyOwner public returns (bool)    {\n        require(noFeeAddress[addr], \"Not in the list\");\n        noFeeAddress[addr] = false;\n        return true;\n    }\n}"},"IAddressManager.sol":{"content":"pragma solidity =0.6.6;\n\ninterface IAddressManager {\n    function setAddress(string calldata key, address addr) external;\n\n    function getAddress(string calldata key) external view returns (address);\n\n    function getAddressPayable(string calldata key) external view returns (address payable);\n}\n"},"IERC20.sol":{"content":"pragma solidity =0.6.6;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}"},"SafeMath.sol":{"content":"pragma solidity =0.6.6;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n"},"Z_CryptoForSpeedGlobalImpl.sol":{"content":"pragma solidity =0.6.6;\n\nimport \"IERC20.sol\";\nimport \"SafeMath.sol\";\n\n/**\n * @title Helps contracts guard agains reentrancy attacks.\n * @author Remco Bloemen \u003cremco@2Ï€.com\u003e\n * @notice If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n\n    /**\n     * @dev We use a single lock for the whole contract.\n     */\n    bool private reentrancyLock = false;\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * @notice If you mark a function `nonReentrant`, you should also\n     * mark it `external`. Calling one nonReentrant function from\n     * another is not supported. Instead, you can implement a\n     * `private` function doing the actual work, and a `external`\n     * wrapper marked as `nonReentrant`.\n     */\n    modifier nonReentrant() {\n        require(!reentrancyLock);\n        reentrancyLock = true;\n        _;\n        reentrancyLock = false;\n    }\n\n}\n\ncontract CryptoForSpeedGlobalImpl {\n\n    using SafeMath for uint256;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner address can call this\");\n        _;\n    }\n\n    function withdrawBNB() public onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    function withdrawBEP20(address bep20TokenAddress) public onlyOwner returns (bool){\n        IERC20 erc20 = IERC20(bep20TokenAddress);\n        uint256 balance = erc20.balanceOf(address(this));\n        return erc20.transfer(owner, balance);\n    }\n\n\n    receive() payable external {}\n\n    fallback() payable external {}\n\n}\n\n"}}