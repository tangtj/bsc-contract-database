pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Jackpot
*/

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract Lottery {

	address owner;
	bool public paused = false;
	address[] public players;
	address[] public winners;
	uint256 public playerLimit = uint256(100);
	uint256 public taxRate = uint256(100000);
	uint256 public jackpotNativePrice = uint256(10000000000000000);
	uint256 public retainedForJackpotNative = uint256(0);
	uint256 public jackpotCoinPrice0 = uint256(1000000000000000000);
	uint256 public retainedForJackpotCoin0 = uint256(0);
	uint256 public jackpotCoinPrice1 = uint256(10000000000000000000);
	uint256 public retainedForJackpotCoin1 = uint256(0);
	event JackpotEntered (address indexed participatingAddress, uint256 indexed participationNumber);
	event JackpotDone (address indexed winningAddress);

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

    function getPlayerCount() external view returns (uint256) {
        return players.length;
    }
    
	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	function random(uint256 input) internal view returns (uint256) {
		return
			uint256(
				keccak256(
					abi.encodePacked(
						block.timestamp +
							block.difficulty +
							block.gaslimit +
							block.number +
							input +
							((
								uint256(
									keccak256(abi.encodePacked(block.coinbase))
								)
							) / block.timestamp) 
							
					)
				)
			);
	}

/**
 * Function changeValueOf_paused
 * Notes for _paused : Toggle to pause lottery
 * The function takes in 1 variable, (a boolean) _paused. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates paused as _paused
*/
	function changeValueOf_paused(bool _paused) external onlyOwner {
		paused  = _paused;
	}

/**
 * Function changeValueOf_playerLimit
 * Notes for _playerLimit : Change the number of players in the lottery.
 * The function takes in 1 variable, (zero or a positive integer) _playerLimit. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (length of players) is equals to 0
 * updates playerLimit as _playerLimit
*/
	function changeValueOf_playerLimit(uint256 _playerLimit) external onlyOwner {
		require(((players).length == uint256(0)), "Can only be changed if there are zero players in the pool");
		playerLimit  = _playerLimit;
	}

/**
 * Function changeValueOf_taxRate
 * Notes for _taxRate : Change the tax rate in the lottery. 10000 is 1%.
 * The function takes in 1 variable, (zero or a positive integer) _taxRate. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (length of players) is equals to 0
 * updates taxRate as _taxRate
*/
	function changeValueOf_taxRate(uint256 _taxRate) external onlyOwner {
		require(((players).length == uint256(0)), "Can only be changed if there are zero players in the pool");
		taxRate  = _taxRate;
	}

/**
 * Function changeValueOf_jackpotNativePrice
 * Notes for _jackpotNativePrice : 10^18 represents 1 native currency
 * The function takes in 1 variable, (zero or a positive integer) _jackpotNativePrice. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates jackpotNativePrice as _jackpotNativePrice
*/
	function changeValueOf_jackpotNativePrice(uint256 _jackpotNativePrice) external onlyOwner {
		jackpotNativePrice  = _jackpotNativePrice;
	}

/**
 * Function changeValueOf_jackpotCoinPrice0
 * Notes for _jackpotCoinPrice0 : 10^18 represents 1 BEP20USDT
 * The function takes in 1 variable, (zero or a positive integer) _jackpotCoinPrice0. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates jackpotCoinPrice0 as _jackpotCoinPrice0
*/
	function changeValueOf_jackpotCoinPrice0(uint256 _jackpotCoinPrice0) external onlyOwner {
		jackpotCoinPrice0  = _jackpotCoinPrice0;
	}

/**
 * Function changeValueOf_jackpotCoinPrice1
 * Notes for _jackpotCoinPrice1 : 10^18 represents 1 TokenERC20
 * The function takes in 1 variable, (zero or a positive integer) _jackpotCoinPrice1. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates jackpotCoinPrice1 as _jackpotCoinPrice1
*/
	function changeValueOf_jackpotCoinPrice1(uint256 _jackpotCoinPrice1) external onlyOwner {
		jackpotCoinPrice1  = _jackpotCoinPrice1;
	}

/**
 * Function ownerWithdrawToken0
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (amount of native currency owned by the address of this contract) is greater than or equals to ((_amt) + (retainedForJackpotNative))
 * if _amt is strictly greater than 0 then (transfers _amt of the native currency to the address that called this function)
*/
	function ownerWithdrawToken0(uint256 _amt) public onlyOwner {
		require((address(this).balance >= (_amt + retainedForJackpotNative)), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((_amt > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : _amt}(""); require(success_1, "can't send money");
		}
	}

/**
 * Function ownerWithdrawToken1
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0x55d398326f99059fF775485246999027B3197955)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((_amt) + (retainedForJackpotCoin0))
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0x55d398326f99059fF775485246999027B3197955)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	function ownerWithdrawToken1(uint256 _amt) public onlyOwner {
		require((ERC20(address(0x55d398326f99059fF775485246999027B3197955)).balanceOf(address(this)) >= (_amt + retainedForJackpotCoin0)), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0x55d398326f99059fF775485246999027B3197955)).transfer(msg.sender, _amt);
		}
	}

/**
 * Function ownerWithdrawToken2
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0x59Cd90dF8AF3c8c6688038a6c028ddb5aA74D1e7)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((_amt) + (retainedForJackpotCoin1))
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0x59Cd90dF8AF3c8c6688038a6c028ddb5aA74D1e7)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	/**function ownerWithdrawToken2(uint256 _amt) public onlyOwner {
		require((ERC20(address(0x59Cd90dF8AF3c8c6688038a6c028ddb5aA74D1e7)).balanceOf(address(this)) >= (_amt + retainedForJackpotCoin1)), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0x59Cd90dF8AF3c8c6688038a6c028ddb5aA74D1e7)).transfer(msg.sender, _amt);
		}
	}*/

    function withdraw_USDT(uint256 _amount) public onlyOwner {
		require((ERC20(0x55d398326f99059fF775485246999027B3197955).balanceOf(address(this)) >= _amount), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		ERC20(0x55d398326f99059fF775485246999027B3197955).transfer(msg.sender, _amount);
	}
/**
 * Function playJackpot
 * The function takes in 0 variables. It can only be called by functions outside of this contract. It does the following :
 * checks that not paused
 * checks that (amount of native currency sent to contract) is equals to jackpotNativePrice
 * updates retainedForJackpotNative as (retainedForJackpotNative) + (((amount of native currency sent to contract) * ((1000000) - (taxRate))) / (1000000))
 * calls ERC20(Address 0x55d398326f99059fF775485246999027B3197955)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as jackpotCoinPrice0
 * updates retainedForJackpotCoin0 as (retainedForJackpotCoin0) + (((jackpotCoinPrice0) * ((1000000) - (taxRate))) / (1000000))
 * calls ERC20(Address 0x59Cd90dF8AF3c8c6688038a6c028ddb5aA74D1e7)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as jackpotCoinPrice1
 * updates retainedForJackpotCoin1 as (retainedForJackpotCoin1) + (((jackpotCoinPrice1) * ((1000000) - (taxRate))) / (1000000))
 * adds the address that called this function to players
 * emits event JackpotEntered with inputs the address that called this function, length of players
 * if (length of players) is equals to playerLimit then (creates an internal variable winningAddress with initial value players with element (random number with seed (length of players)) modulo (length of players); then checks that (amount of native currency owned by the address of this contract) is greater than or equals to retainedForJackpotNative; then if retainedForJackpotNative is strictly greater than 0 then (transfers retainedForJackpotNative of the native currency to winningAddress); then checks that (ERC20(Address 0x55d398326f99059fF775485246999027B3197955)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to retainedForJackpotCoin0; then if retainedForJackpotCoin0 is strictly greater than 0 then (calls ERC20(Address 0x55d398326f99059fF775485246999027B3197955)'s at transfer function  with variable recipient as winningAddress, variable amount as retainedForJackpotCoin0); then checks that (ERC20(Address 0x59Cd90dF8AF3c8c6688038a6c028ddb5aA74D1e7)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to retainedForJackpotCoin1; then if retainedForJackpotCoin1 is strictly greater than 0 then (calls ERC20(Address 0x59Cd90dF8AF3c8c6688038a6c028ddb5aA74D1e7)'s at transfer function  with variable recipient as winningAddress, variable amount as retainedForJackpotCoin1); then updates retainedForJackpotNative as 0; then updates retainedForJackpotCoin0 as 0; then updates retainedForJackpotCoin1 as 0; then updates players as Empty List; then adds winningAddress to winners; and then emits event JackpotDone with inputs winningAddress)
*/
	function playJackpot() external payable {
		require(!(paused), "Jackpot currently paused by owner");
		require((msg.value == jackpotNativePrice), "Incorrect Payment");
		//retainedForJackpotNative  = (retainedForJackpotNative + ((msg.value * (uint256(1000000) - taxRate)) / uint256(1000000)));
		ERC20(address(0x55d398326f99059fF775485246999027B3197955)).transferFrom(msg.sender, address(this), jackpotCoinPrice0);
		retainedForJackpotCoin0  = (retainedForJackpotCoin0 + ((jackpotCoinPrice0 * (uint256(1000000) - taxRate)) / uint256(1000000)));
		//ERC20(address(0x59Cd90dF8AF3c8c6688038a6c028ddb5aA74D1e7)).transferFrom(msg.sender, address(this), jackpotCoinPrice1);
		//retainedForJackpotCoin1  = (retainedForJackpotCoin1 + ((jackpotCoinPrice1 * (uint256(1000000) - taxRate)) / uint256(1000000)));
		players.push(msg.sender);
		emit JackpotEntered(msg.sender, (players).length);
		if (((players).length == playerLimit)){
			address winningAddress = players[(random((players).length) % (players).length)];
			/**require((address(this).balance >= retainedForJackpotNative), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
			if ((retainedForJackpotNative > uint256(0))){
				(bool success_1_1, ) =  payable(winningAddress).call{value : retainedForJackpotNative}(""); require(success_1_1, "can't send money");
			}*/
			require((ERC20(address(0x55d398326f99059fF775485246999027B3197955)).balanceOf(address(this)) >= retainedForJackpotCoin0), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
			if ((retainedForJackpotCoin0 > uint256(0))){
				ERC20(address(0x55d398326f99059fF775485246999027B3197955)).transfer(winningAddress, retainedForJackpotCoin0);
			}
			/**require((ERC20(address(0x59Cd90dF8AF3c8c6688038a6c028ddb5aA74D1e7)).balanceOf(address(this)) >= retainedForJackpotCoin1), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
			if ((retainedForJackpotCoin1 > uint256(0))){
				ERC20(address(0x59Cd90dF8AF3c8c6688038a6c028ddb5aA74D1e7)).transfer(winningAddress, retainedForJackpotCoin1);
			}*/
			//retainedForJackpotNative  = uint256(0);
			retainedForJackpotCoin0  = uint256(0);
			//retainedForJackpotCoin1  = uint256(0);
			players  = new address[](0);
			winners.push(winningAddress);
			emit JackpotDone(winningAddress);
		}
	}
}