{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}"},"index.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ncontract MarathonProtocol {\r\n\r\n    struct Participant {\r\n        uint256 stake;\r\n        uint256 lastWithdrawnSeason; \r\n        uint256 lastdeposit;\r\n        uint256 firstdeposit;\r\n        uint256 withdraw;\r\n        bool request;\r\n        mapping(uint256 =\u003e bool) withdrawnSeasons;  \r\n    }\r\n\r\n    struct Season {\r\n        uint256 time;\r\n        uint256 begin;\r\n        uint256 NET;\r\n        uint256 totalProfit;\r\n        uint256 totalLoss;\r\n        uint256 totalStakeAtTime;\r\n        bool ended;\r\n    }\r\n\r\n    mapping(address =\u003e Participant) public participants;\r\n    mapping(uint256 =\u003e Season) public seasons;\r\n\r\n    uint256 internal totalStake;\r\n    uint256 internal totalDeposits;\r\n\r\n    uint256 public totalUsers;\r\n\r\n    uint256 internal currentSeason = 1;\r\n\r\n    address public owner;\r\n    address internal team;\r\n\r\n    address internal rm;\r\n    address internal treasury;\r\n    address internal sec;\r\n\r\n    uint256 internal feeTeam = 100;\r\n    uint256 internal feeRm = 50;\r\n    uint256 internal feeTr = 25;\r\n\r\n    address[] public unstakeRequests; \r\n    address[] public allUsers; \r\n\r\n    uint256 internal minSTake = 1000 ether;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier hasStake() {\r\n        require(participants[msg.sender].stake \u003e 0, \"You have no stake in the contract\");\r\n        _;\r\n    }\r\n\r\n    IERC20 public usdtToken = IERC20(0x55d398326f99059fF775485246999027B3197955); //mainnet\r\n    //IERC20 public usdtToken = IERC20(0x32d277124D8a5Bc705ca8Af23579F599E8aCCDE7);\r\n\r\n    constructor(address _owner , address _team , address _rm, address _treasury , address _sec) {\r\n        owner = _owner;\r\n        team = _team;\r\n        rm = _rm;\r\n        treasury = _treasury;\r\n        sec = _sec;\r\n    }\r\n\r\n    function deposit(uint256 amount) external {\r\n        require(amount \u003e minSTake, \"You need to send some ether to deposit\");\r\n        require(usdtToken.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\r\n\r\n        if (participants[msg.sender].stake == 0) {\r\n            totalUsers += 1;\r\n            allUsers.push(msg.sender);\r\n            participants[msg.sender].firstdeposit = block.timestamp;  \r\n        }\r\n\r\n        participants[msg.sender].stake += amount;\r\n        participants[msg.sender].lastdeposit = block.timestamp;\r\n        totalStake += amount;\r\n        totalDeposits += amount;\r\n    }\r\n\r\n    function withdrawProfit(uint256 index) external hasStake {\r\n        require(seasons[index].begin \u003e= participants[msg.sender].lastdeposit, \"You cannot withdraw at this time\");\r\n        require(seasons[index].ended, \"Season has not ended yet\");\r\n        require(!participants[msg.sender].request, \"User has requested a withdrawal\");\r\n        require(!participants[msg.sender].withdrawnSeasons[index], \"You already withdrew profits for this season\");\r\n        \r\n        uint256 userStake = participants[msg.sender].stake;\r\n        uint256 seasonNetProfit;\r\n        seasons[index].totalProfit \u003e seasons[index].totalLoss ? seasonNetProfit = seasons[index].totalProfit - seasons[index].totalLoss : seasonNetProfit = 0;\r\n        uint256 profit = (seasonNetProfit * userStake) / seasons[index].totalStakeAtTime;\r\n        participants[msg.sender].withdraw += profit;\r\n        participants[msg.sender].lastWithdrawnSeason = index;\r\n        participants[msg.sender].withdrawnSeasons[index] = true;  // Mark the season as withdrawn for this user\r\n        usdtToken.transfer(msg.sender, profit);\r\n    }\r\n\r\n    function EmergencyUnStake() external hasStake {\r\n        require(participants[msg.sender].request == false,  \"Cannot request\");   \r\n        participants[msg.sender].request = true;\r\n        unstakeRequests.push(msg.sender);\r\n    }\r\n\r\n    function withdrawRquest() external hasStake {\r\n        require(participants[msg.sender].request == true,  \"Cannot request\");   \r\n        participants[msg.sender].request = false;\r\n        removeUnstakeRequest(msg.sender);\r\n    }\r\n    \r\n    function removeUnstakeRequest(address user) internal {\r\n        uint256 length = unstakeRequests.length;\r\n        for (uint256 i = 0; i \u003c length; i++) {\r\n            if (unstakeRequests[i] == user) {\r\n                if (i != length-1) {\r\n                    unstakeRequests[i] = unstakeRequests[length-1]; \r\n                }\r\n                unstakeRequests.pop(); \r\n                break; \r\n            }\r\n        }\r\n    }\r\n\r\n    function removeUser(address user) internal {\r\n        uint256 length = allUsers.length;\r\n        for (uint256 i = 0; i \u003c length; i++) {\r\n            if (allUsers[i] == user) {\r\n                if (i != length-1) {\r\n                    allUsers[i] = allUsers[length-1]; \r\n                }\r\n                allUsers.pop(); \r\n                break; \r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function distributeLoss(uint256 lossAmount) internal {\r\n        require(lossAmount \u003e 0 \u0026\u0026 lossAmount \u003c= totalStake, \"Invalid loss amount\");\r\n        uint256 lossPercentage = lossAmount * 1e18 / totalStake;  // Using 18 decimals for precision\r\n\r\n        for (uint256 i = 0; i \u003c allUsers.length; i++) {\r\n            address userAddress = allUsers[i];\r\n            if (participants[userAddress].firstdeposit \u003c= seasons[currentSeason].begin){\r\n            uint256 userLoss = participants[userAddress].stake * lossPercentage / 1e18; \r\n            participants[userAddress].stake -= userLoss;\r\n            }\r\n        }\r\n\r\n        totalStake -= lossAmount;\r\n    }\r\n\r\n    function payFees(uint256 _amount) internal returns(uint256){\r\n        uint256 tot = (_amount * feeTeam / 1000) + (_amount * feeRm / 1000) + (_amount * feeTr / 1000);\r\n        usdtToken.transfer(team, feeTeam * _amount / 1000);\r\n        usdtToken.transfer(rm, feeRm * _amount / 1000);\r\n        usdtToken.transfer(treasury, feeTr * _amount / 1000);\r\n        usdtToken.transfer(sec, feeTr * _amount / 1000);\r\n        return tot;\r\n    }\r\n\r\n    \r\n    function ownerWithdraw(uint256 amount) external onlyOwner {\r\n        require(amount \u003c= usdtToken.balanceOf(address(this)), \"Insufficient contract balance\");\r\n        usdtToken.transfer(msg.sender, amount);\r\n    }\r\n    \r\n    function closeSeason(uint256 profit, uint256 loss) external onlyOwner {\r\n        require(!seasons[currentSeason].ended, \"Current season has ended\");\r\n\r\n        uint256 NET;\r\n        uint256 fees;\r\n        if(profit \u003e= loss){\r\n            NET = profit - loss;\r\n            require(usdtToken.transferFrom(msg.sender, address(this), NET), \"Transfer failed\");\r\n            fees = payFees(NET);\r\n            NET -= fees;\r\n        } else {\r\n            NET = 0;\r\n            uint256 _loss = loss - profit;\r\n            distributeLoss(_loss);\r\n        } \r\n        seasons[currentSeason].NET += NET;\r\n        seasons[currentSeason].totalProfit += profit;\r\n        seasons[currentSeason].totalLoss += loss;\r\n        seasons[currentSeason].ended = true;\r\n        seasons[currentSeason].time = block.timestamp; \r\n        currentSeason++;\r\n        seasons[currentSeason].begin = block.timestamp; \r\n        seasons[currentSeason].totalStakeAtTime = totalStake;\r\n    }\r\n\r\n    \r\n    function changeTeamandFees(address _team , address _rm , address _treasury , address _sec , uint256 _feeTeam, uint256 _feerm, uint256 _feetr) external onlyOwner {\r\n        team = _team;\r\n        rm = _rm;\r\n        sec = _sec;\r\n        treasury = _treasury;\r\n        feeTeam = _feeTeam;\r\n        feeRm = _feerm;\r\n        feeTr = _feetr;\r\n    }\r\n\r\n    \r\n    function Refund(address user) external payable onlyOwner {\r\n\r\n        require(participants[user].stake \u003e 0 \u0026\u0026 participants[user].request == true,  \"Cannot refund\");\r\n        uint256 amount = participants[user].stake;\r\n        require(usdtToken.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\r\n\r\n        participants[user].request = false;\r\n        participants[user].stake = 0;\r\n        removeUnstakeRequest(user);  \r\n        removeUser(user);\r\n        usdtToken.transfer(user, amount);\r\n\r\n    }\r\n\r\n    function LaunchFirstSeason() external onlyOwner {\r\n        require(seasons[currentSeason].begin == 0 , \"already launched\");\r\n        seasons[currentSeason].begin = block.timestamp;\r\n        seasons[currentSeason].totalStakeAtTime = totalStake;\r\n    }\r\n\r\n    function changeMinIvestment(uint256 _minstake) external onlyOwner {\r\n        minSTake = _minstake;\r\n    }\r\n\r\n\r\n    function getUnstakeRequestCount() external view returns (uint256) {\r\n        return unstakeRequests.length;\r\n    }\r\n\r\n    function getfees() external view returns (uint256) {\r\n        return feeTeam + feeRm + feeTr;\r\n    }\r\n\r\n    function getSeason() external view returns (uint256) {\r\n        return currentSeason;\r\n    }\r\n\r\n    function getUnstakeRequestAddress(uint256 index) external view returns (address) {\r\n        require(index \u003c unstakeRequests.length, \"Index out of bounds\");\r\n        return unstakeRequests[index];\r\n    }\r\n\r\n    function getAllUnstakeRequests() external view returns (address[] memory) {\r\n        return unstakeRequests;\r\n    }\r\n\r\n    function Balance() external view returns (uint256) {\r\n        return usdtToken.balanceOf(address(this));\r\n    }\r\n\r\n    function Stakes() external view returns (uint256 , uint256) {\r\n        return (totalDeposits , totalStake);\r\n    }\r\n\r\n\r\n    function getWithdrawableAmount(uint256 index, address userAddress) public view returns (uint256) {\r\n\r\n        if (participants[userAddress].stake == 0 || participants[userAddress].request == true || participants[userAddress].withdrawnSeasons[index] || seasons[index].totalProfit \u003c= seasons[index].totalLoss) {\r\n            return 0;\r\n        }\r\n\r\n        if (!seasons[index].ended || seasons[index].begin \u003c= participants[userAddress].lastdeposit) {\r\n            return 0; \r\n        }\r\n\r\n        uint256 seasonNetProfit = seasons[index].totalProfit - seasons[index].totalLoss;\r\n        uint256 profit = (seasonNetProfit * participants[userAddress].stake) / seasons[index].totalStakeAtTime;\r\n\r\n        return profit;\r\n    }\r\n\r\n}"}}